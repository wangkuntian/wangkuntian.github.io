
<!DOCTYPE html>
<html lang="zh-en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Wang kuntian&#39;s Blog">
    <title>Python内置函数 - Wang kuntian&#39;s Blog</title>
    <meta name="author" content="Wang kuntian">
    
        <meta name="keywords" content="Python">
    
    
        <link rel="icon" href="https://wangkuntian.github.io/assets/images/favicon.png">
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Wang kuntian","sameAs":["https://github.com/wangkuntian","mailto:wangkuntian1994@163.com"],"image":"faker.jpg"},"articleBody":"Python 2.7的内置函数\n\n\n\n\nAabs()abs(x)返回数字的绝对值。\n参数可以是普通或长整数或浮点数。如果参数是一个复数，则返回其大小（复数的模）。\n123abs(-123) # 123abs(123)  # 123abs(complex(3, 4)) # 5.0\ncomplex()返回值为复数。\ncomplex(3,4)的返回值是3+4j。3+4j的模就是5。\n\n\nall()all(iterable)如果iterable的所有元素为真（或迭代器为空），返回True，否则返回False。\n123all([]) # Trueall[1, 2, 3]) # Trueall([1, 2, None]) # False\n等价于：\n12345def all(iterable):    for element in iterable:        if not element:            return False    return True\n\nany()any(iterable)如果iterable的任一元素为真则返回True。如果迭代器为空，返回False。\n1234any([]) # Falseany([None]) # Falseany([1, 2, None]) # Trueany([1, None, None]) # True\n等价于：\n12345def any(iterable):    for element in iterable:        if element:            return True    return False\n\nBbasestring()这个抽象类型是str和unicode的超类。它不能被调用或实例化，但它可以用于测试对象是str还是unicode的实例。isinstance(obj,basestring)等同于isinstance(obj,(str,unicode))\nbin()bin(x)将整数转换为二进制字符串。\n结果是一个有效的Python表达式。如果x不是Python int对象，则必须定义一个返回整数的_index_()方法。\n12bin(10) # 0b1010bin(100) # 0b1100100\n\nbool()class bool([x])返回一个布尔值，即True或False。\nx为True则返回值为True，x为False返回值为False。\n12345678bool() # Falsebool(0) # Falsebool(1) # Truebool([]) # Falsebool(&#123;&#125;) # Falsebool(()) # Falsebool(True) # Truebool(False) # True\n\nbytearray()class bytearray([source[, encoding[, errors]]])返回一个新的字节数组。bytearray类是 0 &lt;= x &lt;256 范围内的可变整数序列。\n可选形参 source 可以用不同的方式来初始化数组：\n\n如果是unicode，则还必须提供编码（和可选的，错误）参数，bytearray()使用unicode.encode()将unicode转换为字节。\n如果是一个integer，会初始化大小为该数字的数组，并使用null字节填充。\n如果是一个符合buffer接口的对象，该对象的只读buffer会用来初始化字节数组。\n如果是一个iterable可迭代对象，它的元素的范围必须是 0 &lt;= x &lt;256 的整数，它会被用作数组的初始内容。\n如果没有实参，则创建大小为0的数组。\n\nCcallable()callable(object)如果对象参数显示为可调用，则返回True，否则返回False。\n如果返回true，则调用仍然可能失败，但如果调用失败，则调用对象将永远不会成功。\n类是可调用的（调用类会返回一个新实例）。如果类实例具有_call_()方法，则它们是可调用的。\n\n\nchr()chr(i)返回一个字符串，其ASCII码为整数i。\n参数必须在[0..255]范围内。如果i超出该范围，则会引发ValueError。\n12chr(97) # achr(65) # A\n相对的方法是ord()。\n\n\nclassmethod()classmethod(function)返回一个函数的类方法。\n一个类方法把类自己作为第一个实参，就像一个实例方法把实例自己作为第一个实参。请用以下习惯来声明类方法:\n1234class C(object):    @classmethod    def f(cls, arg1, arg2, ...):        ...\n\ncmp()cmp(x, y)比较两个对象x和y并根据结果返回一个整数。\n如果x &lt; y则返回值为负，如果x == y则返回零，如果x &gt; y则返回为正\n123cmp(1, 1) # 0cmp(1, 2) # -1cmp(2, 1) # 1\n\ncompile()compile(source, filename, mode[, flags[, dont_inherit]])将源代码编译为代码或AST对象。代码对象可以由exec语句执行，也可以通过调用eval()来评估。\nsource可以是Unicode字符串，Latin-1编码字符串或AST对象。\nfilename实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 ‘‘）。\nmode实参指定了编译代码必须用的模式。如果source是语句序列，可以是exec；如果是单一表达式，可以是eval；如果是单个交互式语句，可以是single。（在最后一种情况下，如果表达式执行结果不是None将会被打印出来。）\n\n\ncomplex()class complex([real[, imag]])将字符串或数字转换为复数，返回值为real + imag * j。\n12complex(3,4) # (3+4j)complex(&#x27;3+4j&#x27;) # (3+4j)\n当从字符串转换时，字符串在 + 或 - 的周围必须不能有空格。例如complex(‘1+2j’)是合法的，但complex(‘1 + 2j’)会触发ValueError异常。\n\n\n\nDdelattr()delattr(object, name)setattr()相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如delattr(student, ‘name’)等价于del student.name。\n12345678910class Student(object):    def __init__(self, name, age):        self.name = name        self.age = agestudent = Student(name=&#x27;wkt&#x27;, age=24)print getattr(student, &#x27;name&#x27;) # wktdelattr(student, &#x27;name&#x27;)print getattr(student, &#x27;name&#x27;) # AttributeError\n\ndict()class dict(**kwarg)class dict(mapping, **kwarg)class dict(iterable, **kwarg)创建一个新的字典。\n123456a = dict(one=1, two=2, three=3)b = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;c = dict(zip([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;], [1, 2, 3]))d = dict([(&#x27;two&#x27;, 2), (&#x27;one&#x27;, 1), (&#x27;three&#x27;, 3)])e = dict(&#123;&#x27;three&#x27;: 3, &#x27;one&#x27;: 1, &#x27;two&#x27;: 2&#125;)a == b == c == d == e # True\n\ndir()dir([object])如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。\n如果对象有一个名为_dir_()的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义_getattr_()或__getattribute__()函数的对象能够自定义dir()来报告它们的属性。\n如果对象不提供_dir_()，这个函数会尝试从对象已定义的_dict_属性和类型对象收集信息。结果列表并不总是完整的，如果对象有自定义_getattr\\()，那结果可能不准确。\n默认的dir()机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：\n\n如果对象是模块对象，则列表包含模块的属性名称。\n如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。\n否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。\n返回的列表按字母表排序。\n\n12345import datetimedir() # [&#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;datetime&#x27;]dir(datetime) # [&#x27;MAXYEAR&#x27;, &#x27;MINYEAR&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;date&#x27;, &#x27;datetime&#x27;, &#x27;datetime_CAPI&#x27;, &#x27;time&#x27;, &#x27;timedelta&#x27;, &#x27;tzinfo&#x27;]\n\n1234567class Person(object):    def __dir__(self):        return [&#x27;name&#x27;, &#x27;sex&#x27;, &#x27;age&#x27;]p = Person()dir(p) # [&#x27;age&#x27;, &#x27;name&#x27;, &#x27;sex&#x27;]\n\ndivmod()divmod(a, b)取两个数（非复数）作为参数，返回由商和余数组成的一对数。\n对于普通类型和长整数，结果与(a // b，a ％ b)相同。\n对于浮点数，结果是(q, a ％ b)，其中q通常是math.floor(a / b)，但可能比该值小1。在任何情况下，q * b + a ％ b非常接近a，如果a％b非零，则其具有与b相同的符号，并且0 &lt;= abs(a ％ b) &lt; abs(b)。\n12divmod(1, 3)  # (0, 1)divmod(10, 4) # (2, 2)\n\n\nEenumerate()enumerate(sequence, start=0)返回一个枚举对象。 \nsequence必须是序列，迭代器或其他支持迭代的对象。\nenumerate（）返回的迭代器的next（）方法返回一个包含计数的元组（从start开始，默认为0）和迭代序列获得的值。\n123456seasons = [&#x27;spring&#x27;, &#x27;summer&#x27;, &#x27;autumn&#x27;, &#x27;winter&#x27;]list(enumerate(seasons))            # [(0, &#x27;spring&#x27;), (1, &#x27;summer&#x27;), (2, &#x27;autumn&#x27;), (3, &#x27;winter&#x27;)]list(enumerate(seasons, start=1))   # [(1, &#x27;spring&#x27;), (2, &#x27;summer&#x27;), (3, &#x27;autumn&#x27;), (4, &#x27;winter&#x27;)]\n相当于。\n12345def enumerate(sequence, start=0):    n = start    for elem in sequence:        yield n, elem        n += 1\n\neval()eval(expression[, globals[, locals]])参数是Unicode或Latin-1编码的字符串以及可选的全局变量和局部变量。如果提供，globals必须是字典。如果提供，则locals可以是任何映射对象。\n表达式参数作为Python表达式（技术上讲，条件列表）被解析和评估，使用全局变量和本地字典作为全局和本地名称空间。如果全局字典存在且缺少‘__builtins__’，则在解析表达式之前将当前全局变量复制到全局变量中。这意味着表达式通常具有对标准__builtin__模块的完全访问权限，并且传播受限制的环境。如果省略locals字典，则默认为globals字典。如果省略两个字典，则表达式在调用eval()的环境中执行。返回值是计算表达式的结果。语法错误报告为异常。\n12x = 10eval(&#x27; x + 20 &#x27;)  # 30\n此函数还可用于执行任意代码对象（例如由compile()创建的代码对象）。在这种情况下，传递代码对象而不是字符串。如果代码对象已使用’exec’作为mode参数进行编译，则eval()的返回值将为None。\nexec语句支持动态执行语句。execfile()函数支持从文件执行语句。globals()和locals()函数分别返回当前的全局和本地字典，这对于传递以供eval()或execfile()使用很有用。\n\n\nexecfile()execfile(filename[, globals[, locals]])此函数类似于exec语句，但解析文件而不是字符串。它与import语句的不同之处在于它不使用模块管理 - 它无条件地读取文件并且不创建新模块。\n参数是文件名和两个可选字典。使用全局和本地字典作为全局和本地命名空间，将文件解析并评估为一系列Python语句（类似于模块）。如果提供，则locals可以是任何映射对象。请记住，在模块级别，全局变量和本地变量是相同的字典。如果将两个单独的对象作为全局变量和局部变量传递，则代码将被执行，就像它嵌入在类定义中一样。如果省略locals字典，则默认为globals字典。如果省略两个字典，则表达式在调用execfile（）的环境中执行。返回值为None。\n默认的locals的行为与下面的函数locals()相同：不应尝试修改默认的locals字典。如果需要在函数execfile()返回后查看代码对locals的影响，则传递显式的locals字典。execfile()不能可靠地用于修改函数的本地。\n\n\n\nFfile()file(name[, mode[, buffering]])文件类型的构造函数，在文件对象一节中进一步描述。构造函数的参数与下面描述的open()内置函数的参数相同。打开文件时，最好使用open()而不是直接调用此构造函数。file更适合于类型测试（例如，写入isinstance(f，file)）。\nfilter()filter(function, iterable)从iterable的那些元素构造一个列表，该函数返回true。\niterable可以是序列，支持迭代的容器，也可以是迭代器。\n如果iterable是字符串或元组，则结果也具有该类型;否则它总是一个列表。如果function为None，即删除所有可迭代的false元素。\n请注意，如果函数不是None，则filter（function，iterable）等效于[item for item in iterable if function(item)]，如果函数为None，则[item for item in iterable if item]。\n123456789x = range(1, 10)# [1, 2, 3, 4, 5, 6, 7, 8, 9]filter(lambda item: item if item % 2 == 0 else None, x)# [2, 4, 6, 8][item for item in x if item % 2 == 0]# [2, 4, 6, 8]\n\nfloat()class float([x])返回由数字或字符串x构造的浮点数。\n如果参数是字符串，则它必须包含可能已赋值的decimal或浮点数，可能嵌入在空格中。参数也可以是[+|-]nan或[+|-] inf。否则，参数可以是普通或长整数或浮点数，并返回具有相同值（在Python的浮点精度内）的浮点数。\n如果没有给出参数，则返回0.0。\nformat()format(value[, format_spec])将值转换为“格式化”表示，由format_spec控制。format_spec的解释取决于value参数的类型，但是大多数内置类型都使用标准格式化语法：Format Specification Mini-Language。\nformat(value, format_spec)只调用value.format(format_spec)。\n\n1&#x27;hello &#123;0&#125;&#x27;.format(&#x27;world&#x27;) # hello world\n\nfrozenset()class frozenset([iterable])返回一个新的frozenset对象，可选地包含从iterable中获取的元素。返回一个新的set或frozenset对象，其元素取自iterable。集合的元素必须是可以清除的。要表示集合集，内部集合必须是冻结集合对象。如果未指定iterable，则返回新的空集。\nGgetattr()getattr(object, name[, default])返回对象命名属性的值。\nname必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。\n例如，getattr(x, ‘foobar’)等同于x.foobar。如果指定的属性不存在，且提供了default值，则返回它，否则触发AttributeError。\nglobals()返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。\nHhasattr()hasattr(object, name)参数是一个对象和一个字符串。如果字符串是对象属性之一的名称，则结果为True，否则为False。（这是通过调用getattr(object,name)并查看它是否引发异常来实现的。）\nhash()hash(object)返回对象的哈希值（如果有的话）。哈希值是整数，它们用于在字典查找期间快速比较字典键。相等的数字值具有相同的哈希值（即使它们具有不同的类型，如1和1.0的情况）。\nhelp()help([object])启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。\n该函数通过 site 模块加入到内置命名空间。\n\n\nhex()hex(x)将整数（任意大小）转换为前缀为“0x”的小写十六进制字符串。\n123hex(255)    # 0xffhex(-220)   # -0xdchex(1L)     # 0x1L\n如果x不是int或long对象，则必须定义一个返回字符串的hex()方法。\n\n\n如果要获取浮点数的十六进制字符串形式，请使用float.hex()方法。\n\n\nIid()id(object)返回对象的“标识”。这是一个整数（或长整数），保证在该生命周期内该对象是唯一且恒定的。\n具有非重叠生存期的两个对象可以具有相同的id()值。\nid()返回的值是内存中对象的地址。\n\n\ninput()input([prompt])相当于eval(raw_input(prompt))。\n此功能不会捕获用户错误。如果输入语法无效，则会引发SyntaxError。如果评估期间出现错误，可能会引发其他异常。所以应该使用raw_input()函数来获取用户的常规输入。\n如果加载了readline模块，input()将使用它来提供复杂的行编辑和历史记录功能。\nint()class int(x=0)class int(x, base=10)返回由数字或字符串x构造的整数对象，如果没有给出参数，则返回0。\n如果x是数字，则它可以是普通整数，长整数或浮点数。\n如果x是浮点，则转换将截断为零。\n如果参数超出整数范围，则函数返回一个long对象。\n如果x不是数字或者给定了base，那么x必须是一个字符串或Unicode对象，表示以radix为基数的整数文字。可选地，文字可以在前面加+或-（之间没有空格）并且用空格包围。base-n文字由数字0到n-1组成，a到z（或A到Z）的值为10到35。\n默认base为10。允许的值为0和2-36。 Base-2，-8和-16文字可以选择以0b/0B，0o/0O/0或0x/0X作为前缀，与代码中的整数文字一样。Base0表示将字符串完全解释为整数文字，因此实际基数为2，8，10或16。\n12345678int()                   # 0int(1.1)                # 1int(&#x27;11111&#x27;, base=2)    # 31int(&#x27;11111&#x27;, base=4)    # 341int(&#x27;11111&#x27;, base=8)    # 4681int(&#x27;11111&#x27;, base=16)   # 69905int(&#x27;0xa&#x27;, base=16)     # 10int(&#x27;11111&#x27;, base=0)    # 11111\n\nisinstance()isinstance(object, classinfo)如果object参数是classinfo参数的实例，或者是（直接，间接或虚拟）子类的实例，则返回true。\n如果classinfo是类型对象（新样式类）并且object是该类型的对象或其（直接，间接或虚拟）子类，则也返回true。\n如果object不是类实例或给定类型的对象，则该函数始终返回false。\n如果classinfo是某一个类或类型对象的元组（或递归地，其他此类元组），则如果object是这个类或这种类型的实例，则返回true。\n如果classinfo不是类，类型和类的元组或类型的元组，则会引发TypeError异常。\nissubclass()issubclass(class, classinfo)如果class是classinfo的子类（直接、间接或虚拟的），则返回true。\nclassinfo可以是类对象的元组，此时 classinfo 中的每个元素都会被检查。\n其他情况，会触发TypeError异常。\niter()iter(o[, sentinel])返回一个迭代器对象。\n如果没有第二个参数，o必须是支持迭代协议（__iter__()方法）的集合对象，或者它必须支持序列协议（__getitem__()方法，整数参数从0开始）。\n如果它不支持这些协议中的任何一个，则引发TypeError。\n如果给出第二个参数sentinel，则o必须是可调用对象。在这种情况下创建的迭代器将为每个对next（）方法的调用调用o而不带参数；如果返回的值等于sentinel，则会引发StopIteration，否则返回该值。\n12345678910it = iter(range(0, 10))while True:    try:        x = next(it)        print x,    except StopIteration:        break# 0 1 2 3 4 5 6 7 8 9\n\n\n第二种形式的iter()的一个有用的应用是读取文件的行直到达到某一行。以下示例读取文件，直到readline()方法返回空字符串。\n123with open(&#x27;mydata.txt&#x27;) as fp:    for line in iter(fp.readline, &#x27;&#x27;):        process_line(line)\nLlen()len(s)返回对象的长度（元素个数）。\n实参可以是序列（如string、bytes、tuple、list或range等）或集合（如dictionary、set或frozen set等）。\nlist()class list([iterable])返回一个列表，其项目与iterable的项目相同且顺序相同。\niterable可以是序列，支持迭代的容器，也可以是迭代器对象。如果iterable已经是一个列表，则会生成并返回一个副本，类似于iterable[:]。例如，list(‘abc’)返回[‘a’,’b’,’c’]和list((1,2,3))返回[1,2,3]。\n如果没有给出参数，则返回一个新的空列表，[]。\nlist是一个可变序列类型。\nlocals()locals()更新并返回表示当前本地符号表的字典。locals()在函数块中调用时返回自由变量，但在类块中不调用。\nlong()class long(x=0)class long(x, base=10)返回由字符串或数字x构造的长整型对象。\n如果参数是一个字符串，它必须包含一个可能赋值的任意大小的数字，可能嵌入在空格中。\nbase参数的解释方式与int()相同，并且只能在x为字符串时给出。\n否则，参数可以是普通或长整数或浮点数，并返回具有相同值的长整数。将浮点数转换为整数截断（朝向零）。如果没有给出参数，则返回0L。\n123456long()                  # 0long(&#x27;111&#x27;, base=2)     # 7long(&#x27;111&#x27;, base=10)    # 111long(&#x27;111&#x27;, base=16)    # 273long(1.11)              # 1long(0.11)              # 0\nMmap()map(function, iterable, …)将函数应用于iterable的每个项目并返回结果列表。\n如果传递了多个可迭代参数，则函数必须采用所有参数，并且并行地应用于所有迭代的项。\n如果一个iterable比另一个短，则假定使用None项扩展。\n如果function为None，则假定为identity函数；如果有多个参数，map()返回一个由包含所有迭代中相应项的元组组成的列表（一种转置操作）。可迭代参数可以是序列或任何可迭代对象；结果始终是一个列表。\n1234567891011121314def add(x, y):    if x and y:        return x + y    else:        return x if x else yl1 = range(1, 4)            # [1, 2, 3]l2 = range(1, 6)            # [1, 2, 3, 4, 5]map(None, l1)               # [1, 2, 3]map(lambda x: x + 1, l1)    # [2, 3, 4]map(None, l1, l2)           # [(1, 1), (2, 2), (3, 3), (None, 4), (None, 5)]map(add, l1, l2)            # [2, 4, 6, 4, 5]map(lambda x, y: x + y if x and y else x if x else y, l1, l2)   # [2, 4, 6, 4, 5]\n\nmax()max(iterable[, key])max(arg1, arg2, *args[, key])返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。\n如果提供了一个位置参数，则iterable必须是非空的可迭代（例如非空字符串，元组或列表）。\n返回iterable中的最大项。如果提供了两个或多个位置参数，则返回最大的位置参数。\n可选的key参数指定一个单参数排序函数，就像用于list.sort()的函数一样。键参数（如果提供）必须采用关键字形式（例如，max(a, b, c, key = func)）。\n12345max(-3, 2)                                  # 2max(-3, 2, key=lambda x: x * x)             # -3max(range(0, 1), range(0, 3), range(0, 6))  # [0, 1, 2, 3, 4, 5]max(range(0, 10))                           # 9max(range(0, 10), key=lambda x: x * -1)     # 0\n\nmemoryview()memoryview(obj)返回由给定实参创建的“内存视图”对象。\n123456v = memoryview(&#x27;abc&#x27;)   # &lt;memory at 0x10e7c03e0&gt;type(v)                 # &lt;type &#x27;memoryview&#x27;&gt;v.tobytes()             # abcv.tolist()              # [97, 98, 99]v.itemsize              # 1v.readonly              # True\n\nmin(）min(iterable[, key])min(arg1, arg2, *args[, key])\n返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。\n如果提供了一个位置参数，则iterable必须是非空的可迭代（例如非空字符串，元组或列表）。\n返回iterable中的最小项。如果提供了两个或多个位置参数，则返回最小的位置参数。\n可选的key参数指定一个单参数排序函数，就像用于list.sort()的函数一样。键参数（如果提供）必须采用关键字形式（例如，min(a, b, c, key=func)）。\n12345min(-3, 2)                                  # -3min(-3, 2, key=lambda x: x * x)             # 2min(range(0, 1), range(0, 3), range(0, 6))  # [0]min(range(0, 10))                           # 0min(range(0, 10), key=lambda x: x * -1)     # 9\n\nNnext()next(iterator[, default])通过调用next()方法从迭代器中检索下一个项目。如果给定default，则在迭代器耗尽时返回，否则引发StopIteration。\n12345678it = iter(range(0, 10))while True:    s = next(it, -1)    print s,    if s == -1:        break# 0 1 2 3 4 5 6 7 8 9 -1\n\nOobject()class object返回一个新的无特征对象。object是所有新样式类的基础。它具有新样式类的所有实例共有的方法。\n此函数不接受任何参数。以前，它接受了参数但忽略了它们。\n\n\noct()oct(x)将整数（任意大小）转换为八进制字符串。结果是一个有效的Python表达式。\n123oct(8)      # 010oct(18)     # 022oct(-128)   # -0200\n\nopen()open(name[, mode[, buffering]])\n打开文件，返回文件对象部分中描述的文件类型的对象。如果无法打开文件，则引发**IOError**。打开文件时，最好使用open()而不是直接调用文件构造函数。\n\n前两个参数与stdio的fopen()相同：name是要打开的文件名，mode是一个字符串，表示如何打开文件。\n最常用的模式值是'r'用于读取，'w'用于写入（截断文件，如果它已经存在），'a'用于追加（在某些Unix系统上意味着所有写入都附加到文件的末尾而不管当前的搜索位置）。如果省略mode，则默认为'r'。默认设置是使用文本模式，可以在写入时将“\\n”字符转换为特定于平台的表示，并在读取时返回。因此，在打开二进制文件时，您应该将'b'附加到模式值以在二进制模式下打开文件，这将提高可移植性。\n\n可选的buffering参数指定文件所需的缓冲区大小：0表示无缓冲，1表示行缓冲，任何其他正值表示使用（大约）该大小（以字节为单位）的缓冲区。负缓冲意味着使用系统默认值，通常为tty设备进行行缓冲，并为其他文件进行完全缓冲。如果省略，则使用系统默认值。\n模式’r +’，’w +’和’a +’打开文件进行更新（读写）;请注意’w +’会截断文件。在区分二进制文件和文本文件的系统上，将“b”附加到模式以在二进制模式下打开文件；在没有这种区别的系统上，添加’b’没有效果。\n除了标准的fopen（）值模式可以是’U’或’rU’。Python通常使用通用换行符支持构建；提供“U”将文件作为文本文件打开，但行可以通过以下任何一种方式终止：Unix行尾约定’\\n’，Macintosh约定’\\r’或Windows约定’\\r\\n’。所有这些外部表示都被Python程序视为’\\n’。如果在没有通用换行符的情况下构建Python，则使用“U”的模式与普通文本模式相同。请注意，如此打开的文件对象也有一个名为newlines的属性，其值为None（如果尚未看到换行符）、’\\n’、’\\r’、’\\r\\n’或包含所有元组的元组看到的换行类型。\nPython强制执行模式，在剥离’U’后，以’r’，’w’或’a’开头。\nPython提供了许多文件处理模块，包括fileinput，os，os.path，tempfile和shutil。\nord()ord(c)给定一个长度为1的字符串，当参数是unicode对象时，或者参数是8位字符串时的字节值。，返回表示字符的Unicode代码点的整数。\n例如，ord(‘a’)返回整数97，ord(u’\\u2020’)返回8224。这是8位字符串的chr()和unicode对象的unichr()的反转。如果给出了unicode参数并且Python是使用UCS2 Unicode构建的，则字符的代码点必须在[0..65535]范围内；否则字符串长度为2，将引发TypeError。\n1234ord(&#x27;A&#x27;)        # 65chr(65)         # Aunichr(65)      # Aord(u&#x27;\\u1024&#x27;)  # 4132\n\nPpow()pow(x, y[, z])返回x的y次幂；如果z存在，则对z取余（比直接pow(x, y)%z计算更高效）。两个参数形式的pow(x, y)等价于幂运算符：x**y。\n参数必须具有数字类型。对于混合操作数类型，二进制算术运算符的强制规则适用。\n对于int和long int操作数，结果与操作数具有相同的类型（在强制类型转换之后），除非第二个参数为负；在这种情况下，所有参数都转换为float并传递float结果。例如，10**2返回100，但10**-2返回0.01。\n如果第二个参数为负数，则必须省略第三个参数。如果存在z，则x和y必须是整数类型，y必须是非负的。\n\n\n1234567pow(2, 10)      # 10242 ** 10         # 1024pow(2, -10)     # 0.00097656252 ** -10        # 0.0009765625pow(2, 10, 10)  # 42 ** 10 % 10    # 4pow(2, -10, 10) # TypeError\n\nprint()print(*objects, sep=’ ‘, end=’\\n’, file=sys.stdout)将对象打印到流文件，由sep分隔，然后结束。 sep，end和file（如果存在）必须作为关键字参数给出。\n所有非关键字参数都会被转换为字符串，就像是执行了str()一样，并会被写入到流，以sep且在末尾加上 end。sep和end都必须为字符串；它们也可以为None，这意味着使用默认值。如果没有给出objects，则 print()将只写入end。\nfile参数必须是带有write(string)方法的对象;如果它不存在或None，将使用sys.stdout。输出缓冲由文件确定。例如，使用file.flush()确保在屏幕上立即显示。\n此功能通常不作为内置函数提供，因为名称print被识别为print语句。要禁用该语句并使用print()函数，请在模块顶部使用此future语句：\n1from __future__ import print_function\n\nproperty()class property([fget[, fset[, fdel[, doc]]]])\n返回新样式类（从object派生的类）的属性。\nfget是获取属性值的函数。fset是用于设置属性值的函数。fdel是用于删除属性值的函数。并且doc为属性对象创建文档字符串。一个典型的用法是定义一个托管属性x:\n1234567891011121314class C(object):    def __init__(self):        self._x = None    def getx(self):        return self._x    def setx(self, value):        self._x = value    def delx(self):        del self._x    x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)\n如果c是C的实例，c.x将调用getter，c.x = value将调用setter，delc.x将调用deleter。\n如果给出，doc将成为该property属性的文档字符串。否则该property将拷贝fget的文档字符串（如果存在）。这令使用property() 作为decorator来创建只读的特征属性可以很容易地实现：\n12345678class Parrot(object):    def __init__(self):        self._voltage = 100000    @property    def voltage(self):        &quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;        return self._voltage\n以上@property装饰器会将voltage()方法转化为一个具有相同名称的只读属性的“getter”，并将voltage的文档字符串设置为“Get the current voltage.”\n特征属性对象具有getter，setter以及deleter方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。这最好是用一个例子来解释:\n12345678910111213141516class C(object):    def __init__(self):        self._x = None    @property    def x(self):        &quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;        return self._x    @x.setter    def x(self, value):        self._x = value    @x.deleter    def x(self):        del self._x\n上述代码与第一个例子完全等价。注意一定要给附加函数与原始的特征属性相同的名称(在本例中为x)。返回的特征属性对象同样具有与构造器参数相对应的属性fget，fset和fdel。\nRrangerange(stop)range(start, stop[, step])这是一个用于创建包含算术进度的列表的通用函数。它最常用于for循环。\n参数必须是普通整数。如果省略step参数，则默认为1。如果省略start参数，则默认为0。\n完整形式返回普通整数列表[start，start + step，start + 2 * step，…]。\n\n\n如果step为正，则最后一个元素是最大的start + i * step小于stop；如果step为负数，则最后一个元素是最小的start + i * step大于stop。step不能为零，否则引发ValueError。\n12345678910111213141516range(10)# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]range(1, 11)# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]range(0, 30, 5)# [0, 5, 10, 15, 20, 25]range(0, 10, 3)# [0, 3, 6, 9]range(0, -10, -1)# [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]range(0)# []range(1, 0)# []range(0, 10, -1)# []\n\nraw_input()raw_input([prompt])如果存在prompt参数，则将其写入标准输出而不带尾随换行符。该函数从输入中读取一行，将其转换为字符串（剥离尾部换行符），然后返回该行。读取EOF时，会引发EOFError。\n12s = raw_input(&quot;what&#x27;s your name?\\n&quot;)    # wangkuntianprint s                                 # wangkuntian\n如果加载了readline模块，则raw_input()将使用它来提供精细的行编辑和历史记录功能。\nreduce()reduce(function, iterable[, initializer])从左到右累加两个参数的函数到iterable项，以便将iterable减少为单个值。例如，reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])计算的是((((1+2)+3)+4)+5)的值。左参数x是累加值，右参数y是迭代的更新值。如果存在可选的initializer设定项，则它将放置在计算中的iterable项之前，并在iterable为空时用作默认值。如果未给出initializer且iterable只包含一项，则返回第一项。大致相当于：\n1234567891011def reduce(function, iterable, initializer=None):    it = iter(iterable)    if initializer is None:        try:            initializer = next(it)        except StopIteration:            raise TypeError(&#x27;reduce() of empty sequence with no initial value&#x27;)    accum_value = initializer    for x in it:        accum_value = function(accum_value, x)    return accum_value\n\nreload()reload(module)重新加载以前导入的模块。参数必须是模块对象，因此必须先成功导入。如果您使用外部编辑器编辑了模块源文件并希望在不离开Python解释器的情况下试用新版本，这将非常有用。返回值是模块对象（与模块参数相同）。\n执行重载（模块）时：\n\n重新编译Python模块的代码并重新执行模块级代码，定义一组新的对象，这些对象绑定到模块字典中的名称。扩展模块的init功能不会第二次调用。\n与Python中的所有其他对象一样，只有在引用计数降为零后才会回收旧对象。\n模块名称空间中的名称将更新为指向任何新对象或已更改的对象。\n对旧对象的其他引用（例如模块外部的名称）不会反弹以引用新对象，如果需要，必须在每个命名空间中进行更新。\n\n还有其他一些警告：重新加载模块时，将保留其字典（包含模块的全局变量）。名称的重新定义将覆盖旧的定义，因此这通常不是问题。如果新版本的模块未定义旧版本定义的名称，则旧定义仍然存在。如果模块维护对象的全局表或缓存，则此功能可用于模块的优势 - 使用try语句可以测试表的存在并在需要时跳过其初始化：\n1234try:    cacheexcept NameError:    cache = &#123;&#125;\n\n重新加载内置或动态加载的模块通常不是很有用。不建议重新加载sys，__main__，builtins和其他关键模块。在许多情况下，扩展模块不是设计为多次初始化，并且在重新加载时可能以任意方式失败。\n如果一个模块使用from … import …从另一个模块导入对象，则为另一个模块调用reload（）不会重新定义从它导入的对象 - 一种方法是重新执行from语句，另一种方法是使用导入和限定名称（module.*name*）。\n如果模块实例化类的实例，则重新加载定义类的模块不会影响实例的方法定义 - 它们继续使用旧的类定义。派生类也是如此。\nrepr()repr(object)返回包含对象的可打印表示的字符串。这与转换（反向引号）产生的值相同。\n能够以普通函数的形式访问此操作有时很有用。对于许多类型，此函数尝试返回一个字符串，该字符串在传递给eval()时会产生具有相同值的对象，否则表示是一个括在尖括号中的字符串，其中包含对象类型的名称以及通常包括对象名称和地址的附加信息。\n类可以通过定义__repr__()方法来控制此函数为其实例返回的内容。\n1234567891011121314repr(123)                       # 123repr(&#x27;123&#x27;)                     # &#x27;123&#x27;repr(object())                  # &lt;object object at 0x10e8b50f0&gt;class Student(object):    def __init__(self, name):        self.name = name    def __repr__(self):        return &#x27;The student is %s&#x27; % self.namerepr(Student(&#x27;wangkuntian&#x27;))    # The student is wangkuntian\n\nreversed()reversed(seq)返回一个反向的 iterator。seq必须是一个具有__reversed__()方法的对象或者是支持该序列协议（具有从0开始的整数类型参数的__len__()方法和__getitem__()方法）。\n12list(reversed(range(10)))# [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\nround()round(number[, ndigits])返回舍入到小数点后的ndigits数字的浮点值数字。如果省略ndigits，则默认为零。\n结果是一个浮点数。将值四舍五入为函数减去ndigits的最接近的10的倍数；如果两个倍数相等，则舍入远离0（因此，例如，round(0.5)为1.0，round(-0.5)为-1.0）。\n对浮点数执行round()的行为可能会令人惊讶：例如，round(2.675, 2)将给出2.67而不是期望的2.68。这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。\n\n\nSset()class set([iterable])返回一个新的set对象，可以选择带有从iterable获取的元素。set是一个内置类型。\nsetattr()setattr(object, name, value)此函数与getattr()两相对应。其参数为一个对象、一个字符串和一个任意值。字符串指定一个现有属性或者新增属性。函数会将值赋给该属性，只要对象允许这种操作。例如，setattr(x, ‘foobar’, 123)等价于 x.foobar = 123。\nslice()class slice(stop)class slice(start, stop[, step])返回一个表示由range(start, stop, step)所指定索引集的slice对象。其中start和step参数默认为None。\n切片对象具有仅会返回对应参数值（或其默认值）的只读数据属性start，stop 和 step。它们没有其他的显式功能；不过它们会被NumPy以及其他第三方扩展所使用。切片对象也会在使用扩展索引语法时被生成。例如：a[start:stop:step]或a[start:stop, i]。\nsorted()sorted(iterable[, cmp[, key[, reverse]]])根据 iterable 中的项返回一个新的已排序列表。\n可选参数cmp，key和reverse与list.sort（）方法的含义相同。\ncmp指定两个参数（可迭代元素）的自定义比较函数，它应返回负数，零或正数，具体取决于第一个参数是否被认为小于，等于或大于第二个参数：cmp=lambda x, y: cmp(x.lower(), y.lower())。默认值为None。\nkey指定一个参数的函数，该函数用于从每个列表元素中提取比较键：key=str.lower。默认值为None（直接比较元素）。\n内置的sorted()确保是稳定的。如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 — 这有利于进行多重排序（例如先按部门、再按薪级排序）。\n\n123456789101112131415161718import randomclass Student(object):    def __init__(self, name):        self.name = name    def __repr__(self):        return &#x27;student: %s&#x27; % self.namestudents = [Student(str(random.randint(0, 5))) for i in range(0, 5)]# [student: 3, student: 0, student: 5, student: 2, student: 4]sorted(students, cmp=lambda x, y: cmp(x.name, y.name))# [student: 0, student: 2, student: 3, student: 4, student: 5]sorted(students, key=lambda x: x.name)# [student: 0, student: 2, student: 3, student: 4, student: 5]\nstaticmethod()staticmethod(function)返回一个静态的函数方法。静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法：\n1234class C(object):    @staticmethod    def f(arg1, arg2, ...):        ...\n静态方法的调用可以在类上进行(例如C.f())也可以在实例上进行(例如C().f())。\n\n\nstr()class str(object=’’)返回一个包含对象的可打印表示的字符串。\n对于字符串，这将返回字符串本身。与repr(object)的区别在于str(object)并不总是尝试返回eval()可接受的字符串；它的目标是返回一个可打印的字符串。\n如果没有给出参数，则返回空字符串’’。\nsum()sum(iterable[, start])从start开始自左向右对iterable中的项求和并返回总计值。 \nstart默认为0。iterable的项通常为数字，开始值则不允许为字符串。\n对某些用例来说，存在sum()的更好替代。拼接字符串序列的更好更快方式是调用’’.join(sequence)。要以扩展精度对浮点值求和，请参阅math.fsum()。要拼接一系列可迭代对象，请考虑使用itertools.chain()。\n\n\n12x = range(0, 10)    # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]sum(x, 10)          # 55\n\nsuper()super(type[, object-or-type])返回一个代理对象，它会将方法调用委托给type指定的父类或兄弟类。这对于访问已在类中被重载的继承方法很有用。搜索顺序与 getattr()所使用的相同，只是type指定的类型本身会被跳过。\ntype的__mro__属性列出了getattr()和super()所使用的方法解析顺序。该属性是动态的，可以在继承层级结构更新的时候任意改变。\n如果省略第二个参数，则返回的超类对象是未绑定的。如果第二个参数为一个对象，则isinstance(obj, type)必须为真值。如果第二个参数为一个类型，则issubclass(type2, type)必须为真值（这适用于类方法）。\nsuper()仅适用于新式类。\n\n\nsuper 有两个典型用例。 \n\n在具有单继承的类层级结构中，super可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。这种用法与其他编程语言中super的用法非常相似。\n用例是在动态执行环境中支持协作多重继承。此用例为Python所独有，在静态编译语言或仅支持单继承的语言中是不存在的。这使得实现“菱形图”成为可能，在这时会有多个基类实现相同的方法。好的设计强制要求这种方法在每个情况下具有相同的调用签名（因为调用顺序是在运行时确定的，也因为该顺序要适应类层级结构的更改，还因为该顺序可能包含在运行时之前未知的兄弟类）。\n\n123class C(B):    def method(self, arg):        super(C, self).method(arg)\n请注意super()是作为显式加点属性查找的绑定过程的一部分来实现的，例如super().__getitem__(name)。它做到这一点是通过实现自己的__getattribute__()方法，这样就能以可预测的顺序搜索类，并且支持协作多重继承。对应地，super()在像 super()[name]这样使用语句或操作符进行隐式查找时则未被定义。\n另请注意，super（）不限于使用内部方法。两个参数形式完全指定参数并进行适当的引用。\n\n\nTtuple()tuple([iterable])返回一个元组，其元素与iterable的项目相同且顺序相同。\niterable可以是一个序列，一个支持迭代的容器，或一个迭代器对象。如果iterable已经是一个元组，则返回不变。例如，tuple(‘abc’)返回(‘a’, ‘b’, ‘c’)和tuple([1, 2, 3])返回(1, 2, 3)。如果没有给出参数，则返回一个新的空元组()。\ntuple（元组）是一个不可变的序列类型。\n\n\ntype()class type(object)class type(name, bases, dict)使用一个参数时，返回对象的类型。返回值是一个类型对象。建议使用isinstance()内置函数来测试对象的类型。\n使用三个参数时，返回一个新类型对象。这实际上是类语句的动态形式。名称字符串是类名，并成为__name__属性；base元组列出基类并成为__bases__属性；dict字典是包含类体定义的命名空间，并成为__dict__属性。例如，以下两个语句创建相同的类型对象：\n1234class X(object):    a = 1X = type(&#x27;X&#x27;, (object,), dict(a=1))\n\nUunichr()unichr(i)返回Unicode代码为整数i的一个字符的Unicode字符串。例如，unichr(97)返回字符串u’a’。这是Unicode字符串的ord()的反转。\n参数的有效范围取决于Python的配置方式 - 可能是UCS2[0..0xFFFF]或UCS4[0..0x10FFFF]。否则会引发ValueError。\n12ord(&#x27;A&#x27;)    # 65unichr(65)  # A\n\nunicode()unicode(object=’’)unicode(object[, encoding[, errors]])使用以下模式之一返回对象的Unicode字符串版本：\n\n如果给出了encoding和/或errors，unicode()将使用编解码器解码对象，该对象可以是8位字符串或字符缓冲区。encoding参数是一个给出编码名称的字符串；如果编码未知，则引发LookupError。错误处理是根据错误完成的；这指定了对输入编码中无效的字符的处理。如果错误是’strict’（默认值），则会在出现错误时引发ValueError，而值为’ignore’会导致错误被忽略，值为’replace’会导致官方Unicode替换字符，U+FFFD替换无法解码的输入字符。\n如果没有给出可选参数，unicode()将模仿str()的行为，返回Unicode字符串而不是8位字符串。更确切地说，如果object是Unicode字符串或子类，它将返回该Unicode字符串，而不应用任何其他解码。\n对于提供__unicode__()方法的对象，它将调用此方法而不使用参数来创建Unicode字符串。对于所有其他对象，请求8位字符串版本或表示，然后使用’strict’模式下的默认编码的编解码器将其转换为Unicode字符串。1234567891011class Student(object):    def __init__(self, name):        self.name = name    def __unicode__(self):        return u&#x27;student: %s&#x27; % self.nameunicode(Student(&#x27;wangkuntian&#x27;))     # student: wangkuntianunicode(&#x27;王&#x27;, encoding=&#x27;utf-8&#x27;)     # 王unicode(&#x27;呼yue&#x27;, errors=&#x27;ignore&#x27;)   # yue\n\n\n\nVvars()vars([object])返回模块、类、实例或任何其它具有__dict__属性的对象的__dict__属性。\n模块和实例等对象具有可更新的__dict__属性；但是，其他对象可能对其__dict__属性有写限制（例如，新式类使用dictproxy来防止直接字典更新）。\n不带参数时，vars()的行为类似locals()。请注意，locals字典仅对于读取起作用，因为对locals字典的更新会被忽略。\n\n\n123456class Student(object):    def __init__(self, name):        self.name = namevars(Student(&#x27;wangkuntian&#x27;))    # &#123;&#x27;name&#x27;: &#x27;wangkuntian&#x27;&#125;\n\nXxrange()xrange(stop)xrange(start, stop[, step])此函数与range()非常相似，但返回xrange对象而不是list。\n这是一个不透明的序列类型，它产生与相应列表相同的值，而不是实际同时存储它们。xrange()在range()上的优势是最小的（因为xrange()在被要求时仍需要创建值），除非在内存饥饿的机器上使用非常大的范围或者当所有范围的元素都是没用过（例如当循环通常以break结束时）。\nCPython实现细节：xrange()旨在简单快速。实现可能会对此实施限制。Python的C实现将所有参数限制为原生C long（“short”Python整数），并且还要求元素的数量适合原生C long。\n如果需要更大的范围，可以使用itertools模块制作备用版本：islice(count(start, step), (stop-start+step-1+2*(step&lt;0))//step)\n\n\nZzip()zip([iterable, …])此函数返回元组列表，其中第i个元组包含来自每个参数序列或迭代的第i个元素。返回的列表的长度被截断为最短参数序列的长度。\n当有多个参数长度相同时，zip()类似于map()，初始参数为None。使用单个序列参数，它返回一个1元组的列表。没有参数，它返回一个空列表。\n保证了迭代的从左到右的评估顺序。这使得使用zip(*[iter(s)]*n)将数据序列聚类成n长度组的习惯成为可能。\nzip()与*运算符相结合可以用来拆解一个列表：\n123456x = [1, 2, 3]y = [4, 5, 6]zipped = zip(x, y)              # [(1, 4), (2, 5), (3, 6)]x2, y2 = zip(*zipped)x == list(x2) and y == list(y2) # True\n\n____import__()__import__(name[, globals[, locals[, fromlist[, level]]]])\n与importlib.import_module()不同，这是一个日常Python编程中不需要用到的高级函数。\n\n\nimport语句调用此函数。它可以替换（通过导入__builtin__模块并分配给__builtin__.__import__）以更改import语句的语义，但是现在通常使用导入钩子更简单。直接使用__import__()很少见，除非您要导入名称仅在运行时已知的模块。\n该函数会导入name模块，有可能使用给定的globals和locals来确定如何在包的上下文中解读名称。fromlist给出了应该从由name 指定的模块导入对象或子模块的名称。标准实现完全不使用其locals参数，而仅使用globals参数来确定import语句的包上下文。\nlevel指定是使用绝对导入还是相对导入。默认值为-1表示将同时尝试绝对与相对导入。0表示仅执行绝对导入。level的正值表示要搜索的父目录相对于调用__import__()的模块的目录的数量。\n当name变量的形式为package.module时，通常将会返回最高层级的包（第一个点号之前的名称），而不是以name命名的模块。 但是，当给出了非空的fromlist参数时，则将返回以name命名的模块。\n例如，语句import spam的结果将为与以下代码作用相同的字节码：\n1spam = __import__(&#x27;spam&#x27;, globals(), locals(), [], -1)\n\n语句import spam.ham的结果将为以下调用：\n1spam = __import__(&#x27;spam.ham&#x27;, globals(), locals(), [], -1)\n\n语句from spam.ham import eggs, sausage as saus 的结果将为：\n123_temp = __import__(&#x27;spam.ham&#x27;, globals(), locals(), [&#x27;eggs&#x27;, &#x27;sausage&#x27;], -1)eggs = _temp.eggssaus = _temp.sausage\n\n在这里，spam.ham模块会由__import__()返回。要导入的对象将从此对象中提取并赋值给它们对应的名称。\n如果你只想按名称导入模块（可能在包中），请使用importlib.import_module()。\n","dateCreated":"2019-04-02T20:39:31+08:00","dateModified":"2023-09-21T10:45:00+08:00","datePublished":"2019-04-02T20:39:31+08:00","description":"Python 2.7的内置函数","headline":"Python内置函数","image":[null,"covers/PROJECT-Vayne.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},"publisher":{"@type":"Organization","name":"Wang kuntian","sameAs":["https://github.com/wangkuntian","mailto:wangkuntian1994@163.com"],"image":"faker.jpg","logo":{"@type":"ImageObject","url":"faker.jpg"}},"url":"https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","keywords":"Python","thumbnailUrl":"covers/PROJECT-Vayne.jpg"}</script>
    <meta name="description" content="Python 2.7的内置函数">
<meta property="og:type" content="blog">
<meta property="og:title" content="Python内置函数">
<meta property="og:url" content="https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="Wang kuntian&#39;s Blog">
<meta property="og:description" content="Python 2.7的内置函数">
<meta property="og:locale" content="zh_EN">
<meta property="article:published_time" content="2019-04-02T12:39:31.000Z">
<meta property="article:modified_time" content="2023-09-21T02:45:00.099Z">
<meta property="article:author" content="Wang kuntian">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://wangkuntian.github.io/assets/images/faker.jpg"/>
    
    
    
        <meta property="og:image" content="https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/covers/PROJECT-Vayne.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/covers/PROJECT-Vayne.jpg"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-bkzaqwnhdy35ne9gawopbfxp7lltc7yhde0uckf6kikurfjo9ztq2v5apuqa.min.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136102260-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-136102260-1');
    </script>


    

    
        
    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Wang kuntian&#39;s Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/faker.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/faker.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Wang kuntian</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Hi</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/wangkuntian"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:wangkuntian1994@163.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full"
             style="background-image:url('/covers/PROJECT-Vayne.jpg');"
             data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Python内置函数
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-04-02T20:39:31+08:00">
	
		    Apr 02, 2019
    	
    </time>
    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        hasCoverCaption">
                
<article class="post">
    
        <span class="post-header-cover-caption caption">Project Vayne</span>
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>Python 2.7的内置函数</p>
<span id="more"></span>

<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#A"><span class="toc-text">A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#abs"><span class="toc-text">abs()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#all"><span class="toc-text">all()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any"><span class="toc-text">any()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B"><span class="toc-text">B</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basestring"><span class="toc-text">basestring()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin"><span class="toc-text">bin()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bool"><span class="toc-text">bool()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bytearray"><span class="toc-text">bytearray()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C"><span class="toc-text">C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#callable"><span class="toc-text">callable()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chr"><span class="toc-text">chr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#classmethod"><span class="toc-text">classmethod()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmp"><span class="toc-text">cmp()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compile"><span class="toc-text">compile()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#complex"><span class="toc-text">complex()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D"><span class="toc-text">D</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#delattr"><span class="toc-text">delattr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dict"><span class="toc-text">dict()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dir"><span class="toc-text">dir()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#divmod"><span class="toc-text">divmod()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#E"><span class="toc-text">E</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#enumerate"><span class="toc-text">enumerate()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eval"><span class="toc-text">eval()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execfile"><span class="toc-text">execfile()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#F"><span class="toc-text">F</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#file"><span class="toc-text">file()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter"><span class="toc-text">filter()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#float"><span class="toc-text">float()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#format"><span class="toc-text">format()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#frozenset"><span class="toc-text">frozenset()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G"><span class="toc-text">G</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getattr"><span class="toc-text">getattr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#globals"><span class="toc-text">globals()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H"><span class="toc-text">H</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hasattr"><span class="toc-text">hasattr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash"><span class="toc-text">hash()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#help"><span class="toc-text">help()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hex"><span class="toc-text">hex()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I"><span class="toc-text">I</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#id"><span class="toc-text">id()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input"><span class="toc-text">input()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int"><span class="toc-text">int()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isinstance"><span class="toc-text">isinstance()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#issubclass"><span class="toc-text">issubclass()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iter"><span class="toc-text">iter()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#L"><span class="toc-text">L</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#len"><span class="toc-text">len()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-text">list()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#locals"><span class="toc-text">locals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#long"><span class="toc-text">long()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#M"><span class="toc-text">M</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-text">map()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#max"><span class="toc-text">max()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memoryview"><span class="toc-text">memoryview()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min-%EF%BC%89"><span class="toc-text">min(）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N"><span class="toc-text">N</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#next"><span class="toc-text">next()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#O"><span class="toc-text">O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#object"><span class="toc-text">object()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oct"><span class="toc-text">oct()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#open"><span class="toc-text">open()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ord"><span class="toc-text">ord()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P"><span class="toc-text">P</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pow"><span class="toc-text">pow()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#print"><span class="toc-text">print()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#property"><span class="toc-text">property()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R"><span class="toc-text">R</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#range"><span class="toc-text">range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raw-input"><span class="toc-text">raw_input()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce"><span class="toc-text">reduce()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reload"><span class="toc-text">reload()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#repr"><span class="toc-text">repr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reversed"><span class="toc-text">reversed()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#round"><span class="toc-text">round()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#S"><span class="toc-text">S</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-text">set()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setattr"><span class="toc-text">setattr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice"><span class="toc-text">slice()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sorted"><span class="toc-text">sorted()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#staticmethod"><span class="toc-text">staticmethod()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#str"><span class="toc-text">str()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sum"><span class="toc-text">sum()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-text">super()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T"><span class="toc-text">T</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tuple"><span class="toc-text">tuple()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type"><span class="toc-text">type()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#U"><span class="toc-text">U</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unichr"><span class="toc-text">unichr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unicode"><span class="toc-text">unicode()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V"><span class="toc-text">V</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vars"><span class="toc-text">vars()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#X"><span class="toc-text">X</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xrange"><span class="toc-text">xrange()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Z"><span class="toc-text">Z</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zip"><span class="toc-text">zip()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">__</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#import"><span class="toc-text">__import__()</span></a></li></ol></li></ol>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h3><p>abs(x)<br>返回数字的绝对值。</p>
<p>参数可以是普通或长整数或浮点数。如果参数是一个复数，则返回其大小（复数的模）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">abs</span>(-<span class="number">123</span>) <span class="comment"># 123</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">123</span>)  <span class="comment"># 123</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>)) <span class="comment"># 5.0</span></span><br></pre></td></tr></table></figure>
<div class="alert info no-icon"><p><a href="#complex">complex()</a>返回值为复数。</p>
<p>complex(3,4)的返回值是3+4j。3+4j的模就是5。</p>
</div>

<h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><p>all(iterable)<br>如果iterable的所有元素为真（或迭代器为空），返回True，否则返回False。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">all</span>([]) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">all</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">all</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="literal">None</span>]) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">all</span>(<span class="params">iterable</span>):</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> element:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="any"><a href="#any" class="headerlink" title="any()"></a>any()</h3><p>any(iterable)<br>如果iterable的任一元素为真则返回True。如果迭代器为空，返回False。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">any</span>([]) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">any</span>([<span class="literal">None</span>]) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">any</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="literal">None</span>]) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">any</span>([<span class="number">1</span>, <span class="literal">None</span>, <span class="literal">None</span>]) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">any</span>(<span class="params">iterable</span>):</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> element:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="basestring"><a href="#basestring" class="headerlink" title="basestring()"></a>basestring()</h3><p>这个抽象类型是str和unicode的超类。它不能被调用或实例化，但它可以用于测试对象是str还是unicode的实例。isinstance(obj,basestring)等同于isinstance(obj,(str,unicode))</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin()"></a>bin()</h3><p>bin(x)<br>将整数转换为二进制字符串。</p>
<p>结果是一个有效的Python表达式。如果x不是Python int对象，则必须定义一个返回整数的_<em>index_</em>()方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bin</span>(<span class="number">10</span>) <span class="comment"># 0b1010</span></span><br><span class="line"><span class="built_in">bin</span>(<span class="number">100</span>) <span class="comment"># 0b1100100</span></span><br></pre></td></tr></table></figure>

<h3 id="bool"><a href="#bool" class="headerlink" title="bool()"></a>bool()</h3><p>class bool([x])<br>返回一个布尔值，即True或False。</p>
<p>x为True则返回值为True，x为False返回值为False。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span>() <span class="comment"># False</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="number">0</span>) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="number">1</span>) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">bool</span>([]) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">bool</span>(&#123;&#125;) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">bool</span>(()) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="literal">True</span>) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="literal">False</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="bytearray"><a href="#bytearray" class="headerlink" title="bytearray()"></a>bytearray()</h3><p>class bytearray([source[, encoding[, errors]]])<br>返回一个新的字节数组。bytearray类是 0 &lt;= x &lt;256 范围内的可变整数序列。</p>
<p>可选形参 source 可以用不同的方式来初始化数组：</p>
<ul>
<li>如果是unicode，则还必须提供编码（和可选的，错误）参数，bytearray()使用unicode.encode()将unicode转换为字节。</li>
<li>如果是一个integer，会初始化大小为该数字的数组，并使用null字节填充。</li>
<li>如果是一个符合buffer接口的对象，该对象的只读buffer会用来初始化字节数组。</li>
<li>如果是一个iterable可迭代对象，它的元素的范围必须是 0 &lt;= x &lt;256 的整数，它会被用作数组的初始内容。</li>
<li>如果没有实参，则创建大小为0的数组。</li>
</ul>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="callable"><a href="#callable" class="headerlink" title="callable()"></a>callable()</h3><p>callable(object)<br>如果对象参数显示为可调用，则返回True，否则返回False。</p>
<p>如果返回true，则调用仍然可能失败，但如果调用失败，则调用对象将永远不会成功。</p>
<div class="alert info no-icon"><p>类是可调用的（调用类会返回一个新实例）。<br>如果类实例具有_<em>call_</em>()方法，则它们是可调用的。</p>
</div>

<h3 id="chr"><a href="#chr" class="headerlink" title="chr()"></a>chr()</h3><p>chr(i)<br>返回一个字符串，其ASCII码为整数i。</p>
<p>参数必须在[0..255]范围内。如果i超出该范围，则会引发ValueError。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chr</span>(<span class="number">97</span>) <span class="comment"># a</span></span><br><span class="line"><span class="built_in">chr</span>(<span class="number">65</span>) <span class="comment"># A</span></span><br></pre></td></tr></table></figure>
<div class="alert info no-icon"><p>相对的方法是ord()。</p>
</div>

<h3 id="classmethod"><a href="#classmethod" class="headerlink" title="classmethod()"></a>classmethod()</h3><p>classmethod(function)<br>返回一个函数的类方法。</p>
<p>一个类方法把类自己作为第一个实参，就像一个实例方法把实例自己作为第一个实参。请用以下习惯来声明类方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">cls, arg1, arg2, ...</span>):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp()"></a>cmp()</h3><p>cmp(x, y)<br>比较两个对象x和y并根据结果返回一个整数。</p>
<p>如果x &lt; y则返回值为负，如果x == y则返回零，如果x &gt; y则返回为正</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp(<span class="number">1</span>, <span class="number">1</span>) <span class="comment"># 0</span></span><br><span class="line">cmp(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># -1</span></span><br><span class="line">cmp(<span class="number">2</span>, <span class="number">1</span>) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<h3 id="compile"><a href="#compile" class="headerlink" title="compile()"></a>compile()</h3><p>compile(source, filename, mode[, flags[, dont_inherit]])<br>将源代码编译为代码或AST对象。代码对象可以由exec语句执行，也可以通过调用eval()来评估。</p>
<div class="alert info no-icon"><p>source可以是Unicode字符串，Latin-1编码字符串或AST对象。</p>
<p>filename实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 ‘<string>‘）。</p>
<p>mode实参指定了编译代码必须用的模式。如果source是语句序列，可以是exec；如果是单一表达式，可以是eval；如果是单个交互式语句，可以是single。（在最后一种情况下，如果表达式执行结果不是None将会被打印出来。）</p>
</div>

<h3 id="complex"><a href="#complex" class="headerlink" title="complex()"></a>complex()</h3><p>class complex([real[, imag]])<br>将字符串或数字转换为复数，返回值为real + imag * j。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span>(<span class="number">3</span>,<span class="number">4</span>) <span class="comment"># (3+4j)</span></span><br><span class="line"><span class="built_in">complex</span>(<span class="string">&#x27;3+4j&#x27;</span>) <span class="comment"># (3+4j)</span></span><br></pre></td></tr></table></figure>
<div class="alert danger no-icon"><p>当从字符串转换时，字符串在 + 或 - 的周围必须不能有空格。例如complex(‘1+2j’)是合法的，但complex(‘1 + 2j’)会触发ValueError异常。</p>
</div>


<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="delattr"><a href="#delattr" class="headerlink" title="delattr()"></a>delattr()</h3><p>delattr(object, name)<br>setattr()相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如delattr(student, ‘name’)等价于del student.name。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student = Student(name=<span class="string">&#x27;wkt&#x27;</span>, age=<span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">getattr</span>(student, <span class="string">&#x27;name&#x27;</span>) <span class="comment"># wkt</span></span><br><span class="line"><span class="built_in">delattr</span>(student, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">getattr</span>(student, <span class="string">&#x27;name&#x27;</span>) <span class="comment"># AttributeError</span></span><br></pre></td></tr></table></figure>

<h3 id="dict"><a href="#dict" class="headerlink" title="dict()"></a>dict()</h3><p>class dict(**kwarg)<br>class dict(mapping, **kwarg)<br>class dict(iterable, **kwarg)<br>创建一个新的字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line">b = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">d = <span class="built_in">dict</span>([(<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line">e = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">a == b == c == d == e <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p>dir([object])<br>如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。</p>
<p>如果对象有一个名为_<em>dir_</em>()的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义_<em>getattr_</em>()或__getattribute__()函数的对象能够自定义dir()来报告它们的属性。</p>
<p>如果对象不提供_<em>dir_</em>()，这个函数会尝试从对象已定义的_<em>dict_<em>属性和类型对象收集信息。结果列表并不总是完整的，如果对象有自定义_getattr\</em></em>()，那结果可能不准确。</p>
<p>默认的dir()机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：</p>
<ul>
<li>如果对象是模块对象，则列表包含模块的属性名称。</li>
<li>如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。</li>
<li>否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。</li>
<li>返回的列表按字母表排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="built_in">dir</span>() </span><br><span class="line"><span class="comment"># [&#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;datetime&#x27;]</span></span><br><span class="line"><span class="built_in">dir</span>(datetime) </span><br><span class="line"><span class="comment"># [&#x27;MAXYEAR&#x27;, &#x27;MINYEAR&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;date&#x27;, &#x27;datetime&#x27;, &#x27;datetime_CAPI&#x27;, &#x27;time&#x27;, &#x27;timedelta&#x27;, &#x27;tzinfo&#x27;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__dir__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">dir</span>(p) <span class="comment"># [&#x27;age&#x27;, &#x27;name&#x27;, &#x27;sex&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="divmod"><a href="#divmod" class="headerlink" title="divmod()"></a>divmod()</h3><p>divmod(a, b)<br>取两个数（非复数）作为参数，返回由商和余数组成的一对数。</p>
<p>对于普通类型和长整数，结果与(a // b，a ％ b)相同。</p>
<p>对于浮点数，结果是(q, a ％ b)，其中q通常是math.floor(a / b)，但可能比该值小1。在任何情况下，q * b + a ％ b非常接近a，如果a％b非零，则其具有与b相同的符号，并且0 &lt;= abs(a ％ b) &lt; abs(b)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">divmod</span>(<span class="number">1</span>, <span class="number">3</span>)  <span class="comment"># (0, 1)</span></span><br><span class="line"><span class="built_in">divmod</span>(<span class="number">10</span>, <span class="number">4</span>) <span class="comment"># (2, 2)</span></span><br></pre></td></tr></table></figure>


<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a>enumerate()</h3><p>enumerate(sequence, start=0)<br>返回一个枚举对象。 </p>
<p>sequence必须是序列，迭代器或其他支持迭代的对象。</p>
<p>enumerate（）返回的迭代器的next（）方法返回一个包含计数的元组（从start开始，默认为0）和迭代序列获得的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seasons = [<span class="string">&#x27;spring&#x27;</span>, <span class="string">&#x27;summer&#x27;</span>, <span class="string">&#x27;autumn&#x27;</span>, <span class="string">&#x27;winter&#x27;</span>]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons))            </span><br><span class="line"><span class="comment"># [(0, &#x27;spring&#x27;), (1, &#x27;summer&#x27;), (2, &#x27;autumn&#x27;), (3, &#x27;winter&#x27;)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>))   </span><br><span class="line"><span class="comment"># [(1, &#x27;spring&#x27;), (2, &#x27;summer&#x27;), (3, &#x27;autumn&#x27;), (4, &#x27;winter&#x27;)]</span></span><br></pre></td></tr></table></figure>
<p>相当于。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">enumerate</span>(<span class="params">sequence, start=<span class="number">0</span></span>):</span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> sequence:</span><br><span class="line">        <span class="keyword">yield</span> n, elem</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>eval(expression[, globals[, locals]])<br>参数是Unicode或Latin-1编码的字符串以及可选的全局变量和局部变量。如果提供，globals必须是字典。如果提供，则locals可以是任何映射对象。</p>
<p>表达式参数作为Python表达式（技术上讲，条件列表）被解析和评估，使用全局变量和本地字典作为全局和本地名称空间。如果全局字典存在且缺少‘__builtins__’，则在解析表达式之前将当前全局变量复制到全局变量中。这意味着表达式通常具有对标准__builtin__模块的完全访问权限，并且传播受限制的环境。如果省略locals字典，则默认为globals字典。如果省略两个字典，则表达式在调用eval()的环境中执行。返回值是计算表达式的结果。语法错误报告为异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27; x + 20 &#x27;</span>)  <span class="comment"># 30</span></span><br></pre></td></tr></table></figure>
<p>此函数还可用于执行任意代码对象（例如由compile()创建的代码对象）。在这种情况下，传递代码对象而不是字符串。如果代码对象已使用’exec’作为mode参数进行编译，则eval()的返回值将为None。</p>
<div class="alert info no-icon"><p>exec语句支持动态执行语句。<br>execfile()函数支持从文件执行语句。<br>globals()和locals()函数分别返回当前的全局和本地字典，这对于传递以供eval()或execfile()使用很有用。</p>
</div>

<h3 id="execfile"><a href="#execfile" class="headerlink" title="execfile()"></a>execfile()</h3><p>execfile(filename[, globals[, locals]])<br>此函数类似于exec语句，但解析文件而不是字符串。它与import语句的不同之处在于它不使用模块管理 - 它无条件地读取文件并且不创建新模块。</p>
<p>参数是文件名和两个可选字典。使用全局和本地字典作为全局和本地命名空间，将文件解析并评估为一系列Python语句（类似于模块）。如果提供，则locals可以是任何映射对象。请记住，在模块级别，全局变量和本地变量是相同的字典。如果将两个单独的对象作为全局变量和局部变量传递，则代码将被执行，就像它嵌入在类定义中一样。如果省略locals字典，则默认为globals字典。如果省略两个字典，则表达式在调用execfile（）的环境中执行。返回值为None。</p>
<div class="alert info no-icon"><p>默认的locals的行为与下面的函数locals()相同：不应尝试修改默认的locals字典。如果需要在函数execfile()返回后查看代码对locals的影响，则传递显式的locals字典。execfile()不能可靠地用于修改函数的本地。</p>
</div>


<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="file"><a href="#file" class="headerlink" title="file()"></a>file()</h3><p>file(name[, mode[, buffering]])<br>文件类型的构造函数，在文件对象一节中进一步描述。构造函数的参数与下面描述的open()内置函数的参数相同。<br>打开文件时，最好使用open()而不是直接调用此构造函数。file更适合于类型测试（例如，写入isinstance(f，file)）。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>filter(function, iterable)<br>从iterable的那些元素构造一个列表，该函数返回true。</p>
<p>iterable可以是序列，支持迭代的容器，也可以是迭代器。</p>
<p>如果iterable是字符串或元组，则结果也具有该类型;否则它总是一个列表。如果function为None，即删除所有可迭代的false元素。</p>
<p>请注意，如果函数不是None，则filter（function，iterable）等效于[item for item in iterable if function(item)]，如果函数为None，则[item for item in iterable if item]。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">filter</span>(<span class="keyword">lambda</span> item: item <span class="keyword">if</span> item % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="literal">None</span>, x)</span><br><span class="line"><span class="comment"># [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">[item <span class="keyword">for</span> item <span class="keyword">in</span> x <span class="keyword">if</span> item % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment"># [2, 4, 6, 8]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="float"><a href="#float" class="headerlink" title="float()"></a>float()</h3><p>class float([x])<br>返回由数字或字符串x构造的浮点数。</p>
<p>如果参数是字符串，则它必须包含可能已赋值的decimal或浮点数，可能嵌入在空格中。参数也可以是[+|-]nan或[+|-] inf。否则，参数可以是普通或长整数或浮点数，并返回具有相同值（在Python的浮点精度内）的浮点数。</p>
<p>如果没有给出参数，则返回0.0。</p>
<h3 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h3><p>format(value[, format_spec])<br>将值转换为“格式化”表示，由format_spec控制。format_spec的解释取决于value参数的类型，但是大多数内置类型都使用标准格式化语法：Format Specification Mini-Language。</p>
<div class="alert info no-icon"><p>format(value, format_spec)只调用value.<strong>format</strong>(format_spec)。</p>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;world&#x27;</span>) <span class="comment"># hello world</span></span><br></pre></td></tr></table></figure>

<h3 id="frozenset"><a href="#frozenset" class="headerlink" title="frozenset()"></a>frozenset()</h3><p>class frozenset([iterable])<br>返回一个新的frozenset对象，可选地包含从iterable中获取的元素。<br>返回一个新的set或frozenset对象，其元素取自iterable。集合的元素必须是可以清除的。要表示集合集，内部集合必须是冻结集合对象。如果未指定iterable，则返回新的空集。</p>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><h3 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a>getattr()</h3><p>getattr(object, name[, default])<br>返回对象命名属性的值。</p>
<p>name必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。</p>
<p>例如，getattr(x, ‘foobar’)等同于x.foobar。如果指定的属性不存在，且提供了default值，则返回它，否则触发AttributeError。</p>
<h3 id="globals"><a href="#globals" class="headerlink" title="globals()"></a>globals()</h3><p>返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。</p>
<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><h3 id="hasattr"><a href="#hasattr" class="headerlink" title="hasattr()"></a>hasattr()</h3><p>hasattr(object, name)<br>参数是一个对象和一个字符串。如果字符串是对象属性之一的名称，则结果为True，否则为False。（这是通过调用getattr(object,name)并查看它是否引发异常来实现的。）</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h3><p>hash(object)<br>返回对象的哈希值（如果有的话）。哈希值是整数，它们用于在字典查找期间快速比较字典键。相等的数字值具有相同的哈希值（即使它们具有不同的类型，如1和1.0的情况）。</p>
<h3 id="help"><a href="#help" class="headerlink" title="help()"></a>help()</h3><p>help([object])<br>启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。</p>
<div class="alert info no-icon"><p>该函数通过 site 模块加入到内置命名空间。</p>
</div>

<h3 id="hex"><a href="#hex" class="headerlink" title="hex()"></a>hex()</h3><p>hex(x)<br>将整数（任意大小）转换为前缀为“0x”的小写十六进制字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hex</span>(<span class="number">255</span>)    <span class="comment"># 0xff</span></span><br><span class="line"><span class="built_in">hex</span>(-<span class="number">220</span>)   <span class="comment"># -0xdc</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="number">1L</span>)     <span class="comment"># 0x1L</span></span><br></pre></td></tr></table></figure>
<div class="alert info no-icon"><p>如果x不是int或long对象，则必须定义一个返回字符串的<strong>hex</strong>()方法。</p>
</div>

<div class="alert info no-icon"><p>如果要获取浮点数的十六进制字符串形式，请使用float.hex()方法。</p>
</div>

<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><h3 id="id"><a href="#id" class="headerlink" title="id()"></a>id()</h3><p>id(object)<br>返回对象的“标识”。这是一个整数（或长整数），保证在该生命周期内该对象是唯一且恒定的。</p>
<p>具有非重叠生存期的两个对象可以具有相同的id()值。</p>
<div class="alert info no-icon"><p>id()返回的值是内存中对象的地址。</p>
</div>

<h3 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h3><p>input([prompt])<br>相当于eval(raw_input(prompt))。</p>
<p>此功能不会捕获用户错误。如果输入语法无效，则会引发SyntaxError。如果评估期间出现错误，可能会引发其他异常。所以应该使用raw_input()函数来获取用户的常规输入。</p>
<p>如果加载了readline模块，input()将使用它来提供复杂的行编辑和历史记录功能。</p>
<h3 id="int"><a href="#int" class="headerlink" title="int()"></a>int()</h3><p>class int(x=0)<br>class int(x, base=10)<br>返回由数字或字符串x构造的整数对象，如果没有给出参数，则返回0。</p>
<p>如果x是数字，则它可以是普通整数，长整数或浮点数。</p>
<p>如果x是浮点，则转换将截断为零。</p>
<p>如果参数超出整数范围，则函数返回一个long对象。</p>
<p>如果x不是数字或者给定了base，那么x必须是一个字符串或Unicode对象，表示以radix为基数的整数文字。可选地，文字可以在前面加+或-（之间没有空格）并且用空格包围。base-n文字由数字0到n-1组成，a到z（或A到Z）的值为10到35。</p>
<p>默认base为10。允许的值为0和2-36。 Base-2，-8和-16文字可以选择以0b/0B，0o/0O/0或0x/0X作为前缀，与代码中的整数文字一样。Base0表示将字符串完全解释为整数文字，因此实际基数为2，8，10或16。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>()                   <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">int</span>(<span class="number">1.1</span>)                <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;11111&#x27;</span>, base=<span class="number">2</span>)    <span class="comment"># 31</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;11111&#x27;</span>, base=<span class="number">4</span>)    <span class="comment"># 341</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;11111&#x27;</span>, base=<span class="number">8</span>)    <span class="comment"># 4681</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;11111&#x27;</span>, base=<span class="number">16</span>)   <span class="comment"># 69905</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;0xa&#x27;</span>, base=<span class="number">16</span>)     <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;11111&#x27;</span>, base=<span class="number">0</span>)    <span class="comment"># 11111</span></span><br></pre></td></tr></table></figure>

<h3 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h3><p>isinstance(object, classinfo)<br>如果object参数是classinfo参数的实例，或者是（直接，间接或虚拟）子类的实例，则返回true。</p>
<p>如果classinfo是类型对象（新样式类）并且object是该类型的对象或其（直接，间接或虚拟）子类，则也返回true。</p>
<p>如果object不是类实例或给定类型的对象，则该函数始终返回false。</p>
<p>如果classinfo是某一个类或类型对象的元组（或递归地，其他此类元组），则如果object是这个类或这种类型的实例，则返回true。</p>
<p>如果classinfo不是类，类型和类的元组或类型的元组，则会引发<strong>TypeError</strong>异常。</p>
<h3 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass()"></a>issubclass()</h3><p>issubclass(class, classinfo)<br>如果class是classinfo的子类（直接、间接或虚拟的），则返回true。</p>
<p>classinfo可以是类对象的元组，此时 classinfo 中的每个元素都会被检查。</p>
<p>其他情况，会触发<strong>TypeError</strong>异常。</p>
<h3 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h3><p>iter(o[, sentinel])<br>返回一个迭代器对象。</p>
<p>如果没有第二个参数，o必须是支持迭代协议（__iter__()方法）的集合对象，或者它必须支持序列协议（__getitem__()方法，整数参数从0开始）。</p>
<p>如果它不支持这些协议中的任何一个，则引发<strong>TypeError</strong>。</p>
<p>如果给出第二个参数sentinel，则o必须是可调用对象。<br>在这种情况下创建的迭代器将为每个对next（）方法的调用调用o而不带参数；如果返回的值等于sentinel，则会引发<strong>StopIteration</strong>，否则返回该值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="built_in">print</span> x,</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>第二种形式的iter()的一个有用的应用是读取文件的行直到达到某一行。以下示例读取文件，直到readline()方法返回空字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;mydata.txt&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">iter</span>(fp.readline, <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">        process_line(line)</span><br></pre></td></tr></table></figure>
<h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><h3 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h3><p>len(s)<br>返回对象的长度（元素个数）。</p>
<p>实参可以是序列（如string、bytes、tuple、list或range等）或集合（如dictionary、set或frozen set等）。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h3><p>class list([iterable])<br>返回一个列表，其项目与iterable的项目相同且顺序相同。</p>
<p>iterable可以是序列，支持迭代的容器，也可以是迭代器对象。如果iterable已经是一个列表，则会生成并返回一个副本，类似于iterable[:]。例如，list(‘abc’)返回[‘a’,’b’,’c’]和list((1,2,3))返回[1,2,3]。</p>
<p>如果没有给出参数，则返回一个新的空列表，[]。</p>
<p>list是一个可变序列类型。</p>
<h3 id="locals"><a href="#locals" class="headerlink" title="locals()"></a>locals()</h3><p>locals()<br>更新并返回表示当前本地符号表的字典。<br>locals()在函数块中调用时返回自由变量，但在类块中不调用。</p>
<h3 id="long"><a href="#long" class="headerlink" title="long()"></a>long()</h3><p>class long(x=0)<br>class long(x, base=10)<br>返回由字符串或数字x构造的长整型对象。</p>
<p>如果参数是一个字符串，它必须包含一个可能赋值的任意大小的数字，可能嵌入在空格中。</p>
<p>base参数的解释方式与<a href="#int">int()</a>相同，并且只能在x为字符串时给出。</p>
<p>否则，参数可以是普通或长整数或浮点数，并返回具有相同值的长整数。将浮点数转换为整数截断（朝向零）。如果没有给出参数，则返回0L。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long()                  <span class="comment"># 0</span></span><br><span class="line">long(<span class="string">&#x27;111&#x27;</span>, base=<span class="number">2</span>)     <span class="comment"># 7</span></span><br><span class="line">long(<span class="string">&#x27;111&#x27;</span>, base=<span class="number">10</span>)    <span class="comment"># 111</span></span><br><span class="line">long(<span class="string">&#x27;111&#x27;</span>, base=<span class="number">16</span>)    <span class="comment"># 273</span></span><br><span class="line">long(<span class="number">1.11</span>)              <span class="comment"># 1</span></span><br><span class="line">long(<span class="number">0.11</span>)              <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map(function, iterable, …)<br>将函数应用于iterable的每个项目并返回结果列表。</p>
<p>如果传递了多个可迭代参数，则函数必须采用所有参数，并且并行地应用于所有迭代的项。</p>
<p>如果一个iterable比另一个短，则假定使用None项扩展。</p>
<p>如果function为None，则假定为identity函数；如果有多个参数，map()返回一个由包含所有迭代中相应项的元组组成的列表（一种转置操作）。可迭代参数可以是序列或任何可迭代对象；结果始终是一个列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">and</span> y:</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> x <span class="keyword">else</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l1 = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)            <span class="comment"># [1, 2, 3]</span></span><br><span class="line">l2 = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)            <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">map</span>(<span class="literal">None</span>, l1)               <span class="comment"># [1, 2, 3]</span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="number">1</span>, l1)    <span class="comment"># [2, 3, 4]</span></span><br><span class="line"><span class="built_in">map</span>(<span class="literal">None</span>, l1, l2)           <span class="comment"># [(1, 1), (2, 2), (3, 3), (None, 4), (None, 5)]</span></span><br><span class="line"><span class="built_in">map</span>(add, l1, l2)            <span class="comment"># [2, 4, 6, 4, 5]</span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x + y <span class="keyword">if</span> x <span class="keyword">and</span> y <span class="keyword">else</span> x <span class="keyword">if</span> x <span class="keyword">else</span> y, l1, l2)   <span class="comment"># [2, 4, 6, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h3><p>max(iterable[, key])<br>max(arg1, arg2, *args[, key])<br>返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。</p>
<p>如果提供了一个位置参数，则iterable必须是非空的可迭代（例如非空字符串，元组或列表）。</p>
<p>返回iterable中的最大项。如果提供了两个或多个位置参数，则返回最大的位置参数。</p>
<p>可选的key参数指定一个单参数排序函数，就像用于list.sort()的函数一样。键参数（如果提供）必须采用关键字形式（例如，max(a, b, c, key = func)）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(-<span class="number">3</span>, <span class="number">2</span>)                                  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">max</span>(-<span class="number">3</span>, <span class="number">2</span>, key=<span class="keyword">lambda</span> x: x * x)             <span class="comment"># -3</span></span><br><span class="line"><span class="built_in">max</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>), <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">6</span>))  <span class="comment"># [0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">max</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>))                           <span class="comment"># 9</span></span><br><span class="line"><span class="built_in">max</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>), key=<span class="keyword">lambda</span> x: x * -<span class="number">1</span>)     <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<h3 id="memoryview"><a href="#memoryview" class="headerlink" title="memoryview()"></a>memoryview()</h3><p>memoryview(obj)<br>返回由给定实参创建的“内存视图”对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="built_in">memoryview</span>(<span class="string">&#x27;abc&#x27;</span>)   <span class="comment"># &lt;memory at 0x10e7c03e0&gt;</span></span><br><span class="line"><span class="built_in">type</span>(v)                 <span class="comment"># &lt;type &#x27;memoryview&#x27;&gt;</span></span><br><span class="line">v.tobytes()             <span class="comment"># abc</span></span><br><span class="line">v.tolist()              <span class="comment"># [97, 98, 99]</span></span><br><span class="line">v.itemsize              <span class="comment"># 1</span></span><br><span class="line">v.readonly              <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="min-）"><a href="#min-）" class="headerlink" title="min(）"></a>min(）</h3><p>min(iterable[, key])<br>min(arg1, arg2, *args[, key])</p>
<p>返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。</p>
<p>如果提供了一个位置参数，则iterable必须是非空的可迭代（例如非空字符串，元组或列表）。</p>
<p>返回iterable中的最小项。如果提供了两个或多个位置参数，则返回最小的位置参数。</p>
<p>可选的key参数指定一个单参数排序函数，就像用于list.sort()的函数一样。键参数（如果提供）必须采用关键字形式（例如，min(a, b, c, key=func)）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(-<span class="number">3</span>, <span class="number">2</span>)                                  <span class="comment"># -3</span></span><br><span class="line"><span class="built_in">min</span>(-<span class="number">3</span>, <span class="number">2</span>, key=<span class="keyword">lambda</span> x: x * x)             <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">min</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>), <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">6</span>))  <span class="comment"># [0]</span></span><br><span class="line"><span class="built_in">min</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>))                           <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">min</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>), key=<span class="keyword">lambda</span> x: x * -<span class="number">1</span>)     <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>

<h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><h3 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h3><p>next(iterator[, default])<br>通过调用next()方法从迭代器中检索下一个项目。如果给定default，则在迭代器耗尽时返回，否则引发StopIteration。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    s = <span class="built_in">next</span>(it, -<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span> s,</span><br><span class="line">    <span class="keyword">if</span> s == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 1 2 3 4 5 6 7 8 9 -1</span></span><br></pre></td></tr></table></figure>

<h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><h3 id="object"><a href="#object" class="headerlink" title="object()"></a>object()</h3><p>class object<br>返回一个新的无特征对象。object是所有新样式类的基础。它具有新样式类的所有实例共有的方法。</p>
<div class="alert info no-icon"><p>此函数不接受任何参数。以前，它接受了参数但忽略了它们。</p>
</div>

<h3 id="oct"><a href="#oct" class="headerlink" title="oct()"></a>oct()</h3><p>oct(x)<br>将整数（任意大小）转换为八进制字符串。结果是一个有效的Python表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">oct</span>(<span class="number">8</span>)      <span class="comment"># 010</span></span><br><span class="line"><span class="built_in">oct</span>(<span class="number">18</span>)     <span class="comment"># 022</span></span><br><span class="line"><span class="built_in">oct</span>(-<span class="number">128</span>)   <span class="comment"># -0200</span></span><br></pre></td></tr></table></figure>

<h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>open(name[, mode[, buffering]])</p>
<p>打开文件，返回文件对象部分中描述的文件类型的对象。如果无法打开文件，则引发**IOError**。<span class="highlight-text orange">打开文件时，最好使用open()而不是直接调用文件构造函数。</span></p>

<p>前两个参数与stdio的fopen()相同：name是要打开的文件名，mode是一个字符串，表示如何打开文件。</p>
<p><span class="highlight-text primary">最常用的模式值是'r'用于读取，'w'用于写入（截断文件，如果它已经存在），'a'用于追加（在某些Unix系统上意味着所有写入都附加到文件的末尾而不管当前的搜索位置）。</span>如果省略mode，则默认为'r'。默认设置是使用文本模式，可以在写入时将“\n”字符转换为特定于平台的表示，并在读取时返回。<span class="highlight-text orange">因此，在打开二进制文件时，您应该将'b'附加到模式值以在二进制模式下打开文件，这将提高可移植性。</span></p>

<p>可选的buffering参数指定文件所需的缓冲区大小：0表示无缓冲，1表示行缓冲，任何其他正值表示使用（大约）该大小（以字节为单位）的缓冲区。负缓冲意味着使用系统默认值，通常为tty设备进行行缓冲，并为其他文件进行完全缓冲。如果省略，则使用系统默认值。</p>
<p>模式’r +’，’w +’和’a +’打开文件进行更新（读写）;请注意’w +’会截断文件。在区分二进制文件和文本文件的系统上，将“b”附加到模式以在二进制模式下打开文件；在没有这种区别的系统上，添加’b’没有效果。</p>
<p>除了标准的fopen（）值模式可以是’U’或’rU’。Python通常使用通用换行符支持构建；提供“U”将文件作为文本文件打开，但行可以通过以下任何一种方式终止：Unix行尾约定’\n’，Macintosh约定’\r’或Windows约定’\r\n’。所有这些外部表示都被Python程序视为’\n’。如果在没有通用换行符的情况下构建Python，则使用“U”的模式与普通文本模式相同。请注意，如此打开的文件对象也有一个名为newlines的属性，其值为None（如果尚未看到换行符）、’\n’、’\r’、’\r\n’或包含所有元组的元组看到的换行类型。</p>
<p>Python强制执行模式，在剥离’U’后，以’r’，’w’或’a’开头。</p>
<p>Python提供了许多文件处理模块，包括fileinput，os，os.path，tempfile和shutil。</p>
<h3 id="ord"><a href="#ord" class="headerlink" title="ord()"></a>ord()</h3><p>ord(c)<br>给定一个长度为1的字符串，当参数是unicode对象时，或者参数是8位字符串时的字节值。，返回表示字符的Unicode代码点的整数。</p>
<p>例如，ord(‘a’)返回整数97，ord(u’\u2020’)返回8224。这是8位字符串的chr()和unicode对象的unichr()的反转。如果给出了unicode参数并且Python是使用UCS2 Unicode构建的，则字符的代码点必须在[0..65535]范围内；否则字符串长度为2，将引发<strong>TypeError</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)        <span class="comment"># 65</span></span><br><span class="line"><span class="built_in">chr</span>(<span class="number">65</span>)         <span class="comment"># A</span></span><br><span class="line">unichr(<span class="number">65</span>)      <span class="comment"># A</span></span><br><span class="line"><span class="built_in">ord</span>(<span class="string">u&#x27;\u1024&#x27;</span>)  <span class="comment"># 4132</span></span><br></pre></td></tr></table></figure>

<h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><h3 id="pow"><a href="#pow" class="headerlink" title="pow()"></a>pow()</h3><p>pow(x, y[, z])<br>返回x的y次幂；如果z存在，则对z取余（比直接pow(x, y)%z计算更高效）。两个参数形式的pow(x, y)等价于幂运算符：x**y。</p>
<p>参数必须具有数字类型。对于混合操作数类型，二进制算术运算符的强制规则适用。</p>
<p>对于int和long int操作数，结果与操作数具有相同的类型（在强制类型转换之后），除非第二个参数为负；在这种情况下，所有参数都转换为float并传递float结果。例如，10**2返回100，但10**-2返回0.01。</p>
<div class="alert danger no-icon"><p>如果第二个参数为负数，则必须省略第三个参数。如果存在z，则x和y必须是整数类型，y必须是非负的。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">10</span>)      <span class="comment"># 1024</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">10</span>         <span class="comment"># 1024</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">2</span>, -<span class="number">10</span>)     <span class="comment"># 0.0009765625</span></span><br><span class="line"><span class="number">2</span> ** -<span class="number">10</span>        <span class="comment"># 0.0009765625</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10</span>)  <span class="comment"># 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">10</span> % <span class="number">10</span>    <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">2</span>, -<span class="number">10</span>, <span class="number">10</span>) <span class="comment"># TypeError</span></span><br></pre></td></tr></table></figure>

<h3 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h3><p>print(*objects, sep=’ ‘, end=’\n’, file=sys.stdout)<br>将对象打印到流文件，由sep分隔，然后结束。 sep，end和file（如果存在）必须作为关键字参数给出。</p>
<p>所有非关键字参数都会被转换为字符串，就像是执行了str()一样，并会被写入到流，以sep且在末尾加上 end。sep和end都必须为字符串；它们也可以为None，这意味着使用默认值。如果没有给出objects，则 print()将只写入end。</p>
<p>file参数必须是带有write(string)方法的对象;如果它不存在或None，将使用sys.stdout。输出缓冲由文件确定。例如，使用file.flush()确保在屏幕上立即显示。</p>
<p>此功能通常不作为内置函数提供，因为名称print被识别为print语句。要禁用该语句并使用print()函数，请在模块顶部使用此future语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br></pre></td></tr></table></figure>

<h3 id="property"><a href="#property" class="headerlink" title="property()"></a>property()</h3><p>class property([fget[, fset[, fdel[, doc]]]])</p>
<p>返回新样式类（从object派生的类）的属性。</p>
<p>fget是获取属性值的函数。fset是用于设置属性值的函数。fdel是用于删除属性值的函数。并且doc为属性对象创建文档字符串。<br>一个典型的用法是定义一个托管属性x:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getx</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setx</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delx</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line"></span><br><span class="line">    x = <span class="built_in">property</span>(getx, setx, delx, <span class="string">&quot;I&#x27;m the &#x27;x&#x27; property.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果c是C的实例，c.x将调用getter，c.x = value将调用setter，delc.x将调用deleter。</p>
<p>如果给出，doc将成为该property属性的文档字符串。否则该property将拷贝fget的文档字符串（如果存在）。这令使用property() 作为decorator来创建只读的特征属性可以很容易地实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._voltage = <span class="number">100000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">voltage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._voltage</span><br></pre></td></tr></table></figure>
<p>以上@property装饰器会将voltage()方法转化为一个具有相同名称的只读属性的“getter”，并将voltage的文档字符串设置为“Get the current voltage.”</p>
<p>特征属性对象具有getter，setter以及deleter方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。这最好是用一个例子来解释:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self._x</span><br></pre></td></tr></table></figure>
<p>上述代码与第一个例子完全等价。注意一定要给附加函数与原始的特征属性相同的名称(在本例中为x)。<br>返回的特征属性对象同样具有与构造器参数相对应的属性fget，fset和fdel。</p>
<h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>range(stop)<br>range(start, stop[, step])<br>这是一个用于创建包含算术进度的列表的通用函数。它最常用于for循环。</p>
<p>参数必须是普通整数。如果省略step参数，则默认为1。如果省略start参数，则默认为0。</p>
<div class="alert danger no-icon"><p>完整形式返回普通整数列表[start，start + step，start + 2 * step，…]。</p>
</div>

<p>如果step为正，则最后一个元素是最大的start + i * step小于stop；如果step为负数，则最后一个元素是最小的start + i * step大于stop。step不能为零，否则引发<strong>ValueError</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># [0, 5, 10, 15, 20, 25]</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># [0, 3, 6, 9]</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, -<span class="number">10</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># []</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># []</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure>

<h3 id="raw-input"><a href="#raw-input" class="headerlink" title="raw_input()"></a>raw_input()</h3><p>raw_input([prompt])<br>如果存在prompt参数，则将其写入标准输出而不带尾随换行符。该函数从输入中读取一行，将其转换为字符串（剥离尾部换行符），然后返回该行。读取EOF时，会引发<strong>EOFError</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = raw_input(<span class="string">&quot;what&#x27;s your name?\n&quot;</span>)    <span class="comment"># wangkuntian</span></span><br><span class="line"><span class="built_in">print</span> s                                 <span class="comment"># wangkuntian</span></span><br></pre></td></tr></table></figure>
<p>如果加载了readline模块，则raw_input()将使用它来提供精细的行编辑和历史记录功能。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>reduce(function, iterable[, initializer])<br>从左到右累加两个参数的函数到iterable项，以便将iterable减少为单个值。例如，reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])计算的是((((1+2)+3)+4)+5)的值。左参数x是累加值，右参数y是迭代的更新值。如果存在可选的initializer设定项，则它将放置在计算中的iterable项之前，并在iterable为空时用作默认值。如果未给出initializer且iterable只包含一项，则返回第一项。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reduce</span>(<span class="params">function, iterable, initializer=<span class="literal">None</span></span>):</span><br><span class="line">    it = <span class="built_in">iter</span>(iterable)</span><br><span class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            initializer = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;reduce() of empty sequence with no initial value&#x27;</span>)</span><br><span class="line">    accum_value = initializer</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">        accum_value = function(accum_value, x)</span><br><span class="line">    <span class="keyword">return</span> accum_value</span><br></pre></td></tr></table></figure>

<h3 id="reload"><a href="#reload" class="headerlink" title="reload()"></a>reload()</h3><p>reload(module)<br>重新加载以前导入的模块。参数必须是模块对象，因此必须先成功导入。如果您使用外部编辑器编辑了模块源文件并希望在不离开Python解释器的情况下试用新版本，这将非常有用。返回值是模块对象（与模块参数相同）。</p>
<p>执行重载（模块）时：</p>
<ul>
<li>重新编译Python模块的代码并重新执行模块级代码，定义一组新的对象，这些对象绑定到模块字典中的名称。扩展模块的init功能不会第二次调用。</li>
<li>与Python中的所有其他对象一样，只有在引用计数降为零后才会回收旧对象。</li>
<li>模块名称空间中的名称将更新为指向任何新对象或已更改的对象。</li>
<li>对旧对象的其他引用（例如模块外部的名称）不会反弹以引用新对象，如果需要，必须在每个命名空间中进行更新。</li>
</ul>
<p>还有其他一些警告：<br>重新加载模块时，将保留其字典（包含模块的全局变量）。名称的重新定义将覆盖旧的定义，因此这通常不是问题。如果新版本的模块未定义旧版本定义的名称，则旧定义仍然存在。如果模块维护对象的全局表或缓存，则此功能可用于模块的优势 - 使用try语句可以测试表的存在并在需要时跳过其初始化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cache</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    cache = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>重新加载内置或动态加载的模块通常不是很有用。不建议重新加载sys，__main__，builtins和其他关键模块。在许多情况下，扩展模块不是设计为多次初始化，并且在重新加载时可能以任意方式失败。</p>
<p>如果一个模块使用from … import …从另一个模块导入对象，则为另一个模块调用reload（）不会重新定义从它导入的对象 - 一种方法是重新执行from语句，另一种方法是使用导入和限定名称（module.*name*）。</p>
<p>如果模块实例化类的实例，则重新加载定义类的模块不会影响实例的方法定义 - 它们继续使用旧的类定义。派生类也是如此。</p>
<h3 id="repr"><a href="#repr" class="headerlink" title="repr()"></a>repr()</h3><p>repr(object)<br>返回包含对象的可打印表示的字符串。这与转换（反向引号）产生的值相同。</p>
<p>能够以普通函数的形式访问此操作有时很有用。对于许多类型，此函数尝试返回一个字符串，该字符串在传递给eval()时会产生具有相同值的对象，否则表示是一个括在尖括号中的字符串，其中包含对象类型的名称以及通常包括对象名称和地址的附加信息。</p>
<p>类可以通过定义__repr__()方法来控制此函数为其实例返回的内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">repr</span>(<span class="number">123</span>)                       <span class="comment"># 123</span></span><br><span class="line"><span class="built_in">repr</span>(<span class="string">&#x27;123&#x27;</span>)                     <span class="comment"># &#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">repr</span>(<span class="built_in">object</span>())                  <span class="comment"># &lt;object object at 0x10e8b50f0&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;The student is %s&#x27;</span> % self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">repr</span>(Student(<span class="string">&#x27;wangkuntian&#x27;</span>))    <span class="comment"># The student is wangkuntian</span></span><br></pre></td></tr></table></figure>

<h3 id="reversed"><a href="#reversed" class="headerlink" title="reversed()"></a>reversed()</h3><p>reversed(seq)<br>返回一个反向的 iterator。seq必须是一个具有__reversed__()方法的对象或者是支持该序列协议（具有从0开始的整数类型参数的__len__()方法和__getitem__()方法）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line"><span class="comment"># [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure>
<h3 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h3><p>round(number[, ndigits])<br>返回舍入到小数点后的ndigits数字的浮点值数字。如果省略ndigits，则默认为零。</p>
<p>结果是一个浮点数。将值四舍五入为函数减去ndigits的最接近的10的倍数；如果两个倍数相等，则舍入远离0（因此，例如，round(0.5)为1.0，round(-0.5)为-1.0）。</p>
<div class="alert danger no-icon"><p>对浮点数执行round()的行为可能会令人惊讶：例如，round(2.675, 2)将给出2.67而不是期望的2.68。这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。</p>
</div>

<h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>class set([iterable])<br>返回一个新的set对象，可以选择带有从iterable获取的元素。set是一个内置类型。</p>
<h3 id="setattr"><a href="#setattr" class="headerlink" title="setattr()"></a>setattr()</h3><p>setattr(object, name, value)<br>此函数与getattr()两相对应。其参数为一个对象、一个字符串和一个任意值。字符串指定一个现有属性或者新增属性。函数会将值赋给该属性，只要对象允许这种操作。例如，setattr(x, ‘foobar’, 123)等价于 x.foobar = 123。</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>class slice(stop)<br>class slice(start, stop[, step])<br>返回一个表示由range(start, stop, step)所指定索引集的slice对象。其中start和step参数默认为None。</p>
<p>切片对象具有仅会返回对应参数值（或其默认值）的只读数据属性start，stop 和 step。它们没有其他的显式功能；不过它们会被NumPy以及其他第三方扩展所使用。切片对象也会在使用扩展索引语法时被生成。例如：a[start:stop:step]或a[start:stop, i]。</p>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h3><p>sorted(iterable[, cmp[, key[, reverse]]])<br>根据 iterable 中的项返回一个新的已排序列表。</p>
<p>可选参数cmp，key和reverse与list.sort（）方法的含义相同。</p>
<p>cmp指定两个参数（可迭代元素）的自定义比较函数，它应返回负数，零或正数，具体取决于第一个参数是否被认为小于，等于或大于第二个参数：cmp=lambda x, y: cmp(x.lower(), y.lower())。默认值为None。</p>
<p>key指定一个参数的函数，该函数用于从每个列表元素中提取比较键：key=str.lower。默认值为None（直接比较元素）。</p>
<div class="alert danger no-icon"><p>内置的sorted()确保是稳定的。如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 — 这有利于进行多重排序（例如先按部门、再按薪级排序）。</p>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;student: %s&#x27;</span> % self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">students = [Student(<span class="built_in">str</span>(random.randint(<span class="number">0</span>, <span class="number">5</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="comment"># [student: 3, student: 0, student: 5, student: 2, student: 4]</span></span><br><span class="line"><span class="built_in">sorted</span>(students, cmp=<span class="keyword">lambda</span> x, y: cmp(x.name, y.name))</span><br><span class="line"><span class="comment"># [student: 0, student: 2, student: 3, student: 4, student: 5]</span></span><br><span class="line"><span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> x: x.name)</span><br><span class="line"><span class="comment"># [student: 0, student: 2, student: 3, student: 4, student: 5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="staticmethod"><a href="#staticmethod" class="headerlink" title="staticmethod()"></a>staticmethod()</h3><p>staticmethod(function)<br>返回一个静态的函数方法。<br>静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">arg1, arg2, ...</span>):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<div class="alert danger no-icon"><p>静态方法的调用可以在类上进行(例如C.f())也可以在实例上进行(例如C().f())。</p>
</div>

<h3 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h3><p>class str(object=’’)<br>返回一个包含对象的可打印表示的字符串。</p>
<p>对于字符串，这将返回字符串本身。与repr(object)的区别在于str(object)并不总是尝试返回eval()可接受的字符串；它的目标是返回一个可打印的字符串。</p>
<p>如果没有给出参数，则返回空字符串’’。</p>
<h3 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h3><p>sum(iterable[, start])<br>从start开始自左向右对iterable中的项求和并返回总计值。 </p>
<p>start默认为0。iterable的项通常为数字，开始值则不允许为字符串。</p>
<div class="alert info no-icon"><p>对某些用例来说，存在sum()的更好替代。拼接字符串序列的更好更快方式是调用’’.join(sequence)。要以扩展精度对浮点值求和，请参阅math.fsum()。要拼接一系列可迭代对象，请考虑使用itertools.chain()。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)    <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">sum</span>(x, <span class="number">10</span>)          <span class="comment"># 55</span></span><br></pre></td></tr></table></figure>

<h3 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h3><p>super(type[, object-or-type])<br>返回一个代理对象，它会将方法调用委托给type指定的父类或兄弟类。这对于访问已在类中被重载的继承方法很有用。搜索顺序与 getattr()所使用的相同，只是type指定的类型本身会被跳过。</p>
<p>type的__mro__属性列出了getattr()和super()所使用的方法解析顺序。该属性是动态的，可以在继承层级结构更新的时候任意改变。</p>
<p>如果省略第二个参数，则返回的超类对象是未绑定的。如果第二个参数为一个对象，则isinstance(obj, type)必须为真值。如果第二个参数为一个类型，则issubclass(type2, type)必须为真值（这适用于类方法）。</p>
<div class="alert info no-icon"><p>super()仅适用于新式类。</p>
</div>

<p>super 有两个典型用例。 </p>
<ol>
<li>在具有单继承的类层级结构中，super可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。这种用法与其他编程语言中super的用法非常相似。</li>
<li>用例是在动态执行环境中支持协作多重继承。此用例为Python所独有，在静态编译语言或仅支持单继承的语言中是不存在的。这使得实现“菱形图”成为可能，在这时会有多个基类实现相同的方法。好的设计强制要求这种方法在每个情况下具有相同的调用签名（因为调用顺序是在运行时确定的，也因为该顺序要适应类层级结构的更改，还因为该顺序可能包含在运行时之前未知的兄弟类）。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">B</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="built_in">super</span>(C, self).method(arg)</span><br></pre></td></tr></table></figure>
<div class="alert danger no-icon"><p>请注意super()是作为显式加点属性查找的绑定过程的一部分来实现的，例如super().__getitem__(name)。它做到这一点是通过实现自己的__getattribute__()方法，这样就能以可预测的顺序搜索类，并且支持协作多重继承。对应地，super()在像 super()[name]这样使用语句或操作符进行隐式查找时则未被定义。</p>
<p>另请注意，super（）不限于使用内部方法。两个参数形式完全指定参数并进行适当的引用。</p>
</div>

<h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple()"></a>tuple()</h3><p>tuple([iterable])<br>返回一个元组，其元素与iterable的项目相同且顺序相同。</p>
<p>iterable可以是一个序列，一个支持迭代的容器，或一个迭代器对象。如果iterable已经是一个元组，则返回不变。例如，tuple(‘abc’)返回(‘a’, ‘b’, ‘c’)和tuple([1, 2, 3])返回(1, 2, 3)。如果没有给出参数，则返回一个新的空元组()。</p>
<div class="alert info no-icon"><p>tuple（元组）是一个不可变的序列类型。</p>
</div>

<h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>class type(object)<br>class type(name, bases, dict)<br>使用一个参数时，返回对象的类型。返回值是一个类型对象。建议使用isinstance()内置函数来测试对象的类型。</p>
<p>使用三个参数时，返回一个新类型对象。这实际上是类语句的动态形式。名称字符串是类名，并成为__name__属性；base元组列出基类并成为__bases__属性；dict字典是包含类体定义的命名空间，并成为__dict__属性。例如，以下两个语句创建相同的类型对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">X = <span class="built_in">type</span>(<span class="string">&#x27;X&#x27;</span>, (<span class="built_in">object</span>,), <span class="built_in">dict</span>(a=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><h3 id="unichr"><a href="#unichr" class="headerlink" title="unichr()"></a>unichr()</h3><p>unichr(i)<br>返回Unicode代码为整数i的一个字符的Unicode字符串。例如，unichr(97)返回字符串u’a’。这是Unicode字符串的ord()的反转。</p>
<p>参数的有效范围取决于Python的配置方式 - 可能是UCS2[0..0xFFFF]或UCS4[0..0x10FFFF]。否则会引发<strong>ValueError</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)    <span class="comment"># 65</span></span><br><span class="line">unichr(<span class="number">65</span>)  <span class="comment"># A</span></span><br></pre></td></tr></table></figure>

<h3 id="unicode"><a href="#unicode" class="headerlink" title="unicode()"></a>unicode()</h3><p>unicode(object=’’)<br>unicode(object[, encoding[, errors]])<br>使用以下模式之一返回对象的Unicode字符串版本：</p>
<ul>
<li>如果给出了encoding和/或errors，unicode()将使用编解码器解码对象，该对象可以是8位字符串或字符缓冲区。encoding参数是一个给出编码名称的字符串；如果编码未知，则引发<strong>LookupError</strong>。错误处理是根据错误完成的；这指定了对输入编码中无效的字符的处理。如果错误是’strict’（默认值），则会在出现错误时引发<strong>ValueError</strong>，而值为’ignore’会导致错误被忽略，值为’replace’会导致官方Unicode替换字符，<strong>U+FFFD</strong>替换无法解码的输入字符。</li>
<li>如果没有给出可选参数，unicode()将模仿str()的行为，返回Unicode字符串而不是8位字符串。更确切地说，如果object是Unicode字符串或子类，它将返回该Unicode字符串，而不应用任何其他解码。</li>
<li>对于提供__unicode__()方法的对象，它将调用此方法而不使用参数来创建Unicode字符串。对于所有其他对象，请求8位字符串版本或表示，然后使用’strict’模式下的默认编码的编解码器将其转换为Unicode字符串。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__unicode__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">u&#x27;student: %s&#x27;</span> % self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unicode(Student(<span class="string">&#x27;wangkuntian&#x27;</span>))     <span class="comment"># student: wangkuntian</span></span><br><span class="line">unicode(<span class="string">&#x27;王&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)     <span class="comment"># 王</span></span><br><span class="line">unicode(<span class="string">&#x27;呼yue&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)   <span class="comment"># yue</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="V"><a href="#V" class="headerlink" title="V"></a>V</h2><h3 id="vars"><a href="#vars" class="headerlink" title="vars()"></a>vars()</h3><p>vars([object])<br>返回模块、类、实例或任何其它具有__dict__属性的对象的__dict__属性。</p>
<p>模块和实例等对象具有可更新的__dict__属性；但是，其他对象可能对其__dict__属性有写限制（例如，新式类使用dictproxy来防止直接字典更新）。</p>
<div class="alert info no-icon"><p>不带参数时，vars()的行为类似locals()。请注意，locals字典仅对于读取起作用，因为对locals字典的更新会被忽略。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vars</span>(Student(<span class="string">&#x27;wangkuntian&#x27;</span>))    <span class="comment"># &#123;&#x27;name&#x27;: &#x27;wangkuntian&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="X"><a href="#X" class="headerlink" title="X"></a>X</h2><h3 id="xrange"><a href="#xrange" class="headerlink" title="xrange()"></a>xrange()</h3><p>xrange(stop)<br>xrange(start, stop[, step])<br>此函数与range()非常相似，但返回xrange对象而不是list。</p>
<p>这是一个不透明的序列类型，它产生与相应列表相同的值，而不是实际同时存储它们。xrange()在range()上的优势是最小的（因为xrange()在被要求时仍需要创建值），除非在内存饥饿的机器上使用非常大的范围或者当所有范围的元素都是没用过（例如当循环通常以break结束时）。</p>
<div class="alert info no-icon"><p>CPython实现细节：<br>xrange()旨在简单快速。实现可能会对此实施限制。Python的C实现将所有参数限制为原生C long（“short”Python整数），并且还要求元素的数量适合原生C long。</p>
<p>如果需要更大的范围，可以使用itertools模块制作备用版本：<br>islice(count(start, step), (stop-start+step-1+2*(step&lt;0))//step)</p>
</div>

<h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><h3 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h3><p>zip([iterable, …])<br>此函数返回元组列表，其中第i个元组包含来自每个参数序列或迭代的第i个元素。返回的列表的长度被截断为最短参数序列的长度。</p>
<p>当有多个参数长度相同时，zip()类似于map()，初始参数为None。使用单个序列参数，它返回一个1元组的列表。没有参数，它返回一个空列表。</p>
<p>保证了迭代的从左到右的评估顺序。这使得使用zip(*[iter(s)]*n)将数据序列聚类成n长度组的习惯成为可能。</p>
<p>zip()与*运算符相结合可以用来拆解一个列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">zipped = <span class="built_in">zip</span>(x, y)              <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line">x2, y2 = <span class="built_in">zip</span>(*zipped)</span><br><span class="line">x == <span class="built_in">list</span>(x2) <span class="keyword">and</span> y == <span class="built_in">list</span>(y2) <span class="comment"># True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title="__"></a>__</h2><h3 id="import"><a href="#import" class="headerlink" title="__import__()"></a>__import__()</h3><p>__import__(name[, globals[, locals[, fromlist[, level]]]])</p>
<div class="alert info no-icon"><p>与importlib.import_module()不同，这是一个日常Python编程中不需要用到的高级函数。</p>
</div>

<p>import语句调用此函数。它可以替换（通过导入__builtin__模块并分配给__builtin__.__import__）以更改import语句的语义，但是现在通常使用导入钩子更简单。直接使用__import__()很少见，除非您要导入名称仅在运行时已知的模块。</p>
<p>该函数会导入name模块，有可能使用给定的globals和locals来确定如何在包的上下文中解读名称。fromlist给出了应该从由name 指定的模块导入对象或子模块的名称。标准实现完全不使用其locals参数，而仅使用globals参数来确定import语句的包上下文。</p>
<p>level指定是使用绝对导入还是相对导入。默认值为-1表示将同时尝试绝对与相对导入。0表示仅执行绝对导入。level的正值表示要搜索的父目录相对于调用__import__()的模块的目录的数量。</p>
<p>当name变量的形式为package.module时，通常将会返回最高层级的包（第一个点号之前的名称），而不是以name命名的模块。 但是，当给出了非空的fromlist参数时，则将返回以name命名的模块。</p>
<p>例如，语句import spam的结果将为与以下代码作用相同的字节码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam = <span class="built_in">__import__</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="built_in">globals</span>(), <span class="built_in">locals</span>(), [], -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>语句import spam.ham的结果将为以下调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam = <span class="built_in">__import__</span>(<span class="string">&#x27;spam.ham&#x27;</span>, <span class="built_in">globals</span>(), <span class="built_in">locals</span>(), [], -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>语句from spam.ham import eggs, sausage as saus 的结果将为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_temp = <span class="built_in">__import__</span>(<span class="string">&#x27;spam.ham&#x27;</span>, <span class="built_in">globals</span>(), <span class="built_in">locals</span>(), [<span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;sausage&#x27;</span>], -<span class="number">1</span>)</span><br><span class="line">eggs = _temp.eggs</span><br><span class="line">saus = _temp.sausage</span><br></pre></td></tr></table></figure>

<p>在这里，spam.ham模块会由__import__()返回。要导入的对象将从此对象中提取并赋值给它们对应的名称。</p>
<p>如果你只想按名称导入模块（可能在包中），请使用importlib.import_module()。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Python/" rel="tag">Python</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/"
                    data-tooltip="OpenStack通用库"
                    aria-label="PREVIOUS: OpenStack通用库"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/03/01/OpenStack%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"
                    data-tooltip="OpenStack通用技术"
                    aria-label="NEXT: OpenStack通用技术"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"
                    title="Share on Weibo"
                    aria-label="Share on Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/&amp;title=Python内置函数"
                    title="Share on QQ"
                    aria-label="Share on QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"
                    title="Share on Qzone"
                    aria-label="Share on Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>

<div class="main-content-wrap">
    
        
            <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
阅读量：<span id="2019/04/02/Python内置函数/" class="waline-visitor-count"></span>
<div id="vcomments"></div>
<script>
    new Waline({
        el: "#vcomments",
        serverURL: "https://blog-api-nu-nine.vercel.app/",
        lang: "zh-cn",
        visitor: true,
        emoji: [
            "https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili",
            "https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq",
        ],
        placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
        dark: "auto",
        meta: ["nick", "mail", "link"],
        requiredMeta: [],
        wordLimit: "200",
        pageSize: "10",
        highlight: "hanabi",
        copyright: true,
        avatar: "wavatar",
    });
</script>
  
        
    
</div>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 Wang kuntian. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/"
                    data-tooltip="OpenStack通用库"
                    aria-label="PREVIOUS: OpenStack通用库"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/03/01/OpenStack%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"
                    data-tooltip="OpenStack通用技术"
                    aria-label="NEXT: OpenStack通用技术"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"
                    title="Share on Weibo"
                    aria-label="Share on Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/&amp;title=Python内置函数"
                    title="Share on QQ"
                    aria-label="Share on QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"
                    title="Share on Qzone"
                    aria-label="Share on Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"
                        aria-label="Share on Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>Share on Weibo</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/&amp;title=Python内置函数"
                        aria-label="Share on QQ"
                    >
                        <i class="fab fa-qq" aria-hidden="true"></i><span>Share on QQ</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://wangkuntian.github.io/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"
                        aria-label="Share on Qzone"
                    >
                        <i class="fa fa-star" aria-hidden="true"></i><span>Share on Qzone</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/faker.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Wang kuntian</h4>
        
            <div id="about-card-bio"><p>Hi</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Software Engineer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Beijing
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-ndtc2tx33sr3grlppafri7aw03fwgxbruphsl7cntcdkym8tusuknerf6c0g.min.js"></script>

<!--SCRIPTS END-->


    




    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"display":{"superSample":2.5,"width":180,"height":400,"position":"right","hOffset":0,"vOffset":40},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":true,"hitokoto":false},"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hibiki.model.json"},"log":false});</script></body>
</html>
