
<!DOCTYPE html>
<html lang="zh-en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Wang kuntian&#39;s Blog">
    <title>OpenStack通用库 - Wang kuntian&#39;s Blog</title>
    <meta name="author" content="Wang kuntian">
    
        <meta name="keywords" content="OpenStack,Oslo">
    
    
        <link rel="icon" href="https://wangkuntian.github.io/assets/images/favicon.png">
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Wang kuntian","sameAs":["https://github.com/wangkuntian","mailto:wangkuntian1994@163.com"],"image":"faker.jpg"},"articleBody":"\n\n\ncliffcliff（Command Line Interface Formulation Framework）可以用来帮助构建命令行程序。\n开发者利用cliff框架可以构建诸如svn、git那样的支持多层命令的命令行程序。主程序只负责基本的命令行参数的解析，然后调用各个子命令去执行不同的操作。利用Python动态代码载入的特性，Cliff框架中的每个子命令可以和主程序分开来实现、打包和分发。\n整个cliff框架主要包括以下4种不同类型的对象。\n\ncliff.app.App：主程序对象，用来启动程序，并且负责一些对所有子命令都通用的操作，比如设置日志选项和输入/输出等。\n\ncliff.commandmanager.CommandManager：主要用来载入每一个子命令插件。默认是通过Setuptools的entry points来载入的。\n\ncliff.command.Command：用户可以实现Command的子类来实现不同的子命令，这些子命令被注册在Setuptools的entry points中，被CommandManager载入，每个子命令可以有自己的参数解析（一般使用argparse），同时要实现take_action()方法完成具体的命令。\n\ncliff.interactive.InteractiveApp：实现交互式命令行，一般使用框架提供的默认实现。\n\n\n示例1234567891011121314151617181920212223242526272829303132333435363738# main.pyimport sysimport loggingfrom cliff.app import Appfrom cliff.commandmanager import CommandManagerclass MyApp(App):    log = logging.getLogger(__name__)    def __init__(self):        super(MyApp, self).__init__(            description=&#x27;Cliff Demo App&#x27;,            version=&#x27;1.0&#x27;,            command_manager=CommandManager(&#x27;cliff.cliffdemo&#x27;)        )    def initialize_app(self, argv):        self.LOG.debug(&#x27;initialize_app&#x27;)    def prepare_to_run_command(self, cmd):        self.LOG.debug(&#x27;prepare_to_run_command %s&#x27; % cmd.__class__.__name__)    def clean_up(self, cmd, result, err):        self.LOG.debug(&#x27;clean_up %s&#x27; % cmd.__class__.__name__)        if err:            self.LOG.debug(&#x27;got an error: %s&#x27; % err)def main(argv=sys.argv[1:]):    my_app = MyApp()    return my_app.run(argv)if __name__ == &#x27;__main__&#x27;:    sys.exit(main(sys.argv[1:]))\n上面是主程序代码，新建一个MyApp实例对象，并且调用其run方法运行。MyApp是cliff.app.App的子类，它的初始化函数的原型定义如下。\n123456789class cliff.app.App(description,                     version,                     command_manager,                    stdin=None,                     stdout=None,                     stderr=None,                    interactive_app_factory=&lt;class cliff.interactive.InteractiveApp&gt;,                    deferred_help=False):    pass\n其中，stdin/stdout/stderr可以用来自定义用户自己的标准输入/输出/错误，command_manager必须指向一个cliff.commandmanager.CommandManager的对象实例，来载入各个子命令插件。\n\n\ncliff.commandmanager.CommandManager类的初始化函数原型定义如下。\n123class cliff.commandmanager.CommandManager(namespace,                                          convert_underscores=True):    pass\n其中，namespace用来指定Setuptool entry points的命名空间，CommandManager只会从这个命名空间中载入插件，convert_underscores参数指明是否需要把entry points中的下划线转为空格。\n\n\n\ncliff.App类的方法initialize_app()，会在主程序解析完用户的命令行参数后被调用，而且只会被调用一次。prepare_to_run_command()方法可以被用来做一些针对某个具体子命令的初始化工作，它将在该子命令执行之前被调用。clean_up()方法会在具体某个子命令完成后被调用，用来进行一些清理工作。\n\n\n具体某个子命令的实现通过继承cliff.command.Command来完成。\n123456789101112131415# simple.pyimport loggingfrom cliff.command import Commandclass Simple(Command):    log = logging.getLogger(__name__)    def take_action(self, parsed_args):        self.log.info(&#x27;sending greeting&#x27;)        self.log.debug(&#x27;debugging&#x27;)        self.app.stdout.write(&#x27;Hello world \\n&#x27;)\n\n子命令的实际工作由take_action()来完成。这例子里，simple子命令向标准输出打印一个字符串，它的实现代码由cliff.commandmanager.CommandManager通过Setuptools entry points来载入。\n1234567891011121314151617181920# setup.pyfrom setuptools import setup, find_packagessetup(    name=&#x27;cliffdemo&#x27;,    version=&#x27;1.0&#x27;,    install_requires=[&#x27;cliff&#x27;],    namespace_packages=[],    packages=find_packages(),    entry_points=&#123;        &#x27;console_scripts&#x27;: [            &#x27;cliffdemo = cliffdemo.main:main&#x27;        ],        &#x27;cliff.cliffdemo&#x27;: [            &#x27;simple = cliffdemo.simple:Simple&#x27;        ]    &#125;)\n在Setuptools entry points的命名空间cliff.demo中，定义了命令simple所对应的插件实现是Simple类。Cliff主程序解析用户的输入后，会通过这里所定义的对应关系调用不同的实现类。\nsimple命令执行结果如下。\n\n\noslo.configoslo.config用于解析命令行和配置文件中的配置项。\n示例1234567891011121314151617181920212223242526272829303132333435363738service.pyimport osfrom oslo_config import cfgopts = [    cfg.StrOpt(        &#x27;host&#x27;,        default=&#x27;127.0.0.1&#x27;,        help=&#x27;host of node&#x27;    ),    cfg.IntOpt(        &#x27;collector_workers&#x27;,        default=2,        help=&#x27;Number of workers for collector service.&#x27;    ),]# 注册配置选项cfg.CONF.register_opts(opts)# 将配置选项注册为命令行选项cli_opts = [    cfg.StrOpt(        &#x27;os-tenant-id&#x27;,        deprecated_group=&#x27;DEFAULT&#x27;,        default=os.environ.get(&#x27;OS_TENANT_ID&#x27;, &#x27;&#x27;),        help=&#x27;Tenant ID to use for Openstack service access.&#x27;    ),    cfg.BoolOpt(        &#x27;insecure&#x27;,        default=False,        help=&#x27;xxx&#x27;    ),]cfg.CONF.register_cli_opts(cli_opts, group=&#x27;service_credentials&#x27;)\n配置选项支持的类型配置选项支持的类型如下。\n\n\n\n类名\n说明\n\n\n\noslo_config.cfg.StrOpt\n字符串类型\n\n\noslo_config.cfg.BoolOpt\n布尔型\n\n\noslo_config.cfg.IntOpt\n整数类型\n\n\noslo_config.cfg.FloatOpt\n浮点数类型\n\n\noslo_config.cfg.ListOpt\n字符串列表类型\n\n\noslo_config.cfg.DictOpt\n字典类型，字典中的值需要是字符串类型。\n\n\noslo_config.cfg.MultiStrOpt\n可以分多次配置的字符串列表\n\n\noslo_config.cfg.IPOpt\nIP地址类型\n\n\noslo_config.cfg.HostnameOpt\n域名类型\n\n\noslo_config.cfg.URIOpt\nURI类型\n\n\n定义后的配置项，必须要注册才能使用。配置项还可以注册为命令行选项，之后，可以从命令行读取配置选项的值，并覆盖从配置文件中读取的值。注册配置选项时，可以把某些配置选项注册在一个特定的组下。默认的组是“DEFAULT”。\n\n\n自定义配置选项类型1234567891011121314from oslo_config import cfgfrom oslo_config import typesPortType = types.Integer(1, 65535)common_opts = [    cfg.Opt(        &#x27;bind_port&#x27;,        type=PortType(),        default=8080,        help=&#x27;Port number to listen on.&#x27;    )]\n\n相比于前面的方法，这种定义配置选项的方式能够更好地支持选项值得合法性检查，同时也能支持自定义选项类型。\n使用配置文件和命令行选项指定配置选项为了正确使用oslo.config，应用程序一般需要在启动的时候初始化。\n123from olso_config import cfgcfg.CONF(sys.argv[1:], project=&#x27;xyz&#x27;)\n\n初始化之后，才能正常解析配置文件和命令行选项。最终用户可以用默认的命令行选项“–config-file”或者“–config-dir”来指定配置文件名或者位置。如果没有明确指定，默认按照下面的顺序来寻找配置文件。\n1~/.xyz/xyz.conf ~/xyz.conf /etc/xyz/xyz.conf /etc/xyz.conf\n\n配置文件一般采用类似.ini文件的格式，其中每一个Section对应oslo.config中定义的一个配置选项组，Section[DEFAULT]对应了默认组“DEFAULT”。\n1234567[DEFULT]host = 127.0.0.1collector_workers = 3[service_credentials]insecure = Trueos-tenant-id = xyz123\n\n用命令行指定配置选项值时，如果是定义在某个选项组中的选项，命令行选项名中需要包括该组名作为前缀。\n\n1--service_credentials-os-tenant-id abc123\n\n使用其他模块中已经注册过的配置选项对于已经注册过的配置选项，开发者可以直接访问。\n1234from oslo_config import cfghost = cfg.CONF.hosttenant_id = cfg.CONF.service_credentials.os-tenant-id\n\n还可以使用import_opt来申明在别的模块中定义的配置选项。\n1234from oslo_config import cfgcfg.CONF.import_opt(&#x27;host&#x27;, &#x27;service&#x27;)host = cfg.CONF.host\n\noslo.dboslo.db是针对SQLAlchemy访问的抽象。\n使用SQLAlchemy的session和connectionoslo.db提供了oslo_db.sqlachemy.enginefacade模块来获取session和connection，有两种方法来使用enginefacade，即函数装饰器（decorator）和上下文管理器（context mangager）。这两种调用方式都需要提供一个上下文对象。上下文对象可以是任何Python类。这样做的目的是提供一个统一规范的session使用模式，避免调用者使用不当造成数据库事务（transaction）的滥用和嵌套。\n12345678910111213141516171819202122232425262728from oslo_db.sqlalchemy import enginefacadeclass SomeClass(object):    def __init__(self, x, y):        self.x = x        self.y = yclass MyContext(object):    pass    &#x27;User-defined context class&#x27;def read(context):    with enginefacade.reader.using(context) as session:        return session.query(SomeClass).all()def write(context, x, y):    with enginefacade.writer.using(context) as session:        session.add(SomeClass(x, y))def main():    context = MyContext()    results = read(context)    write(context, 0, 0)\n当使用装饰器模式的时候需要对context对象做特殊处理，调用transaction_context_provider装饰context对象。\n123456789101112131415161718192021222324252627282930from oslo_db.sqlalchemy import enginefacadeclass SomeClass(object):    def __init__(self, x, y):        self.x = x        self.y = y@enginefacade.transaction_context_providerclass MyContext(object):    pass    &#x27;User-defined context class&#x27;@enginefacade.readerdef read(context):    return context.session.query(SomeClass).all()@enginefacade.writerdef write(context, x, y):    context.session.add(SomeClass(x, y))def main():    context = MyContext()    results = read(context)    write(context, 0, 0)\n\n管理员可以通过配置文件来配置oslo.db的许多选项，比如：\n12[database]connection = mysql://root:root@localhost/ceilometer?charset=utf8\n用户可以在使用数据库之前调用oslo_db.sqlalchemy.enginefacade.configure()方法来改变已有的配置。\n\n\n常用配置选项。\n常用配置选项\n\n\n使用通用的SQLAlchemy model类12345678910from oslo_db.sqlalchemy.models import TimestampMixin, ModelBasefrom oslo_db.sqlalchemy.models import typesfrom oslo_db.sqlalchemy.models import Columnclass Project(TimestampMixin, ModelBase):    id = Column(types.Integer, primary_key=True)    name = Column(types.String)\noslol_db.sqlalchemy.models定义了两种Mixin：TimestampMixin和SoftDeleteMixin。使用TimestampMixin时SQLAlchemy model中会多出两列create_at和update_at，分别表示记录的创建时间和上一次修改时间。\nSoftDeleteMixin支持使用soft delete功能。\n12345678910111213from oslo_db.sqlalchemy.models import ModelBase, SoftDeleteMixinfrom oslo_db.sqlalchemy.models import typesfrom oslo_db.sqlalchemy.models import Columnfrom oslo_db.sqlalchemy.utils import model_queryclass Bar(SoftDeleteMixin, ModelBase):    id = Column(types.Integer, primary_key=True)    name = Column(types.String)count = model_query(Bar).find(id=1).soft_delete()if count == 0:    raise Exception(&quot;0 entries were soft deleted&quot;)\n\n不同DB后端的支持12345678910111213141516171819202122232425from oslo_config import cfgfrom oslo_db import api as db_api# 定义不同backend所对应的实现，如果配置选项conf.database.backend的值为sqlalchemy，# 就用project.db.sqlalchemy.api模块中的实现。_BACKEND_MAPPING = &#123;    &#x27;sqlalchemy&#x27;: &#x27;project.db.sqlalchemy.api&#x27;&#125;IMPL = db_api.DBAPI.from_config(cfg.CONF,                                backend_mapping=_BACKEND_MAPPING)def get_engine():    return IMPL.get_engine()def get_session():    return IMPL.get_session()# DB-API methoddef do_something(id):    return IMPL.do_something(id)\n\n\n不同backend具体实现时，需要定义如下函数返回具体DB API的实现类。\n12def get_backend():    return MyImplementationClass\n\noslo.messagingoslo.messaging库为OpenStack各个项目使用RPC和事件通知（Event Notification）提供了一套统一的接口。\n为了支持不同的RPC后端实现，oslo.messaging对如下的对象进行统一。\nTransportTransport主要实现RPC底层的通信（如Socket）以及时间循环、多线程等其他功能。用户可以通过URL来获得指向不同transport实现的句柄。URL格式如下：\n1transport://user:pass@host1:port[,hostN:portN]/virtual_host\n目前支持的Transport有rabbit、qpid与zmq，分别对应不同的后端消息总线。用户可以使用oslo.messaging.get_transport函数来获得transport对象实例的句柄。\nTargetTarget封装了指定一个消息最终目的地的所有信息。\nTarget 参数\n\n在不同的应用场景下，构造Target对象需要不同的参数：创建一个RPC服务器时，需要topic和server参数，exchange参数可选；指定一个endpoint的target时，namespace和version是可选的；客户端发送消息时，需要topic参数，其他可选。\n\n\nServer一个RPC服务器可以暴露多个endpoint，每个endpoint包含一组方法，这组方法可以被客户端通过某种Transport对象远程调用。创建Server对象时，需要指定Transport、Target和一组endpoint。\nRPC Client通过RPC Client，可以远程调用RPC Server上的方法。远程调用时，需要提供一个字典对象来指明调用的上下文，调用方法的名字和传递给调用方法的参数（用字典表示）。\n有cast和call两种远程调用方式。通过cast方式调用，请求发送后就直接返回。通过call方式调用，需要等待响应从服务器返回。\n\n\nNotifierNotifier用来通过Transport发送通知消息。通知消息遵循如下的格式。\n12345678&#123;     &#x27;message_id&#x27;: six.text_type(uuid.uuid4()), # 消息id    &#x27;publisher_id&#x27;: &#x27;compute.host1&#x27;            # 发送者id    &#x27;timestamp&#x27;: timeutils.utcnow(),           # 时间戳    &#x27;priority&#x27;: &#x27;WARN&#x27;,                        # 通知优先级    &#x27;event_type&#x27;: &#x27;compute.create_instance&#x27;,   # 通知类型    &#x27;payload&#x27;: &#123;&#x27;instance_id&#x27;: &#x27;123&#x27;&#125;          # 通知内容    &#125;\n\n用户可以在不同的优先级上发送通知，包括sample、critical、error、warn、info、debug和audit等。\n\n\nNotification ListenerNotification Listener和Server类似，一个Notification Listener对象可以暴露多个endpoint，每个endpoint包含一组方法。但是与Server对象中的endpoint不同的是，这里的endpoint中的方法对应通知消息的不同优先级。\n123456from oslo import messagingClass ErrorEndpoint(object):    def error(self, ctxt, pulisher_id, event_type, payload, metadata):        do_something(payload)        return messaging.NotificationResult.HANDLED\n\nendpoint中的方法如果返回messaging.NotificationResult.HANDLED或者None，表示这个通知消息已经被处理；如果返回messaging.NotificationResult.REQUEUE，表示这个通知消息要重新进入消息队列。\n\n\n利用oslo.messaging来实现远程过程调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# server.py 服务器端from oslo_config import cfgimport oslo_messaging as messagingimport timeclass ServerControllerEndpoint(object):    target = messaging.Target(        namespace=&#x27;control&#x27;,        version=&#x27;2.0&#x27;    )    def __init__(self, server):        self.server = server    def stop(self, context):        if self.server:            self.server.stop()class TestEndpoint(object):    def test(self, context, arg):        print arg        return argtransport = messaging.get_transport(cfg.CONF)target = messaging.Target(topic=&#x27;test&#x27;, server=&#x27;server-1&#x27;)endpoints = [    ServerControllerEndpoint(None),    TestEndpoint()]server = messaging.get_rpc_server(    transport=transport,    target=target,    endpoints=endpoints,    executor=&#x27;blocking&#x27;)try:    server.start()    while True:        time.sleep(1)except KeyboardInterrupt:    print &#x27;Stop server.&#x27;server.wait()\n\n上面定义了两个endpoint：ServerControlEndpoint与TestEndpoint。这两个endpoint中的方法stop()和test()都可以被客户端远程调用。\n创建rpc server对象之前，先创建transport和target对象，这里使用get_transport()函数来获得transport对象的句柄。\nget_transport 参数\n\n\nconf对象里，除了包含transport_url项外，还可以包含control_exchange项。control_exchange用来指明topic所属的默认范围，默认值为“openstack”。用户可以使用oslo.messaging.set_transport_defaults()函数来修改默认值。\n此处构建的Target对象是用来建立RPC server的，所以需要指明topic和server参数。用户定义的endpoint对象也可以包含一个target属性，用来指明这个endpoint所支持的特定的namespace和version。\n这里使用get_rpc_server()函数创建server对象，然后调用server对象的start()方法开始接收远程调用。\nget_rpc_server 参数\n\n123456789101112131415161718192021222324# client.py 客户端from oslo_config import cfgimport oslo_messaging as messagingtransport = messaging.get_transport(cfg.CONF)target = messaging.Target(topic=&#x27;test&#x27;)client = messaging.RPCClient(    transport=transport,    target=target)ret = client.call(    ctxt=&#123;&#125;,    method=&#x27;test&#x27;,    arg=&#123;&#x27;password&#x27;: &#x27;Hello world&#x27;&#125;)cctxt = client.prepare(    namespace=&#x27;control&#x27;,    version=&#x27;2.0&#x27;)cctxt.cast(&#123;&#125;, &#x27;stop&#x27;)\n\n这里target对象构造时，必要的参数只有topic，创建RPCClient对象时，可以接收的参数如下。\nRPCClient 参数\n\n远程调用时，需要传入调用上下文、调用方法的名字和传给调用方法的参数。\nTarget对象的属性在RPCClient对象构造以后，还可以通过prepare()方法修改。用户可以修改的属性包括exchange、topic、namespace、version、server、fanout、timeout、version_cap和retry。修改后target属性只在prepare()方法返回的对象中有效。\n利用oslo.messaging实现通知消息处理12345678910111213141516171819202122232425262728293031323334353637383940414243# notification_listener.py 消息通知处理from oslo_config import cfgimport oslo_messaging as messagingclass NotificationEndpoint(object):    filter_rule = messaging.NotificationFilter(        publisher_id=&#x27;^compute.*&#x27;    )    def warn(self, context, publisher_id, event_type, payload, metadata):        print context, publisher_id, event_type, payload, metadataclass ErrorEndpoint(object):    filter_rule = messaging.NotificationFilter(        publisher_id=&#x27;^instance\\..*\\.start$&#x27;,        context=&#123;&#x27;ctxt_key&#x27;: &#x27;regexp&#x27;&#125;    )    def error(self, context, publisher_id, event_type, payload, metadata):        print context, publisher_id, event_type, payload, metadatatransport = messaging.get_transport(cfg.CONF)targets = [    messaging.Target(topic=&#x27;notifications&#x27;),    messaging.Target(topic=&#x27;notifications_test&#x27;)]endpoints = [    NotificationEndpoint(),    ErrorEndpoint()]pool = &#x27;listener-workers&#x27;listener = messaging.get_notification_listener(    transport=transport,    targets=targets,    endpoints=endpoints,    pool=pool)listener.start()listener.wait()\n\n通知消息处理的endpoint对象和远程过程调用的endpoint对象不同，对象定义的方法需要和通知消息的优先级一一对应。我们可以为不同的endpoint对象指定所对应的target对象。\n最后调用get_notification_listener()函数构造notification listener对象。\nget_notification_listener 参数\n\n相对应的发送消息通知的代码如下。\n12345678910111213141516171819# notifier_send.pyfrom oslo_config import cfgimport oslo_messaging as messagingtransport = messaging.get_transport(cfg.CONF)notifier = messaging.Notifier(    transport=transport,    driver=&#x27;messaging&#x27;,    topics=[&#x27;notifications&#x27;])notifier_2 = notifier.prepare(publisher_id=&#x27;compute&#x27;)notifier_2.error(    ctxt=&#123;&#125;,    event_type=&#x27;my_type&#x27;,    payload=&#123;&#x27;content&#x27;: &#x27;Hello world&#x27;&#125;)\n\n发送消息时，首先要构造Notifier对象。\nNotifier 参数\n\n\n初始化Notifier对象的操作比较复杂，所以可以用prepare()方法修改已经创建的Notifier对象，prepare()方法返回的是新的Notifier对象的实例。\nprepare 参数\n\n最后可以调用Notifier对象的不同方法（error、warn、info等）发送不同优先级的消息通知。\nstevedore利用Python语言的特性，运行时动态载入代码变得更加容易。很多Python应用程序利用这样的特性在运行时发现和载入所谓的“插件”（plugin），使得自己更易于扩展。Python库stevedore就是在Setuptools的entry points基础上，构造了一层抽象层，使开发者可以更容易地在运行时发现和载入插件。\n插件entry points的每一个命名空间里，可以包含多个entry point项。stevedore要求每一项都符合如下格式：\n1name = module:importable\n\n左边是插件的名字，右边是它的具体实现，中间用等号分隔开。插件的具体实现用“模块:可导入的对象”的形式来指定。\n\n\n12345678ceilometer.compute.virt =    libvirt = ceilometer.compute.virt.libvirt.inspector:LibvirtInspector    hyperv = ceilometer.compute.virt.hyperv.inspector:HyperVInspector    vsphere = ceilometer.compute.virt.vmware.inspector:VsphereInspector    xenapi = ceilometer.compute.virt.xenapi.inspector:XenapiInspectorceilometer.hardware.inspectors =    snmp = ceilometer.hardware.inspector.snmp:SNMPInspector\n\n示例中显示了两个不同的entry points的命名空间，”ceilometer.compute.virt“和”ceilometer.hardware.inspectors“，分别注册了4个和1个插件。\n根据每个插件在entry point中名字和具体实现的数量之间的对应关系不同，stevedore提供了多种不同的类来帮助开发者发现和载入插件。\n\n\n\n插件名称: 具体实现\n建议选用stevedore中的类\n\n\n\n1: 1\nstevedore.driver.DriverManager\n\n\n1: n\nstevedore.hook.HookManager\n\n\nm: n\nstevedore.extension.ExtensionManager\n\n\n使用stevedore来帮助程序动态载入插件的过程主要分为3个部分：插件的实现、插件的注册和插件的载入。\n插件的实现Ceilometer的inspector驱动，为不从不同类型hypervisor中获取相关数据提供统一的接口以供compute agent使用。下面是它的基类。\n12345678910111213141516# ceilometer/compute/virt/inspector.pyclass Inspector(object):    def __init__(self, conf):        self.conf = conf    def inspect_instance(self, instance, duration):        &quot;&quot;&quot;Inspect the CPU statistics for an instance.        :param instance: the target instance        :param duration: the last &#x27;n&#x27; seconds, over which the value should be               inspected        :return: the instance stats        &quot;&quot;&quot;        raise ceilometer.NotImplementedError\n\nceilometer/compute/virt/hyperv/inspector.py，ceilometer/compute/virt/libvirt/inspector.py，ceilometer/compute/virt/vmware/inspector.py和ceilometer/compute/virt/xenapi/inspector.py分别为hyperv、kvm、vsphere和xenapi4种不同hypervisor的具体实现。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from ceilometer.compute.virt import inspector as virt_inspectorclass LibvirtInspector(virt_inspector.Inspector):    def __init__(self, conf):        super(LibvirtInspector, self).__init__(conf)        # NOTE(sileht): create a connection on startup        self.connection    @property    def connection(self):        return libvirt_utils.refresh_libvirt_connection(self.conf, self)    @libvirt_utils.raise_nodata_if_unsupported    @libvirt_utils.retry_on_disconnect    def inspect_instance(self, instance, duration=None):        domain = self._get_domain_not_shut_off_or_raise(instance)        memory_used = memory_resident = None        memory_swap_in = memory_swap_out = None        memory_stats = domain.memoryStats()        # Stat provided from libvirt is in KB, converting it to MB.        if &#x27;available&#x27; in memory_stats and &#x27;unused&#x27; in memory_stats:            memory_used = (memory_stats[&#x27;available&#x27;] -                           memory_stats[&#x27;unused&#x27;]) / units.Ki        if &#x27;rss&#x27; in memory_stats:            memory_resident = memory_stats[&#x27;rss&#x27;] / units.Ki        if &#x27;swap_in&#x27; in memory_stats and &#x27;swap_out&#x27; in memory_stats:            memory_swap_in = memory_stats[&#x27;swap_in&#x27;] / units.Ki            memory_swap_out = memory_stats[&#x27;swap_out&#x27;] / units.Ki        # TODO(sileht): stats also have the disk/vnic info        # we could use that instead of the old method for Queen        stats = self.connection.domainListGetStats([domain], 0)[0][1]        cpu_time = 0        current_cpus = stats.get(&#x27;vcpu.current&#x27;)        # Iterate over the maximum number of CPUs here, and count the        # actual number encountered, since the vcpu.x structure can        # have holes according to        # https://libvirt.org/git/?p=libvirt.git;a=blob;f=src/libvirt-domain.c        # virConnectGetAllDomainStats()        for vcpu in six.moves.range(stats.get(&#x27;vcpu.maximum&#x27;, 0)):            try:                cpu_time += (stats.get(&#x27;vcpu.%s.time&#x27; % vcpu) +                             stats.get(&#x27;vcpu.%s.wait&#x27; % vcpu))                current_cpus -= 1            except TypeError:                # pass here, if there are too many holes, the cpu count will                # not match, so don&#x27;t need special error handling.                pass        if current_cpus:            # There wasn&#x27;t enough data, so fall back            cpu_time = stats.get(&#x27;cpu.time&#x27;)        return virt_inspector.InstanceStats(            cpu_number=stats.get(&#x27;vcpu.current&#x27;),            cpu_time=cpu_time,            memory_usage=memory_used,            memory_resident=memory_resident,            memory_swap_in=memory_swap_in,            memory_swap_out=memory_swap_out,            cpu_cycles=stats.get(&quot;perf.cpu_cycles&quot;),            instructions=stats.get(&quot;perf.instructions&quot;),            cache_references=stats.get(&quot;perf.cache_references&quot;),            cache_misses=stats.get(&quot;perf.cache_misses&quot;),            memory_bandwidth_total=stats.get(&quot;perf.mbmt&quot;),            memory_bandwidth_local=stats.get(&quot;perf.mbml&quot;),            cpu_l3_cache_usage=stats.get(&quot;perf.cmt&quot;),        )\n\n插件的注册上述的插件需要在Setuptools的相关文件中注册后，才能被stevedore库所认识。\n12345678# setup.cfgceilometer.compute.virt =    libvirt = ceilometer.compute.virt.libvirt.inspector:LibvirtInspector    hyperv = ceilometer.compute.virt.hyperv.inspector:HyperVInspector    vsphere = ceilometer.compute.virt.vmware.inspector:VsphereInspector    xenapi = ceilometer.compute.virt.xenapi.inspector:XenapiInspector\n\n插件的载入1234567891011121314# ceilometer/compute/virt/inspector.pydef get_hypervisor_inspector(conf):    try:        namespace = &#x27;ceilometer.compute.virt&#x27;        mgr = driver.DriverManager(namespace,                                   conf.hypervisor_inspector,                                   invoke_on_load=True,                                   invoke_args=(conf, ))        return mgr.driver    except ImportError as e:        LOG.error(&quot;Unable to load the hypervisor inspector: %s&quot; % e)        return Inspector(conf)\nCeilometer的compute agent通过调用函数get_hypervisor_inspector来载入具体的某一个插件。此处由于插件和具体实现之间是一对一的关系，所以选用了stevedore的DriverManager类。\nDriverManager 参数\n\ntaskflow通过TaskFlow库，可以更容易地控制任务（Task）的执行。\n示例12345678910111213141516171819202122232425262728293031323334353637383940414243from taskflow import enginesfrom taskflow.patterns import linear_flow as lffrom taskflow import taskclass CallJim(task.Task):    def execute(self, jim_number, *args, **kwargs):        print &#x27;Calling Jim %s.&#x27; % jim_number    def revert(self, jim_number, *args, **kwargs):        print &#x27;Calling %s and apologizing.&#x27; % jim_numberclass CallJoe(task.Task):    def execute(self, joe_number, *args, **kwargs):        print &#x27;Calling Joe %s.&#x27; % joe_number    def revert(self, joe_number, *args, **kwargs):        print &#x27;Calling %s and apologizing.&#x27; % joe_numberclass CallHY(task.Task):    def execute(self, hy_number, *args, **kwargs):        raise IOError(&#x27;HY not at home right now.&#x27;)flow = lf.Flow(&#x27;simple-linear&#x27;).add(    CallJim(),    CallJoe(),    CallHY())try:    engines.run(        flow=flow,        engine_conf=&#123;&#x27;engine&#x27;: &#x27;serial&#x27;&#125;,        store=dict(jim_number=444,                   joe_number=555,                   hy_number=666)    )except Exception as e:    print &#x27;Flow failed: %s&#x27; % e\n\ntask这个示例首先定义了三个task：CallJim、CallJoe和CallHY。在TaskFlow库中，task是拥有执行（execute）和回滚（revert）功能的最小单位（TaskFlow中最小的单位是atom，其他所有类包括Task都是Atom类的子类）。在Task类中，允许开发者定义自己的execute函数和revert函数，分别用来执行task和回退task到之前一次的执行结果。\n然后新新建一个线性流flow，并在其中顺序加入上述3个task对象。TaskFlow中的流flow用来关联各个task，并且规范这些task之间的执行和回滚顺序。\nTaskFlow中所支持的流类型。\n\n\n\n流类型\n说明\n\n\n\nlinear_flow.Flow\n线性流，流中的task/flow按加入顺序执行，按加入顺序的倒序回滚。\n\n\nunordered_flow.Flow\n无顺序流，流中的task/flow的执行和回滚可以按任意顺序。\n\n\ngraph_flow.Flow\n图流，流中的task/flow按照显式指定的依赖关系，或者通过其间provides和requires属性之间的隐含依赖关系，来执行或回滚。\n\n\n这个示例中，由于采用的是线性流，所以这个流中task的执行顺序为：CallJim -&gt; CallJoe -&gt; CallHY，回滚顺序是其倒序。\n\n\nretry流中不仅可以加入任务，还可以嵌套加入其他的流。此外，流还可以通过retry来控制当错误发生时，该如何重试。\nTaskFlow支持的retry类型。\n\n\n\nRetry类型\n说明\n\n\n\nAlwaysRevert\n错误发生时，回滚子流。\n\n\nAlwaysRevertAll\n错误发生时，回滚所有子流。\n\n\nTimes\n错误发生时，重试子流。\n\n\nForEach\n每次错误发生时，为子流中的atom提供一个新的值，然后重试，直到成功或者此retry中定义的值用光为止。\n\n\nParameterizedForEach\n类似ForEach，但是是从后台存储中获取重试的值\n\n\n示例。\n1234567891011121314151617181920212223242526class EchoTask(task.Task):    def execute(self, name, *args, **kwargs):        print &#x27;my name is %s&#x27; % name    def revert(self, name, *args, **kwargs):        print &#x27;sorry, my name is %s&#x27; % nameflow = lf.Flow(&#x27;f1&#x27;).add(    EchoTask(&#x27;t1&#x27;),    lf.Flow(        &#x27;f2&#x27;,        retry=retry.ForEach(            values=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;],            name=&#x27;r1&#x27;,            provides=&#x27;value&#x27;        )    ).add(        EchoTask(&#x27;t2&#x27;),        EchoTask(&#x27;t3&#x27;, requires=&#x27;value&#x27;)    ),    EchoTask(&#x27;t4&#x27;))\n上面的示例，构造了一个线性流f1，它按顺序执行任务t1、子线性流f2、和任务t4。子流f2按序执行任务t2和t3。\n子流f2定义了ForEach类型的retry“r1”。当任务t2或者t3失败时，子流t2首先会回滚。然后“r1”会指导子流f2使用值“a”来重新运行。如果再次失败，子流f2回滚后会再次使用“b”运行；仍然失败后回滚使用值“c”运行。如果值“c”也运行失败，由于“r1”中能够提供的值已经被完全用完，子流f2回滚后不会重新运行。\nengineTaskFlow库中的engine用来载入一个flow，然后驱动flow中的task/flow运行。可以通过engine_conf来指明不同的engine类型。\n\n\n\nengine类型\n说明\n\n\n\n‘serial’\n所有的task都在调用engine.run的那个线程中运行。\n\n\n‘parallel’\ntask可能会被调度到不同的线程中并发运行。\n\n\n‘worker-based’\ntask会被调度到不同的worker中运行。一个worker是一个单独的专门用来运行某些特定task的进程，这个worker进程可以在远程机器上，利用AMQP来通信。\n\n\ntask和flow的输入/输出示例。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from taskflow.patterns import graph_flow as gffrom taskflow.patterns import linear_flow as lffrom taskflow import taskfrom taskflow import enginesclass Adder(task.Task):    def execute(self, x, y, *args, **kwargs):        return x + yflow = gf.Flow(&#x27;root&#x27;).add(    lf.Flow(&#x27;nested_linear&#x27;).add(        # 从后台存储中读取名为y3和y4的参数值，并以参数x，y传递给execute方法        # x2 = y3 + y4        Adder(&#x27;add2&#x27;, provides=&#x27;x2&#x27;, rebind=[&#x27;y3&#x27;, &#x27;y4&#x27;]),        # x1 = y1 + y2        Adder(&#x27;add1&#x27;, provides=&#x27;x1&#x27;, rebind=[&#x27;y1&#x27;, &#x27;y2&#x27;]),    ),    # x5 = x1 + x3    Adder(&#x27;add5&#x27;, provides=&#x27;x5&#x27;, rebind=[&#x27;x1&#x27;, &#x27;x3&#x27;]),    # x3 = x1 + x2    Adder(&#x27;add3&#x27;, provides=&#x27;x3&#x27;, rebind=[&#x27;x1&#x27;, &#x27;x2&#x27;]),    # x4 = x2 + y5    Adder(&#x27;add4&#x27;, provides=&#x27;x4&#x27;, rebind=[&#x27;x2&#x27;, &#x27;y5&#x27;]),    # x6 = x5 + x4    Adder(&#x27;add6&#x27;, provides=&#x27;x6&#x27;, rebind=[&#x27;x5&#x27;, &#x27;x4&#x27;]),    # x7 = x6 + x6    Adder(&#x27;add7&#x27;, provides=&#x27;x7&#x27;, rebind=[&#x27;x6&#x27;, &#x27;x6&#x27;]))store = &#123;    &#x27;y1&#x27;: 1,    &#x27;y2&#x27;: 3,    &#x27;y3&#x27;: 5,    &#x27;y4&#x27;: 7,    &#x27;y5&#x27;: 9&#125;result = engines.run(    flow=flow,    store=store,    engine_conf=&#x27;serial&#x27;)print &#x27;single thread engine result %s&#x27; % resultresult = engines.run(    flow=flow,    store=store,    engine_conf=&#x27;parallel&#x27;)print &#x27;multi thread engine result %s&#x27; % result\n\n上面的示例中，定义了一个Task对象Adder，作用是完成一个加法。接下去生成一个图类型的流root，其中的task都通过provides和rebind来指明它们的输出和输入。\n在engine运行时，通过store参数为流root提供所需要的输入参数，engine会把store的值保存在后台存储中：在执行各个task的过程中，各个task的输入都是从后台存储中获取，输出都保存在后台存储中。这个程序的输出结果如下：\n12Single thread engine result &#123;&#x27;x1&#x27;: 4, &#x27;y5&#x27;: 9, &#x27;y4&#x27;: 7, &#x27;y1&#x27;: 1, &#x27;x2&#x27;: 12, &#x27;x3&#x27;: 16, &#x27;y3&#x27;: 5, &#x27;y2&#x27;: 3, &#x27;x6&#x27;: 41, &#x27;x7&#x27;: 82, &#x27;x4&#x27;: 21, &#x27;x5&#x27;: 20&#125;.Multi thread engine result &#123;&#x27;x1&#x27;: 4, &#x27;y5&#x27;: 9, &#x27;y4&#x27;: 7, &#x27;y1&#x27;: 1, &#x27;x2&#x27;: 12, &#x27;x3&#x27;: 16, &#x27;y3&#x27;: 5, &#x27;y2&#x27;: 3, &#x27;x6&#x27;: 41, &#x27;x7&#x27;: 82, &#x27;x4&#x27;: 21, &#x27;x5&#x27;: 20&#125;.\n\nTaskFlow中的Task和Retry都是Atom的子类。对于任何一种Atom对象，都可以通过requires属性来了解它所要求的输入参数，和通过provides属性来了解它能够提供的输出结果的名字。requires和provides的类型都是包含参数名称的集合（set）。\nrequiresTask对象的requires可以由execute方法获得。比如示例中的Adder对象，由于execute方法的参数是execute(self, x, y)，所以它的requires为：\n123Adder().requiresOrderedSet([&#x27;x&#x27;, &#x27;y&#x27;])\n注意，execute方法的可选参数和*args和**kwargs并不会出现在requires中。\n\n\n1234567class MyTask(task.Task):    def execute(self, spam, eggs=(), *args, **kwargs):        return spam + eggsMyTask().requiresOrderedSet([&#x27;spam&#x27;])\n\n1234567class UniTask(task.Task):    def execute(self, *args, **kwargs):        passUniTask().requiresOrderedSet([])\n\n此外，也可以在创建Task时明确指定它的输入参数要求，这些参数在调用execute()方法时可以通过kwargs获得：\n12345678class Dog(task.Task):    def execute(self, food, *args, **kwargs):        passdog = Dog(requires=(&#x27;water&#x27;, &#x27;grass&#x27;))dog.requiresOrderedSet([&#x27;food&#x27;, &#x27;water&#x27;, &#x27;grass&#x27;])\n\nrebind在有些情况下，传递给某个task的输入参数名称和其所需要的参数名不同，这个时候可以通过rebind来处理。\n12345678910111213141516171819202122from taskflow import taskclass SpawnVMTask(task.Task):    def execute(self, vm_name, vm_image_id, *args, **kwargs):        pass# engine执行下面这个task时，会从后台存储中获取到名为&#x27;name&#x27;的参数值# 然后把它当做vm_name参数传递给task的execute()方法s = SpawnVMTask(rebind=&#123;&#x27;vm_name&#x27;: &#x27;name&#x27;&#125;)s.requiresOrderedSet([&#x27;name&#x27;, &#x27;vm_image_id&#x27;])# engine执行下面这个task时，会从后台存储中获取到名为&#x27;name&#x27;, &#x27;image_id&#x27;# 和&#x27;admin_key_name&#x27;的参数值，把name和image_id分别当做vm_name# 和vm_image_id参数，把admin_key_name当做args参数中的某一项传递# 给task的execute()方法s = SpawnVMTask(rebind=(&#x27;name&#x27;, &#x27;image_id&#x27;, &#x27;admin_key_name&#x27;))s.requiresOrderedSet([&#x27;name&#x27;, &#x27;image_id&#x27;, &#x27;admin_key_name&#x27;])\nprovidestask的输出结果一般是指其execute()方法的返回值。但是由于Python返回值是没有名字的，所有需要通过Task对象的provides属性指明返回值以什么名称存入后台存储中。根据execute()返回值类型的不同，provides可以有不同的方式指定。\n\n如果execute()方法返回的是一个单一的值。\n12345678910111213141516171819from taskflow import taskfrom taskflow import enginesfrom taskflow.patterns import linear_flow as lfclass TheAnswerReturningTask(task.Task):    def execute(self, *args, **kwargs):        return 24t = TheAnswerReturningTask(provides=&#x27;the_answer&#x27;)flow = lf.Flow(&#x27;linear&#x27;).add(t)result = engines.run(    flow=flow,    engine_conf=&#x27;serial&#x27;)result&#123;&#x27;the_answer&#x27;: 24&#125;\n\n如果execute()方法返回元组tuple。\n123456789101112131415161718from taskflow import taskfrom taskflow import enginesfrom taskflow.patterns import linear_flow as lfclass BitsAndPiecesTask(task.Task):    def execute(self, *args, **kwargs):        return &#x27;Bits&#x27;, &#x27;Pieces&#x27;t = BitsAndPiecesTask(provides=(&#x27;bits&#x27;, &#x27;pieces&#x27;))flow = lf.Flow(&#x27;linear&#x27;).add(t)result = engines.run(    flow=flow,    engine_conf=&#x27;serial&#x27;)result&#123;&#x27;bits&#x27;: &#x27;Bits&#x27;, &#x27;pieces&#x27;: &#x27;Pieces&#x27;&#125;\n\n如果execute()方法返回字典。\n123456789101112131415161718from taskflow import taskfrom taskflow import enginesfrom taskflow.patterns import linear_flow as lfclass BitsAndPiecesTask(task.Task):    def execute(self, *args, **kwargs):        return &#123;&#x27;Bits&#x27;: 123, &#x27;Pieces&#x27;: 321&#125;t = BitsAndPiecesTask(provides=&#123;&#x27;Bits&#x27;, &#x27;Pieces&#x27;&#125;)flow = lf.Flow(&#x27;linear&#x27;).add(t)result = engines.run(    flow=flow,    engine_conf=&#x27;serial&#x27;)result&#123;&#x27;Bits&#x27;: 123, &#x27;Pieces&#x27;: 321&#125;\n\n\n\noslo.policyoslo.policy用于控制用户的权限，能够执行什么样的操作。\nOpenStack的每个项目都有一个/etc//policy.yaml文件，通过这个配置文件来实现对用户的权限管理。\n将policy操作的公共部分提取出来，就形成了oslo.policy库，它会负责policy的验证和rules的管理。\npolicy的验证，其实就是对字典key和value的判断，如果匹配成功，则通过policy，否则失败。\n各个工程的API通过policy来检测用户身份群权限的规则，例如有些API只有管理员权限可以执行，有些普通用户可以执行，在代码中的体现就是判断context的project_id和user_id是不是合法类型的。\nNova API示例。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546def authorize(context, action, target, do_raise=True, exc=None):    &quot;&quot;&quot;Verifies that the action is valid on the target in this context.       :param context: nova context       :param action: string representing the action to be checked           this should be colon separated for clarity.           i.e. ``compute:create_instance``,           ``compute:attach_volume``,           ``volume:attach_volume``       :param target: dictionary representing the object of the action           for object creation this should be a dictionary representing the           location of the object e.g. ``&#123;&#x27;project_id&#x27;: context.project_id&#125;``       :param do_raise: if True (the default), raises PolicyNotAuthorized;           if False, returns False       :param exc: Class of the exception to raise if the check fails.                   Any remaining arguments passed to :meth:`authorize` (both                   positional and keyword arguments) will be passed to                   the exception class. If not specified,                   :class:`PolicyNotAuthorized` will be used.       :raises nova.exception.PolicyNotAuthorized: if verification fails           and do_raise is True. Or if &#x27;exc&#x27; is specified it will raise an           exception of that type.       :return: returns a non-False value (not necessarily &quot;True&quot;) if           authorized, and the exact value False if not authorized and           do_raise is False.    &quot;&quot;&quot;    init()    credentials = context.to_policy_values()    if not exc:        exc = exception.PolicyNotAuthorized    try:        result = _ENFORCER.authorize(action, target, credentials,                                     do_raise=do_raise, exc=exc, action=action)    except policy.PolicyNotRegistered:        with excutils.save_and_reraise_exception():            LOG.exception(_LE(&#x27;Policy not registered&#x27;))    except Exception:        with excutils.save_and_reraise_exception():            LOG.debug(&#x27;Policy check for %(action)s failed with credentials &#x27;                      &#x27;%(credentials)s&#x27;,                      &#123;&#x27;action&#x27;: action, &#x27;credentials&#x27;: credentials&#125;)    return result\n对应/etc/nova/policy.json文件内容如下：\n123456&#123;    &quot;context_is_admin&quot;:  &quot;role:admin&quot;,    &quot;admin_or_owner&quot;:  &quot;is_admin:True or project_id:%(project_id)s&quot;,    &quot;default&quot;: &quot;rule:admin_or_owner&quot;    ......&#125;\n从上面的例子可以看到，nova policy的rule是“is_admin:True or project_id:%(project_id)s”，需要验证policy验证是不是admin用户或者project_id是不是匹配。\noslo.rootwarposlo.rootwarp可以让其他OpenStack服务以root身份执行shell命令。一般来说，OpenStack的服务都是以非特权用户的身份运行的，但是当它们需要以root身份运行某些shell命令时，就需要利用到oslo.rootwrap的功能。\noslo.rootwarp首先从配置文件所定义的Filter文件目录中读取所有Filter定义，然后检查要运行的shell命令是否和Filter中的定义相匹配，匹配则运行，不匹配就不运行。\n构造rootwrap shell脚本使用rootwrap需要在一个单独的Python进程中以root身份调用Python函数oslo.rootwrap.cmd.main()。可以通过Setuptools中的console script来构造这样一个脚本。\n以nova为例。\n12345678910# setup.cfgconsole_scripts =    nova-api = nova.cmd.api:main    nova-compute = nova.cmd.compute:main    nova-conductor = nova.cmd.conductor:main    nova-console = nova.cmd.console:main    nova-manage = nova.cmd.manage:main    nova-policy = nova.cmd.policy:main    nova-rootwrap = oslo_rootwrap.cmd:main\n可以看到构造一个名为nova-rootwrap的shell脚本时，会调用oslo.rootwrap.cmd.main()函数。运行“python setup.py install”之后，nova-rootwrap脚本就会被生成。\n调用rootwrap shell脚本rootwrap的shell脚本需要以sudo方式调用。\n1sudo nova-rootwrap /etc/nova/rootwrap.conf COMAND_LINE\n其中/etc/nova/rootwrap.conf是oslo.rootwrap的配置文件名，COMAND_LINE是希望root用户身份运行的shell命令。\n由于rootwrap shell 脚本需要以sudo方式运行，所以还需要配置sudoers文件：\n1nova ALL = (root) NOPASSWD: /var/lib/kolla/venv/bin/nova-rootwrap /etc/nova/rootwrap.conf *\n\nrootwrap配置文件rootwrap配置文件是以INI的文件格式存放的。\nrootwrap 配置选项\n\n定义FilterFilter定义文件一般以.filter后缀结尾，放在配置选项filters_path所指定的目录中。这些定义文件以ini格式存放，Filter的定义存放在[Filter]节中。定义的格式如下。\n1Filter名: Filter类, [Filter类参数1, Filter类参数2, ...]\n\nrootwrap目前所支持的Filter类型。\nrootwrap 所支持的Filter类型\n\noslo.testoslo.test库提供单元测试的基础框架。\noslo.versionedobjects在项目的不断迭代和升级中，数据库结构和API接口的改动不可避免，如果没有一个版本控制的概念在里面，新旧不同模块之间交互就很容易出现问题。oslo.versionedobjects库提供一种通用的自带版本的对象模型，自带序列化功能，可以很容易地和oslo.messaging结合进行远程调用。","dateCreated":"2019-05-07T20:41:33+08:00","dateModified":"2023-09-21T10:45:00+08:00","datePublished":"2019-05-07T20:41:33+08:00","description":"OpenStack通用库","headline":"OpenStack通用库","image":[null,"images/PROJECT-Vayne.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/"},"publisher":{"@type":"Organization","name":"Wang kuntian","sameAs":["https://github.com/wangkuntian","mailto:wangkuntian1994@163.com"],"image":"faker.jpg","logo":{"@type":"ImageObject","url":"faker.jpg"}},"url":"https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/","keywords":"OpenStack, Oslo","thumbnailUrl":"images/PROJECT-Vayne.jpg"}</script>
    <meta name="description" content="OpenStack通用库">
<meta property="og:type" content="blog">
<meta property="og:title" content="OpenStack通用库">
<meta property="og:url" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/index.html">
<meta property="og:site_name" content="Wang kuntian&#39;s Blog">
<meta property="og:description" content="OpenStack通用库">
<meta property="og:locale" content="zh_EN">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/cliff_result.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/oslo_db.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/oslo.messaging_Target.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/oslo.messaging_get_transport.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/oslo.messaging_get_rpc_server.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/oslo.messaging_RPCClient.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/oslo.messaging_get_notification_listener.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/oslo.messaging_Notifier.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/oslo.messaging_prepare.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/stevedore_DriverManager.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/task_result.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/oslo.rootwrap.png">
<meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/oslo.rootwrap_filter.png">
<meta property="article:published_time" content="2019-05-07T12:41:33.000Z">
<meta property="article:modified_time" content="2023-09-21T02:45:00.039Z">
<meta property="article:author" content="Wang kuntian">
<meta property="article:tag" content="OpenStack">
<meta property="article:tag" content="Oslo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/cliff_result.png">
    
    
        
    
    
        <meta property="og:image" content="https://wangkuntian.github.io/assets/images/faker.jpg"/>
    
    
    
        <meta property="og:image" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/PROJECT-Vayne.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/images/PROJECT-Vayne.jpg"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-bkzaqwnhdy35ne9gawopbfxp7lltc7yhde0uckf6kikurfjo9ztq2v5apuqa.min.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136102260-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-136102260-1');
    </script>


    

    
        
    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Wang kuntian&#39;s Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/faker.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/faker.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Wang kuntian</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Hi</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/wangkuntian"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:wangkuntian1994@163.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full"
             style="background-image:url('/images/PROJECT-Vayne.jpg');"
             data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            OpenStack通用库
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-05-07T20:41:33+08:00">
	
		    May 07, 2019
    	
    </time>
    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cliff"><span class="toc-text">cliff</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#oslo-config"><span class="toc-text">oslo.config</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9%E6%94%AF%E6%8C%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">配置选项支持的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">自定义配置选项类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9"><span class="toc-text">使用配置文件和命令行选项指定配置选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%B7%B2%E7%BB%8F%E6%B3%A8%E5%86%8C%E8%BF%87%E7%9A%84%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9"><span class="toc-text">使用其他模块中已经注册过的配置选项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#oslo-db"><span class="toc-text">oslo.db</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8SQLAlchemy%E7%9A%84session%E5%92%8Cconnection"><span class="toc-text">使用SQLAlchemy的session和connection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E7%94%A8%E7%9A%84SQLAlchemy-model%E7%B1%BB"><span class="toc-text">使用通用的SQLAlchemy model类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8CDB%E5%90%8E%E7%AB%AF%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">不同DB后端的支持</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#oslo-messaging"><span class="toc-text">oslo.messaging</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Transport"><span class="toc-text">Transport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Target"><span class="toc-text">Target</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Server"><span class="toc-text">Server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC-Client"><span class="toc-text">RPC Client</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Notifier"><span class="toc-text">Notifier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Notification-Listener"><span class="toc-text">Notification Listener</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8oslo-messaging%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-text">利用oslo.messaging来实现远程过程调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8oslo-messaging%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-text">利用oslo.messaging实现通知消息处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stevedore"><span class="toc-text">stevedore</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6"><span class="toc-text">插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">插件的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-text">插件的注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%9A%84%E8%BD%BD%E5%85%A5"><span class="toc-text">插件的载入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#taskflow"><span class="toc-text">taskflow</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#task"><span class="toc-text">task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#retry"><span class="toc-text">retry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#engine"><span class="toc-text">engine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#task%E5%92%8Cflow%E7%9A%84%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-text">task和flow的输入&#x2F;输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#requires"><span class="toc-text">requires</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rebind"><span class="toc-text">rebind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#provides"><span class="toc-text">provides</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#oslo-policy"><span class="toc-text">oslo.policy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#oslo-rootwarp"><span class="toc-text">oslo.rootwarp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0rootwrap-shell%E8%84%9A%E6%9C%AC"><span class="toc-text">构造rootwrap shell脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8rootwrap-shell%E8%84%9A%E6%9C%AC"><span class="toc-text">调用rootwrap shell脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rootwrap%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">rootwrap配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89Filter"><span class="toc-text">定义Filter</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#oslo-test"><span class="toc-text">oslo.test</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#oslo-versionedobjects"><span class="toc-text">oslo.versionedobjects</span></a></li></ol>

<h1 id="cliff"><a href="#cliff" class="headerlink" title="cliff"></a>cliff</h1><p><a target="_blank" rel="noopener" href="https://github.com/openstack/cliff">cliff</a>（Command Line Interface Formulation Framework）可以用来帮助构建命令行程序。</p>
<p>开发者利用cliff框架可以构建诸如svn、git那样的支持多层命令的命令行程序。主程序只负责基本的命令行参数的解析，然后调用各个子命令去执行不同的操作。利用Python动态代码载入的特性，Cliff框架中的每个子命令可以和主程序分开来实现、打包和分发。</p>
<p>整个cliff框架主要包括以下4种不同类型的对象。</p>
<ul>
<li><p>cliff.app.App：主程序对象，用来启动程序，并且负责一些对所有子命令都通用的操作，比如设置日志选项和输入/输出等。</p>
</li>
<li><p>cliff.commandmanager.CommandManager：主要用来载入每一个子命令插件。默认是通过Setuptools的entry points来载入的。</p>
</li>
<li><p>cliff.command.Command：用户可以实现Command的子类来实现不同的子命令，这些子命令被注册在Setuptools的entry points中，被CommandManager载入，每个子命令可以有自己的参数解析（一般使用argparse），同时要实现take_action()方法完成具体的命令。</p>
</li>
<li><p>cliff.interactive.InteractiveApp：实现交互式命令行，一般使用框架提供的默认实现。</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> cliff.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> cliff.commandmanager <span class="keyword">import</span> CommandManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyApp</span>(<span class="title class_ inherited__">App</span>):</span><br><span class="line">    log = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyApp, self).__init__(</span><br><span class="line">            description=<span class="string">&#x27;Cliff Demo App&#x27;</span>,</span><br><span class="line">            version=<span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">            command_manager=CommandManager(<span class="string">&#x27;cliff.cliffdemo&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize_app</span>(<span class="params">self, argv</span>):</span><br><span class="line">        self.LOG.debug(<span class="string">&#x27;initialize_app&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepare_to_run_command</span>(<span class="params">self, cmd</span>):</span><br><span class="line">        self.LOG.debug(<span class="string">&#x27;prepare_to_run_command %s&#x27;</span> % cmd.__class__.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clean_up</span>(<span class="params">self, cmd, result, err</span>):</span><br><span class="line">        self.LOG.debug(<span class="string">&#x27;clean_up %s&#x27;</span> % cmd.__class__.__name__)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            self.LOG.debug(<span class="string">&#x27;got an error: %s&#x27;</span> % err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv=sys.argv[<span class="number">1</span>:]</span>):</span><br><span class="line">    my_app = MyApp()</span><br><span class="line">    <span class="keyword">return</span> my_app.run(argv)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sys.exit(main(sys.argv[<span class="number">1</span>:]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面是主程序代码，新建一个MyApp实例对象，并且调用其run方法运行。MyApp是cliff.app.App的子类，它的初始化函数的原型定义如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cliff</span>.app.App(description, </span><br><span class="line">                    version, </span><br><span class="line">                    command_manager,</span><br><span class="line">                    stdin=<span class="literal">None</span>, </span><br><span class="line">                    stdout=<span class="literal">None</span>, </span><br><span class="line">                    stderr=<span class="literal">None</span>,</span><br><span class="line">                    interactive_app_factory=&lt;<span class="keyword">class</span> <span class="title class_">cliff</span>.interactive.InteractiveApp&gt;,</span><br><span class="line">                    deferred_help=<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<div class="alert info no-icon"><p>其中，stdin/stdout/stderr可以用来自定义用户自己的标准输入/输出/错误，command_manager必须指向一个cliff.commandmanager.CommandManager的对象实例，来载入各个子命令插件。</p>
</div>

<p>cliff.commandmanager.CommandManager类的初始化函数原型定义如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cliff</span>.commandmanager.CommandManager(namespace,</span><br><span class="line">                                          convert_underscores=<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<div class="alert info no-icon"><p>其中，namespace用来指定Setuptool entry points的命名空间，CommandManager只会从这个命名空间中载入插件，convert_underscores参数指明是否需要把entry points中的下划线转为空格。</p>
</div>


<div class="alert info no-icon"><p>cliff.App类的方法initialize_app()，会在主程序解析完用户的命令行参数后被调用，而且只会被调用一次。<br>prepare_to_run_command()方法可以被用来做一些针对某个具体子命令的初始化工作，它将在该子命令执行之前被调用。<br>clean_up()方法会在具体某个子命令完成后被调用，用来进行一些清理工作。</p>
</div>

<p>具体某个子命令的实现通过继承cliff.command.Command来完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># simple.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> cliff.command <span class="keyword">import</span> Command</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span>(<span class="title class_ inherited__">Command</span>):</span><br><span class="line"></span><br><span class="line">    log = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">take_action</span>(<span class="params">self, parsed_args</span>):</span><br><span class="line">        self.log.info(<span class="string">&#x27;sending greeting&#x27;</span>)</span><br><span class="line">        self.log.debug(<span class="string">&#x27;debugging&#x27;</span>)</span><br><span class="line">        self.app.stdout.write(<span class="string">&#x27;Hello world \n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子命令的实际工作由take_action()来完成。这例子里，simple子命令向标准输出打印一个字符串，它的实现代码由cliff.commandmanager.CommandManager通过Setuptools entry points来载入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setup.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;cliffdemo&#x27;</span>,</span><br><span class="line">    version=<span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">    install_requires=[<span class="string">&#x27;cliff&#x27;</span>],</span><br><span class="line">    namespace_packages=[],</span><br><span class="line">    packages=find_packages(),</span><br><span class="line"></span><br><span class="line">    entry_points=&#123;</span><br><span class="line">        <span class="string">&#x27;console_scripts&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;cliffdemo = cliffdemo.main:main&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;cliff.cliffdemo&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;simple = cliffdemo.simple:Simple&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在Setuptools entry points的命名空间cliff.demo中，定义了命令simple所对应的插件实现是Simple类。Cliff主程序解析用户的输入后，会通过这里所定义的对应关系调用不同的实现类。</p>
<p>simple命令执行结果如下。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/cliff_result.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="images/cliff_result.png" alt=""></a></div>

<h1 id="oslo-config"><a href="#oslo-config" class="headerlink" title="oslo.config"></a>oslo.config</h1><p><a target="_blank" rel="noopener" href="https://github.com/openstack/oslo.config">oslo.config</a>用于解析命令行和配置文件中的配置项。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">service.py</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg</span><br><span class="line"></span><br><span class="line">opts = [</span><br><span class="line">    cfg.StrOpt(</span><br><span class="line">        <span class="string">&#x27;host&#x27;</span>,</span><br><span class="line">        default=<span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;host of node&#x27;</span></span><br><span class="line">    ),</span><br><span class="line">    cfg.IntOpt(</span><br><span class="line">        <span class="string">&#x27;collector_workers&#x27;</span>,</span><br><span class="line">        default=<span class="number">2</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;Number of workers for collector service.&#x27;</span></span><br><span class="line">    ),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册配置选项</span></span><br><span class="line">cfg.CONF.register_opts(opts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将配置选项注册为命令行选项</span></span><br><span class="line">cli_opts = [</span><br><span class="line">    cfg.StrOpt(</span><br><span class="line">        <span class="string">&#x27;os-tenant-id&#x27;</span>,</span><br><span class="line">        deprecated_group=<span class="string">&#x27;DEFAULT&#x27;</span>,</span><br><span class="line">        default=os.environ.get(<span class="string">&#x27;OS_TENANT_ID&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;Tenant ID to use for Openstack service access.&#x27;</span></span><br><span class="line">    ),</span><br><span class="line">    cfg.BoolOpt(</span><br><span class="line">        <span class="string">&#x27;insecure&#x27;</span>,</span><br><span class="line">        default=<span class="literal">False</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    ),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">cfg.CONF.register_cli_opts(cli_opts, group=<span class="string">&#x27;service_credentials&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置选项支持的类型"><a href="#配置选项支持的类型" class="headerlink" title="配置选项支持的类型"></a>配置选项支持的类型</h2><p>配置选项支持的类型如下。</p>
<table>
<thead>
<tr>
<th align="left">类名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">oslo_config.cfg.StrOpt</td>
<td align="left">字符串类型</td>
</tr>
<tr>
<td align="left">oslo_config.cfg.BoolOpt</td>
<td align="left">布尔型</td>
</tr>
<tr>
<td align="left">oslo_config.cfg.IntOpt</td>
<td align="left">整数类型</td>
</tr>
<tr>
<td align="left">oslo_config.cfg.FloatOpt</td>
<td align="left">浮点数类型</td>
</tr>
<tr>
<td align="left">oslo_config.cfg.ListOpt</td>
<td align="left">字符串列表类型</td>
</tr>
<tr>
<td align="left">oslo_config.cfg.DictOpt</td>
<td align="left">字典类型，字典中的值需要是字符串类型。</td>
</tr>
<tr>
<td align="left">oslo_config.cfg.MultiStrOpt</td>
<td align="left">可以分多次配置的字符串列表</td>
</tr>
<tr>
<td align="left">oslo_config.cfg.IPOpt</td>
<td align="left">IP地址类型</td>
</tr>
<tr>
<td align="left">oslo_config.cfg.HostnameOpt</td>
<td align="left">域名类型</td>
</tr>
<tr>
<td align="left">oslo_config.cfg.URIOpt</td>
<td align="left">URI类型</td>
</tr>
</tbody></table>
<div class="alert info no-icon"><p>定义后的配置项，必须要注册才能使用。<br>配置项还可以注册为命令行选项，之后，可以从命令行读取配置选项的值，并覆盖从配置文件中读取的值。<br>注册配置选项时，可以把某些配置选项注册在一个特定的组下。默认的组是“DEFAULT”。</p>
</div>

<h2 id="自定义配置选项类型"><a href="#自定义配置选项类型" class="headerlink" title="自定义配置选项类型"></a>自定义配置选项类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">PortType = types.Integer(<span class="number">1</span>, <span class="number">65535</span>)</span><br><span class="line"></span><br><span class="line">common_opts = [</span><br><span class="line">    cfg.Opt(</span><br><span class="line">        <span class="string">&#x27;bind_port&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=PortType(),</span><br><span class="line">        default=<span class="number">8080</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;Port number to listen on.&#x27;</span></span><br><span class="line">    )</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>相比于前面的方法，这种定义配置选项的方式能够更好地支持选项值得合法性检查，同时也能支持自定义选项类型。</p>
<h2 id="使用配置文件和命令行选项指定配置选项"><a href="#使用配置文件和命令行选项指定配置选项" class="headerlink" title="使用配置文件和命令行选项指定配置选项"></a>使用配置文件和命令行选项指定配置选项</h2><p>为了正确使用oslo.config，应用程序一般需要在启动的时候初始化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> olso_config <span class="keyword">import</span> cfg</span><br><span class="line"></span><br><span class="line">cfg.CONF(sys.argv[<span class="number">1</span>:], project=<span class="string">&#x27;xyz&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>初始化之后，才能正常解析配置文件和命令行选项。最终用户可以用默认的命令行选项“–config-file”或者“–config-dir”来指定配置文件名或者位置。如果没有明确指定，默认按照下面的顺序来寻找配置文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.xyz/xyz.conf ~/xyz.conf /etc/xyz/xyz.conf /etc/xyz.conf</span><br></pre></td></tr></table></figure>

<p>配置文件一般采用类似.ini文件的格式，其中每一个Section对应oslo.config中定义的一个配置选项组，Section[DEFAULT]对应了默认组“DEFAULT”。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[DEFULT]</span></span><br><span class="line"><span class="attr">host</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">collector_workers</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="section">[service_credentials]</span></span><br><span class="line"><span class="attr">insecure</span> = <span class="literal">True</span></span><br><span class="line"><span class="attr">os-tenant-id</span> = xyz123</span><br></pre></td></tr></table></figure>

<div class="alert info no-icon"><p>用命令行指定配置选项值时，如果是定义在某个选项组中的选项，命令行选项名中需要包括该组名作为前缀。</p>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--service_credentials-os-tenant-<span class="built_in">id</span> abc123</span><br></pre></td></tr></table></figure>

<h2 id="使用其他模块中已经注册过的配置选项"><a href="#使用其他模块中已经注册过的配置选项" class="headerlink" title="使用其他模块中已经注册过的配置选项"></a>使用其他模块中已经注册过的配置选项</h2><p>对于已经注册过的配置选项，开发者可以直接访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from oslo_config import cfg</span><br><span class="line"></span><br><span class="line">host = cfg.CONF.host</span><br><span class="line">tenant_id = cfg.CONF.service_credentials.os-tenant-id</span><br></pre></td></tr></table></figure>

<p>还可以使用import_opt来申明在别的模块中定义的配置选项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg</span><br><span class="line"></span><br><span class="line">cfg.CONF.import_opt(<span class="string">&#x27;host&#x27;</span>, <span class="string">&#x27;service&#x27;</span>)</span><br><span class="line">host = cfg.CONF.host</span><br></pre></td></tr></table></figure>

<h1 id="oslo-db"><a href="#oslo-db" class="headerlink" title="oslo.db"></a>oslo.db</h1><p><a target="_blank" rel="noopener" href="https://github.com/openstack/oslo.db">oslo.db</a>是针对SQLAlchemy访问的抽象。</p>
<h2 id="使用SQLAlchemy的session和connection"><a href="#使用SQLAlchemy的session和connection" class="headerlink" title="使用SQLAlchemy的session和connection"></a>使用SQLAlchemy的session和connection</h2><p>oslo.db提供了oslo_db.sqlachemy.enginefacade模块来获取session和connection，有两种方法来使用enginefacade，即函数装饰器（decorator）和上下文管理器（context mangager）。这两种调用方式都需要提供一个上下文对象。上下文对象可以是任何Python类。这样做的目的是提供一个统一规范的session使用模式，避免调用者使用不当造成数据库事务（transaction）的滥用和嵌套。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> oslo_db.sqlalchemy <span class="keyword">import</span> enginefacade</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContext</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="string">&#x27;User-defined context class&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="keyword">with</span> enginefacade.reader.using(context) <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">return</span> session.query(SomeClass).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">context, x, y</span>):</span><br><span class="line">    <span class="keyword">with</span> enginefacade.writer.using(context) <span class="keyword">as</span> session:</span><br><span class="line">        session.add(SomeClass(x, y))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    context = MyContext()</span><br><span class="line">    results = read(context)</span><br><span class="line">    write(context, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>当使用装饰器模式的时候需要对context对象做特殊处理，调用transaction_context_provider装饰context对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> oslo_db.sqlalchemy <span class="keyword">import</span> enginefacade</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@enginefacade.transaction_context_provider</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContext</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="string">&#x27;User-defined context class&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@enginefacade.reader</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="keyword">return</span> context.session.query(SomeClass).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@enginefacade.writer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">context, x, y</span>):</span><br><span class="line">    context.session.add(SomeClass(x, y))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    context = MyContext()</span><br><span class="line">    results = read(context)</span><br><span class="line">    write(context, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>管理员可以通过配置文件来配置oslo.db的许多选项，比如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[database]</span></span><br><span class="line"><span class="attr">connection</span> = mysql://root:root@localhost/ceilometer?charset=utf8</span><br></pre></td></tr></table></figure>
<div class="alert info no-icon"><p>用户可以在使用数据库之前调用oslo_db.sqlalchemy.enginefacade.configure()方法来改变已有的配置。</p>
</div>

<p>常用配置选项。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/oslo_db.png" title="常用配置选项" data-caption="常用配置选项" data-fancybox="default"><img class="fig-img" src="images/oslo_db.png" alt="常用配置选项"></a><span class="caption">常用配置选项</span></div>
<br>

<h2 id="使用通用的SQLAlchemy-model类"><a href="#使用通用的SQLAlchemy-model类" class="headerlink" title="使用通用的SQLAlchemy model类"></a>使用通用的SQLAlchemy model类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> oslo_db.sqlalchemy.models <span class="keyword">import</span> TimestampMixin, ModelBase</span><br><span class="line"><span class="keyword">from</span> oslo_db.sqlalchemy.models <span class="keyword">import</span> types</span><br><span class="line"><span class="keyword">from</span> oslo_db.sqlalchemy.models <span class="keyword">import</span> Column</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Project</span>(TimestampMixin, ModelBase):</span><br><span class="line">    <span class="built_in">id</span> = Column(types.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(types.String)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>oslol_db.sqlalchemy.models定义了两种Mixin：TimestampMixin和SoftDeleteMixin。使用TimestampMixin时SQLAlchemy model中会多出两列create_at和update_at，分别表示记录的创建时间和上一次修改时间。</p>
<p>SoftDeleteMixin支持使用soft delete功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> oslo_db.sqlalchemy.models <span class="keyword">import</span> ModelBase, SoftDeleteMixin</span><br><span class="line"><span class="keyword">from</span> oslo_db.sqlalchemy.models <span class="keyword">import</span> types</span><br><span class="line"><span class="keyword">from</span> oslo_db.sqlalchemy.models <span class="keyword">import</span> Column</span><br><span class="line"><span class="keyword">from</span> oslo_db.sqlalchemy.utils <span class="keyword">import</span> model_query</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(SoftDeleteMixin, ModelBase):</span><br><span class="line">    <span class="built_in">id</span> = Column(types.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(types.String)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">count = model_query(Bar).find(<span class="built_in">id</span>=<span class="number">1</span>).soft_delete()</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;0 entries were soft deleted&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="不同DB后端的支持"><a href="#不同DB后端的支持" class="headerlink" title="不同DB后端的支持"></a>不同DB后端的支持</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">from</span> oslo_db <span class="keyword">import</span> api <span class="keyword">as</span> db_api</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义不同backend所对应的实现，如果配置选项conf.database.backend的值为sqlalchemy，</span></span><br><span class="line"><span class="comment"># 就用project.db.sqlalchemy.api模块中的实现。</span></span><br><span class="line"></span><br><span class="line">_BACKEND_MAPPING = &#123;</span><br><span class="line">    <span class="string">&#x27;sqlalchemy&#x27;</span>: <span class="string">&#x27;project.db.sqlalchemy.api&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IMPL = db_api.DBAPI.from_config(cfg.CONF,</span><br><span class="line">                                backend_mapping=_BACKEND_MAPPING)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_engine</span>():</span><br><span class="line">    <span class="keyword">return</span> IMPL.get_engine()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_session</span>():</span><br><span class="line">    <span class="keyword">return</span> IMPL.get_session()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># DB-API method</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">return</span> IMPL.do_something(<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure>


<p>不同backend具体实现时，需要定义如下函数返回具体DB API的实现类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_backend</span>():</span><br><span class="line">    <span class="keyword">return</span> MyImplementationClass</span><br></pre></td></tr></table></figure>

<h1 id="oslo-messaging"><a href="#oslo-messaging" class="headerlink" title="oslo.messaging"></a>oslo.messaging</h1><p><a target="_blank" rel="noopener" href="https://github.com/openstack/oslo.messaging">oslo.messaging</a>库为OpenStack各个项目使用RPC和事件通知（Event Notification）提供了一套统一的接口。</p>
<p>为了支持不同的RPC后端实现，oslo.messaging对如下的对象进行统一。</p>
<h2 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h2><p>Transport主要实现RPC底层的通信（如Socket）以及时间循环、多线程等其他功能。用户可以通过URL来获得指向不同transport实现的句柄。URL格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transport://user:pass@host1:port[,hostN:portN]/virtual_host</span><br></pre></td></tr></table></figure>
<p>目前支持的Transport有rabbit、qpid与zmq，分别对应不同的后端消息总线。用户可以使用oslo.messaging.get_transport函数来获得transport对象实例的句柄。</p>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Target封装了指定一个消息最终目的地的所有信息。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/oslo.messaging_Target.png" title="Target 参数" data-caption="Target 参数" data-fancybox="default"><img class="fig-img" src="images/oslo.messaging_Target.png" alt="Target 参数"></a><span class="caption">Target 参数</span></div>

<div class="alert info no-icon"><p>在不同的应用场景下，构造Target对象需要不同的参数：<br>创建一个RPC服务器时，需要topic和server参数，exchange参数可选；<br>指定一个endpoint的target时，namespace和version是可选的；<br>客户端发送消息时，需要topic参数，其他可选。</p>
</div>

<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>一个RPC服务器可以暴露多个endpoint，每个endpoint包含一组方法，这组方法可以被客户端通过某种Transport对象远程调用。创建Server对象时，需要指定Transport、Target和一组endpoint。</p>
<h2 id="RPC-Client"><a href="#RPC-Client" class="headerlink" title="RPC Client"></a>RPC Client</h2><p>通过RPC Client，可以远程调用RPC Server上的方法。远程调用时，需要提供一个字典对象来指明调用的上下文，调用方法的名字和传递给调用方法的参数（用字典表示）。</p>
<div class="alert info no-icon"><p>有cast和call两种远程调用方式。<br>通过cast方式调用，请求发送后就直接返回。<br>通过call方式调用，需要等待响应从服务器返回。</p>
</div>

<h2 id="Notifier"><a href="#Notifier" class="headerlink" title="Notifier"></a>Notifier</h2><p>Notifier用来通过Transport发送通知消息。通知消息遵循如下的格式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="string">&#x27;message_id&#x27;</span>: six.text_type(uuid.uuid4()), <span class="comment"># 消息id</span></span><br><span class="line">    <span class="string">&#x27;publisher_id&#x27;</span>: <span class="string">&#x27;compute.host1&#x27;</span>            <span class="comment"># 发送者id</span></span><br><span class="line">    <span class="string">&#x27;timestamp&#x27;</span>: timeutils.utcnow(),           <span class="comment"># 时间戳</span></span><br><span class="line">    <span class="string">&#x27;priority&#x27;</span>: <span class="string">&#x27;WARN&#x27;</span>,                        <span class="comment"># 通知优先级</span></span><br><span class="line">    <span class="string">&#x27;event_type&#x27;</span>: <span class="string">&#x27;compute.create_instance&#x27;</span>,   <span class="comment"># 通知类型</span></span><br><span class="line">    <span class="string">&#x27;payload&#x27;</span>: &#123;<span class="string">&#x27;instance_id&#x27;</span>: <span class="string">&#x27;123&#x27;</span>&#125;          <span class="comment"># 通知内容    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="alert info no-icon"><p>用户可以在不同的优先级上发送通知，包括sample、critical、error、warn、info、debug和audit等。</p>
</div>

<h2 id="Notification-Listener"><a href="#Notification-Listener" class="headerlink" title="Notification Listener"></a>Notification Listener</h2><p>Notification Listener和Server类似，一个Notification Listener对象可以暴露多个endpoint，每个endpoint包含一组方法。但是与Server对象中的endpoint不同的是，这里的endpoint中的方法对应通知消息的不同优先级。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> oslo <span class="keyword">import</span> messaging</span><br><span class="line"></span><br><span class="line">Class ErrorEndpoint(<span class="built_in">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">error</span>(<span class="params">self, ctxt, pulisher_id, event_type, payload, metadata</span>):</span><br><span class="line">        do_something(payload)</span><br><span class="line">        <span class="keyword">return</span> messaging.NotificationResult.HANDLED</span><br></pre></td></tr></table></figure>

<div class="alert info no-icon"><p>endpoint中的方法如果返回messaging.NotificationResult.HANDLED或者None，表示这个通知消息已经被处理；<br>如果返回messaging.NotificationResult.REQUEUE，表示这个通知消息要重新进入消息队列。</p>
</div>

<h2 id="利用oslo-messaging来实现远程过程调用"><a href="#利用oslo-messaging来实现远程过程调用" class="headerlink" title="利用oslo.messaging来实现远程过程调用"></a>利用oslo.messaging来实现远程过程调用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server.py 服务器端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">import</span> oslo_messaging <span class="keyword">as</span> messaging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerControllerEndpoint</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    target = messaging.Target(</span><br><span class="line">        namespace=<span class="string">&#x27;control&#x27;</span>,</span><br><span class="line">        version=<span class="string">&#x27;2.0&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, server</span>):</span><br><span class="line">        self.server = server</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self, context</span>):</span><br><span class="line">        <span class="keyword">if</span> self.server:</span><br><span class="line">            self.server.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestEndpoint</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self, context, arg</span>):</span><br><span class="line">        <span class="built_in">print</span> arg</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transport = messaging.get_transport(cfg.CONF)</span><br><span class="line">target = messaging.Target(topic=<span class="string">&#x27;test&#x27;</span>, server=<span class="string">&#x27;server-1&#x27;</span>)</span><br><span class="line">endpoints = [</span><br><span class="line">    ServerControllerEndpoint(<span class="literal">None</span>),</span><br><span class="line">    TestEndpoint()</span><br><span class="line">]</span><br><span class="line">server = messaging.get_rpc_server(</span><br><span class="line">    transport=transport,</span><br><span class="line">    target=target,</span><br><span class="line">    endpoints=endpoints,</span><br><span class="line">    executor=<span class="string">&#x27;blocking&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    server.start()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Stop server.&#x27;</span></span><br><span class="line"></span><br><span class="line">server.wait()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面定义了两个endpoint：ServerControlEndpoint与TestEndpoint。这两个endpoint中的方法stop()和test()都可以被客户端远程调用。</p>
<p>创建rpc server对象之前，先创建transport和target对象，这里使用get_transport()函数来获得transport对象的句柄。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/oslo.messaging_get_transport.png" title="get_transport 参数" data-caption="get_transport 参数" data-fancybox="default"><img class="fig-img" src="images/oslo.messaging_get_transport.png" alt="get_transport 参数"></a><span class="caption">get_transport 参数</span></div>


<p>conf对象里，除了包含transport_url项外，还可以包含control_exchange项。control_exchange用来指明topic所属的默认范围，默认值为“openstack”。用户可以使用oslo.messaging.set_transport_defaults()函数来修改默认值。</p>
<p>此处构建的Target对象是用来建立RPC server的，所以需要指明topic和server参数。用户定义的endpoint对象也可以包含一个target属性，用来指明这个endpoint所支持的特定的namespace和version。</p>
<p>这里使用get_rpc_server()函数创建server对象，然后调用server对象的start()方法开始接收远程调用。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/oslo.messaging_get_rpc_server.png" title="get_rpc_server 参数" data-caption="get_rpc_server 参数" data-fancybox="default"><img class="fig-img" src="images/oslo.messaging_get_rpc_server.png" alt="get_rpc_server 参数"></a><span class="caption">get_rpc_server 参数</span></div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client.py 客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">import</span> oslo_messaging <span class="keyword">as</span> messaging</span><br><span class="line"></span><br><span class="line">transport = messaging.get_transport(cfg.CONF)</span><br><span class="line">target = messaging.Target(topic=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">client = messaging.RPCClient(</span><br><span class="line">    transport=transport,</span><br><span class="line">    target=target</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ret = client.call(</span><br><span class="line">    ctxt=&#123;&#125;,</span><br><span class="line">    method=<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    arg=&#123;<span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Hello world&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">cctxt = client.prepare(</span><br><span class="line">    namespace=<span class="string">&#x27;control&#x27;</span>,</span><br><span class="line">    version=<span class="string">&#x27;2.0&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cctxt.cast(&#123;&#125;, <span class="string">&#x27;stop&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里target对象构造时，必要的参数只有topic，创建RPCClient对象时，可以接收的参数如下。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/oslo.messaging_RPCClient.png" title="RPCClient 参数" data-caption="RPCClient 参数" data-fancybox="default"><img class="fig-img" src="images/oslo.messaging_RPCClient.png" alt="RPCClient 参数"></a><span class="caption">RPCClient 参数</span></div>

<p>远程调用时，需要传入调用上下文、调用方法的名字和传给调用方法的参数。</p>
<p>Target对象的属性在RPCClient对象构造以后，还可以通过prepare()方法修改。用户可以修改的属性包括exchange、topic、namespace、version、server、fanout、timeout、version_cap和retry。修改后target属性只在prepare()方法返回的对象中有效。</p>
<h2 id="利用oslo-messaging实现通知消息处理"><a href="#利用oslo-messaging实现通知消息处理" class="headerlink" title="利用oslo.messaging实现通知消息处理"></a>利用oslo.messaging实现通知消息处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># notification_listener.py 消息通知处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">import</span> oslo_messaging <span class="keyword">as</span> messaging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotificationEndpoint</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    filter_rule = messaging.NotificationFilter(</span><br><span class="line">        publisher_id=<span class="string">&#x27;^compute.*&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">warn</span>(<span class="params">self, context, publisher_id, event_type, payload, metadata</span>):</span><br><span class="line">        <span class="built_in">print</span> context, publisher_id, event_type, payload, metadata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorEndpoint</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    filter_rule = messaging.NotificationFilter(</span><br><span class="line">        publisher_id=<span class="string">&#x27;^instance\..*\.start$&#x27;</span>,</span><br><span class="line">        context=&#123;<span class="string">&#x27;ctxt_key&#x27;</span>: <span class="string">&#x27;regexp&#x27;</span>&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">error</span>(<span class="params">self, context, publisher_id, event_type, payload, metadata</span>):</span><br><span class="line">        <span class="built_in">print</span> context, publisher_id, event_type, payload, metadata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transport = messaging.get_transport(cfg.CONF)</span><br><span class="line">targets = [</span><br><span class="line">    messaging.Target(topic=<span class="string">&#x27;notifications&#x27;</span>),</span><br><span class="line">    messaging.Target(topic=<span class="string">&#x27;notifications_test&#x27;</span>)</span><br><span class="line">]</span><br><span class="line">endpoints = [</span><br><span class="line">    NotificationEndpoint(),</span><br><span class="line">    ErrorEndpoint()</span><br><span class="line">]</span><br><span class="line">pool = <span class="string">&#x27;listener-workers&#x27;</span></span><br><span class="line">listener = messaging.get_notification_listener(</span><br><span class="line">    transport=transport,</span><br><span class="line">    targets=targets,</span><br><span class="line">    endpoints=endpoints,</span><br><span class="line">    pool=pool</span><br><span class="line">)</span><br><span class="line">listener.start()</span><br><span class="line">listener.wait()</span><br></pre></td></tr></table></figure>

<p>通知消息处理的endpoint对象和远程过程调用的endpoint对象不同，对象定义的方法需要和通知消息的优先级一一对应。我们可以为不同的endpoint对象指定所对应的target对象。</p>
<p>最后调用get_notification_listener()函数构造notification listener对象。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/oslo.messaging_get_notification_listener.png" title="get_notification_listener 参数" data-caption="get_notification_listener 参数" data-fancybox="default"><img class="fig-img" src="images/oslo.messaging_get_notification_listener.png" alt="get_notification_listener 参数"></a><span class="caption">get_notification_listener 参数</span></div>

<p>相对应的发送消息通知的代码如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># notifier_send.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">import</span> oslo_messaging <span class="keyword">as</span> messaging</span><br><span class="line"></span><br><span class="line">transport = messaging.get_transport(cfg.CONF)</span><br><span class="line">notifier = messaging.Notifier(</span><br><span class="line">    transport=transport,</span><br><span class="line">    driver=<span class="string">&#x27;messaging&#x27;</span>,</span><br><span class="line">    topics=[<span class="string">&#x27;notifications&#x27;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">notifier_2 = notifier.prepare(publisher_id=<span class="string">&#x27;compute&#x27;</span>)</span><br><span class="line">notifier_2.error(</span><br><span class="line">    ctxt=&#123;&#125;,</span><br><span class="line">    event_type=<span class="string">&#x27;my_type&#x27;</span>,</span><br><span class="line">    payload=&#123;<span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;Hello world&#x27;</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发送消息时，首先要构造Notifier对象。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/oslo.messaging_Notifier.png" title="Notifier 参数" data-caption="Notifier 参数" data-fancybox="default"><img class="fig-img" src="images/oslo.messaging_Notifier.png" alt="Notifier 参数"></a><span class="caption">Notifier 参数</span></div>


<p>初始化Notifier对象的操作比较复杂，所以可以用prepare()方法修改已经创建的Notifier对象，prepare()方法返回的是新的Notifier对象的实例。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/oslo.messaging_prepare.png" title="prepare 参数" data-caption="prepare 参数" data-fancybox="default"><img class="fig-img" src="images/oslo.messaging_prepare.png" alt="prepare 参数"></a><span class="caption">prepare 参数</span></div>

<p>最后可以调用Notifier对象的不同方法（error、warn、info等）发送不同优先级的消息通知。</p>
<h1 id="stevedore"><a href="#stevedore" class="headerlink" title="stevedore"></a>stevedore</h1><p>利用Python语言的特性，运行时动态载入代码变得更加容易。很多Python应用程序利用这样的特性在运行时发现和载入所谓的“插件”（plugin），使得自己更易于扩展。Python库<a target="_blank" rel="noopener" href="https://github.com/openstack/stevedore">stevedore</a>就是在Setuptools的entry points基础上，构造了一层抽象层，使开发者可以更容易地在运行时发现和载入插件。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>entry points的每一个命名空间里，可以包含多个entry point项。stevedore要求每一项都符合如下格式：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span> = module:importable</span><br></pre></td></tr></table></figure>

<div class="alert info no-icon"><p>左边是插件的名字，右边是它的具体实现，中间用等号分隔开。插件的具体实现用“模块:可导入的对象”的形式来指定。</p>
</div>

<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ceilometer.compute.virt</span> =</span><br><span class="line">    <span class="attr">libvirt</span> = ceilometer.compute.virt.libvirt.inspector:LibvirtInspector</span><br><span class="line">    <span class="attr">hyperv</span> = ceilometer.compute.virt.hyperv.inspector:HyperVInspector</span><br><span class="line">    <span class="attr">vsphere</span> = ceilometer.compute.virt.vmware.inspector:VsphereInspector</span><br><span class="line">    <span class="attr">xenapi</span> = ceilometer.compute.virt.xenapi.inspector:XenapiInspector</span><br><span class="line"></span><br><span class="line"><span class="attr">ceilometer.hardware.inspectors</span> =</span><br><span class="line">    <span class="attr">snmp</span> = ceilometer.hardware.inspector.snmp:SNMPInspector</span><br></pre></td></tr></table></figure>

<p>示例中显示了两个不同的entry points的命名空间，”ceilometer.compute.virt“和”ceilometer.hardware.inspectors“，分别注册了4个和1个插件。</p>
<p>根据每个插件在entry point中名字和具体实现的数量之间的对应关系不同，stevedore提供了多种不同的类来帮助开发者发现和载入插件。</p>
<table>
<thead>
<tr>
<th align="left">插件名称: 具体实现</th>
<th align="left">建议选用stevedore中的类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1: 1</td>
<td align="left">stevedore.driver.DriverManager</td>
</tr>
<tr>
<td align="left">1: n</td>
<td align="left">stevedore.hook.HookManager</td>
</tr>
<tr>
<td align="left">m: n</td>
<td align="left">stevedore.extension.ExtensionManager</td>
</tr>
</tbody></table>
<p>使用stevedore来帮助程序动态载入插件的过程主要分为3个部分：插件的实现、插件的注册和插件的载入。</p>
<h2 id="插件的实现"><a href="#插件的实现" class="headerlink" title="插件的实现"></a>插件的实现</h2><p>Ceilometer的inspector驱动，为不从不同类型hypervisor中获取相关数据提供统一的接口以供compute agent使用。下面是它的基类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ceilometer/compute/virt/inspector.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inspector</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, conf</span>):</span><br><span class="line">        self.conf = conf</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inspect_instance</span>(<span class="params">self, instance, duration</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Inspect the CPU statistics for an instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param instance: the target instance</span></span><br><span class="line"><span class="string">        :param duration: the last &#x27;n&#x27; seconds, over which the value should be</span></span><br><span class="line"><span class="string">               inspected</span></span><br><span class="line"><span class="string">        :return: the instance stats</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> ceilometer.NotImplementedError</span><br></pre></td></tr></table></figure>

<p>ceilometer/compute/virt/hyperv/inspector.py，ceilometer/compute/virt/libvirt/inspector.py，ceilometer/compute/virt/vmware/inspector.py和ceilometer/compute/virt/xenapi/inspector.py分别为hyperv、kvm、vsphere和xenapi4种不同hypervisor的具体实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> ceilometer.compute.virt <span class="keyword">import</span> inspector <span class="keyword">as</span> virt_inspector</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LibvirtInspector</span>(virt_inspector.Inspector):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, conf</span>):</span><br><span class="line">        <span class="built_in">super</span>(LibvirtInspector, self).__init__(conf)</span><br><span class="line">        <span class="comment"># NOTE(sileht): create a connection on startup</span></span><br><span class="line">        self.connection</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connection</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> libvirt_utils.refresh_libvirt_connection(self.conf, self)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @libvirt_utils.raise_nodata_if_unsupported</span></span><br><span class="line"><span class="meta">    @libvirt_utils.retry_on_disconnect</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inspect_instance</span>(<span class="params">self, instance, duration=<span class="literal">None</span></span>):</span><br><span class="line">        domain = self._get_domain_not_shut_off_or_raise(instance)</span><br><span class="line"></span><br><span class="line">        memory_used = memory_resident = <span class="literal">None</span></span><br><span class="line">        memory_swap_in = memory_swap_out = <span class="literal">None</span></span><br><span class="line">        memory_stats = domain.memoryStats()</span><br><span class="line">        <span class="comment"># Stat provided from libvirt is in KB, converting it to MB.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;available&#x27;</span> <span class="keyword">in</span> memory_stats <span class="keyword">and</span> <span class="string">&#x27;unused&#x27;</span> <span class="keyword">in</span> memory_stats:</span><br><span class="line">            memory_used = (memory_stats[<span class="string">&#x27;available&#x27;</span>] -</span><br><span class="line">                           memory_stats[<span class="string">&#x27;unused&#x27;</span>]) / units.Ki</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;rss&#x27;</span> <span class="keyword">in</span> memory_stats:</span><br><span class="line">            memory_resident = memory_stats[<span class="string">&#x27;rss&#x27;</span>] / units.Ki</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;swap_in&#x27;</span> <span class="keyword">in</span> memory_stats <span class="keyword">and</span> <span class="string">&#x27;swap_out&#x27;</span> <span class="keyword">in</span> memory_stats:</span><br><span class="line">            memory_swap_in = memory_stats[<span class="string">&#x27;swap_in&#x27;</span>] / units.Ki</span><br><span class="line">            memory_swap_out = memory_stats[<span class="string">&#x27;swap_out&#x27;</span>] / units.Ki</span><br><span class="line"></span><br><span class="line">        <span class="comment"># TODO(sileht): stats also have the disk/vnic info</span></span><br><span class="line">        <span class="comment"># we could use that instead of the old method for Queen</span></span><br><span class="line">        stats = self.connection.domainListGetStats([domain], <span class="number">0</span>)[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        cpu_time = <span class="number">0</span></span><br><span class="line">        current_cpus = stats.get(<span class="string">&#x27;vcpu.current&#x27;</span>)</span><br><span class="line">        <span class="comment"># Iterate over the maximum number of CPUs here, and count the</span></span><br><span class="line">        <span class="comment"># actual number encountered, since the vcpu.x structure can</span></span><br><span class="line">        <span class="comment"># have holes according to</span></span><br><span class="line">        <span class="comment"># https://libvirt.org/git/?p=libvirt.git;a=blob;f=src/libvirt-domain.c</span></span><br><span class="line">        <span class="comment"># virConnectGetAllDomainStats()</span></span><br><span class="line">        <span class="keyword">for</span> vcpu <span class="keyword">in</span> six.moves.<span class="built_in">range</span>(stats.get(<span class="string">&#x27;vcpu.maximum&#x27;</span>, <span class="number">0</span>)):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cpu_time += (stats.get(<span class="string">&#x27;vcpu.%s.time&#x27;</span> % vcpu) +</span><br><span class="line">                             stats.get(<span class="string">&#x27;vcpu.%s.wait&#x27;</span> % vcpu))</span><br><span class="line">                current_cpus -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span> TypeError:</span><br><span class="line">                <span class="comment"># pass here, if there are too many holes, the cpu count will</span></span><br><span class="line">                <span class="comment"># not match, so don&#x27;t need special error handling.</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_cpus:</span><br><span class="line">            <span class="comment"># There wasn&#x27;t enough data, so fall back</span></span><br><span class="line">            cpu_time = stats.get(<span class="string">&#x27;cpu.time&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> virt_inspector.InstanceStats(</span><br><span class="line">            cpu_number=stats.get(<span class="string">&#x27;vcpu.current&#x27;</span>),</span><br><span class="line">            cpu_time=cpu_time,</span><br><span class="line">            memory_usage=memory_used,</span><br><span class="line">            memory_resident=memory_resident,</span><br><span class="line">            memory_swap_in=memory_swap_in,</span><br><span class="line">            memory_swap_out=memory_swap_out,</span><br><span class="line">            cpu_cycles=stats.get(<span class="string">&quot;perf.cpu_cycles&quot;</span>),</span><br><span class="line">            instructions=stats.get(<span class="string">&quot;perf.instructions&quot;</span>),</span><br><span class="line">            cache_references=stats.get(<span class="string">&quot;perf.cache_references&quot;</span>),</span><br><span class="line">            cache_misses=stats.get(<span class="string">&quot;perf.cache_misses&quot;</span>),</span><br><span class="line">            memory_bandwidth_total=stats.get(<span class="string">&quot;perf.mbmt&quot;</span>),</span><br><span class="line">            memory_bandwidth_local=stats.get(<span class="string">&quot;perf.mbml&quot;</span>),</span><br><span class="line">            cpu_l3_cache_usage=stats.get(<span class="string">&quot;perf.cmt&quot;</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="插件的注册"><a href="#插件的注册" class="headerlink" title="插件的注册"></a>插件的注册</h2><p>上述的插件需要在Setuptools的相关文件中注册后，才能被stevedore库所认识。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setup.cfg</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ceilometer.compute.virt</span> =</span><br><span class="line">    <span class="attr">libvirt</span> = ceilometer.compute.virt.libvirt.inspector:LibvirtInspector</span><br><span class="line">    <span class="attr">hyperv</span> = ceilometer.compute.virt.hyperv.inspector:HyperVInspector</span><br><span class="line">    <span class="attr">vsphere</span> = ceilometer.compute.virt.vmware.inspector:VsphereInspector</span><br><span class="line">    <span class="attr">xenapi</span> = ceilometer.compute.virt.xenapi.inspector:XenapiInspector</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="插件的载入"><a href="#插件的载入" class="headerlink" title="插件的载入"></a>插件的载入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ceilometer/compute/virt/inspector.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_hypervisor_inspector</span>(<span class="params">conf</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        namespace = <span class="string">&#x27;ceilometer.compute.virt&#x27;</span></span><br><span class="line">        mgr = driver.DriverManager(namespace,</span><br><span class="line">                                   conf.hypervisor_inspector,</span><br><span class="line">                                   invoke_on_load=<span class="literal">True</span>,</span><br><span class="line">                                   invoke_args=(conf, ))</span><br><span class="line">        <span class="keyword">return</span> mgr.driver</span><br><span class="line">    <span class="keyword">except</span> ImportError <span class="keyword">as</span> e:</span><br><span class="line">        LOG.error(<span class="string">&quot;Unable to load the hypervisor inspector: %s&quot;</span> % e)</span><br><span class="line">        <span class="keyword">return</span> Inspector(conf)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Ceilometer的compute agent通过调用函数get_hypervisor_inspector来载入具体的某一个插件。此处由于插件和具体实现之间是一对一的关系，所以选用了stevedore的DriverManager类。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/stevedore_DriverManager.png" title="DriverManager 参数" data-caption="DriverManager 参数" data-fancybox="default"><img class="fig-img" src="images/stevedore_DriverManager.png" alt="DriverManager 参数"></a><span class="caption">DriverManager 参数</span></div>

<h1 id="taskflow"><a href="#taskflow" class="headerlink" title="taskflow"></a>taskflow</h1><p>通过<a target="_blank" rel="noopener" href="https://github.com/openstack/taskflow">TaskFlow</a>库，可以更容易地控制任务（Task）的执行。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> engines</span><br><span class="line"><span class="keyword">from</span> taskflow.patterns <span class="keyword">import</span> linear_flow <span class="keyword">as</span> lf</span><br><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallJim</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, jim_number, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Calling Jim %s.&#x27;</span> % jim_number</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">revert</span>(<span class="params">self, jim_number, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Calling %s and apologizing.&#x27;</span> % jim_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallJoe</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, joe_number, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Calling Joe %s.&#x27;</span> % joe_number</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">revert</span>(<span class="params">self, joe_number, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Calling %s and apologizing.&#x27;</span> % joe_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallHY</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, hy_number, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">raise</span> IOError(<span class="string">&#x27;HY not at home right now.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flow = lf.Flow(<span class="string">&#x27;simple-linear&#x27;</span>).add(</span><br><span class="line">    CallJim(),</span><br><span class="line">    CallJoe(),</span><br><span class="line">    CallHY()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    engines.run(</span><br><span class="line">        flow=flow,</span><br><span class="line">        engine_conf=&#123;<span class="string">&#x27;engine&#x27;</span>: <span class="string">&#x27;serial&#x27;</span>&#125;,</span><br><span class="line">        store=<span class="built_in">dict</span>(jim_number=<span class="number">444</span>,</span><br><span class="line">                   joe_number=<span class="number">555</span>,</span><br><span class="line">                   hy_number=<span class="number">666</span>)</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Flow failed: %s&#x27;</span> % e</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><p>这个示例首先定义了三个task：CallJim、CallJoe和CallHY。在TaskFlow库中，task是拥有执行（execute）和回滚（revert）功能的最小单位（TaskFlow中最小的单位是atom，其他所有类包括Task都是Atom类的子类）。在Task类中，允许开发者定义自己的execute函数和revert函数，分别用来执行task和回退task到之前一次的执行结果。</p>
<p>然后新新建一个线性流flow，并在其中顺序加入上述3个task对象。TaskFlow中的流flow用来关联各个task，并且规范这些task之间的执行和回滚顺序。</p>
<p>TaskFlow中所支持的流类型。</p>
<table>
<thead>
<tr>
<th align="left">流类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">linear_flow.Flow</td>
<td align="left">线性流，流中的task/flow按加入顺序执行，按加入顺序的倒序回滚。</td>
</tr>
<tr>
<td align="left">unordered_flow.Flow</td>
<td align="left">无顺序流，流中的task/flow的执行和回滚可以按任意顺序。</td>
</tr>
<tr>
<td align="left">graph_flow.Flow</td>
<td align="left">图流，流中的task/flow按照显式指定的依赖关系，或者通过其间provides和requires属性之间的隐含依赖关系，来执行或回滚。</td>
</tr>
</tbody></table>
<p>这个示例中，由于采用的是线性流，所以这个流中task的执行顺序为：CallJim -&gt; CallJoe -&gt; CallHY，回滚顺序是其倒序。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/task_result.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="images/task_result.png" alt=""></a></div>

<h2 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h2><p>流中不仅可以加入任务，还可以嵌套加入其他的流。此外，流还可以通过retry来控制当错误发生时，该如何重试。</p>
<p>TaskFlow支持的retry类型。</p>
<table>
<thead>
<tr>
<th align="left">Retry类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AlwaysRevert</td>
<td align="left">错误发生时，回滚子流。</td>
</tr>
<tr>
<td align="left">AlwaysRevertAll</td>
<td align="left">错误发生时，回滚所有子流。</td>
</tr>
<tr>
<td align="left">Times</td>
<td align="left">错误发生时，重试子流。</td>
</tr>
<tr>
<td align="left">ForEach</td>
<td align="left">每次错误发生时，为子流中的atom提供一个新的值，然后重试，直到成功或者此retry中定义的值用光为止。</td>
</tr>
<tr>
<td align="left">ParameterizedForEach</td>
<td align="left">类似ForEach，但是是从后台存储中获取重试的值</td>
</tr>
</tbody></table>
<p>示例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoTask</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, name, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;my name is %s&#x27;</span> % name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">revert</span>(<span class="params">self, name, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;sorry, my name is %s&#x27;</span> % name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flow = lf.Flow(<span class="string">&#x27;f1&#x27;</span>).add(</span><br><span class="line">    EchoTask(<span class="string">&#x27;t1&#x27;</span>),</span><br><span class="line">    lf.Flow(</span><br><span class="line">        <span class="string">&#x27;f2&#x27;</span>,</span><br><span class="line">        retry=retry.ForEach(</span><br><span class="line">            values=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">            name=<span class="string">&#x27;r1&#x27;</span>,</span><br><span class="line">            provides=<span class="string">&#x27;value&#x27;</span></span><br><span class="line">        )</span><br><span class="line">    ).add(</span><br><span class="line">        EchoTask(<span class="string">&#x27;t2&#x27;</span>),</span><br><span class="line">        EchoTask(<span class="string">&#x27;t3&#x27;</span>, requires=<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    ),</span><br><span class="line">    EchoTask(<span class="string">&#x27;t4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的示例，构造了一个线性流f1，它按顺序执行任务t1、子线性流f2、和任务t4。子流f2按序执行任务t2和t3。</p>
<p>子流f2定义了ForEach类型的retry“r1”。当任务t2或者t3失败时，子流t2首先会回滚。然后“r1”会指导子流f2使用值“a”来重新运行。如果再次失败，子流f2回滚后会再次使用“b”运行；仍然失败后回滚使用值“c”运行。如果值“c”也运行失败，由于“r1”中能够提供的值已经被完全用完，子流f2回滚后不会重新运行。</p>
<h2 id="engine"><a href="#engine" class="headerlink" title="engine"></a>engine</h2><p>TaskFlow库中的engine用来载入一个flow，然后驱动flow中的task/flow运行。可以通过engine_conf来指明不同的engine类型。</p>
<table>
<thead>
<tr>
<th align="left">engine类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘serial’</td>
<td align="left">所有的task都在调用engine.run的那个线程中运行。</td>
</tr>
<tr>
<td align="left">‘parallel’</td>
<td align="left">task可能会被调度到不同的线程中并发运行。</td>
</tr>
<tr>
<td align="left">‘worker-based’</td>
<td align="left">task会被调度到不同的worker中运行。<br>一个worker是一个单独的专门用来运行某些特定task的进程，<br>这个worker进程可以在远程机器上，利用AMQP来通信。</td>
</tr>
</tbody></table>
<h2 id="task和flow的输入-输出"><a href="#task和flow的输入-输出" class="headerlink" title="task和flow的输入/输出"></a>task和flow的输入/输出</h2><p>示例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> taskflow.patterns <span class="keyword">import</span> graph_flow <span class="keyword">as</span> gf</span><br><span class="line"><span class="keyword">from</span> taskflow.patterns <span class="keyword">import</span> linear_flow <span class="keyword">as</span> lf</span><br><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> task</span><br><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> engines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, x, y, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flow = gf.Flow(<span class="string">&#x27;root&#x27;</span>).add(</span><br><span class="line">    lf.Flow(<span class="string">&#x27;nested_linear&#x27;</span>).add(</span><br><span class="line">        <span class="comment"># 从后台存储中读取名为y3和y4的参数值，并以参数x，y传递给execute方法</span></span><br><span class="line">        <span class="comment"># x2 = y3 + y4</span></span><br><span class="line">        Adder(<span class="string">&#x27;add2&#x27;</span>, provides=<span class="string">&#x27;x2&#x27;</span>, rebind=[<span class="string">&#x27;y3&#x27;</span>, <span class="string">&#x27;y4&#x27;</span>]),</span><br><span class="line">        <span class="comment"># x1 = y1 + y2</span></span><br><span class="line">        Adder(<span class="string">&#x27;add1&#x27;</span>, provides=<span class="string">&#x27;x1&#x27;</span>, rebind=[<span class="string">&#x27;y1&#x27;</span>, <span class="string">&#x27;y2&#x27;</span>]),</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># x5 = x1 + x3</span></span><br><span class="line">    Adder(<span class="string">&#x27;add5&#x27;</span>, provides=<span class="string">&#x27;x5&#x27;</span>, rebind=[<span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;x3&#x27;</span>]),</span><br><span class="line">    <span class="comment"># x3 = x1 + x2</span></span><br><span class="line">    Adder(<span class="string">&#x27;add3&#x27;</span>, provides=<span class="string">&#x27;x3&#x27;</span>, rebind=[<span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;x2&#x27;</span>]),</span><br><span class="line">    <span class="comment"># x4 = x2 + y5</span></span><br><span class="line">    Adder(<span class="string">&#x27;add4&#x27;</span>, provides=<span class="string">&#x27;x4&#x27;</span>, rebind=[<span class="string">&#x27;x2&#x27;</span>, <span class="string">&#x27;y5&#x27;</span>]),</span><br><span class="line">    <span class="comment"># x6 = x5 + x4</span></span><br><span class="line">    Adder(<span class="string">&#x27;add6&#x27;</span>, provides=<span class="string">&#x27;x6&#x27;</span>, rebind=[<span class="string">&#x27;x5&#x27;</span>, <span class="string">&#x27;x4&#x27;</span>]),</span><br><span class="line">    <span class="comment"># x7 = x6 + x6</span></span><br><span class="line">    Adder(<span class="string">&#x27;add7&#x27;</span>, provides=<span class="string">&#x27;x7&#x27;</span>, rebind=[<span class="string">&#x27;x6&#x27;</span>, <span class="string">&#x27;x6&#x27;</span>])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">store = &#123;</span><br><span class="line">    <span class="string">&#x27;y1&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;y2&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;y3&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;y4&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="string">&#x27;y5&#x27;</span>: <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = engines.run(</span><br><span class="line">    flow=flow,</span><br><span class="line">    store=store,</span><br><span class="line">    engine_conf=<span class="string">&#x27;serial&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;single thread engine result %s&#x27;</span> % result</span><br><span class="line"></span><br><span class="line">result = engines.run(</span><br><span class="line">    flow=flow,</span><br><span class="line">    store=store,</span><br><span class="line">    engine_conf=<span class="string">&#x27;parallel&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;multi thread engine result %s&#x27;</span> % result</span><br></pre></td></tr></table></figure>

<p>上面的示例中，定义了一个Task对象Adder，作用是完成一个加法。接下去生成一个图类型的流root，其中的task都通过provides和rebind来指明它们的输出和输入。</p>
<p>在engine运行时，通过store参数为流root提供所需要的输入参数，engine会把store的值保存在后台存储中：在执行各个task的过程中，各个task的输入都是从后台存储中获取，输出都保存在后台存储中。这个程序的输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Single thread engine result &#123;<span class="string">&#x27;x1&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;y5&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;y4&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;y1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;x2&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;x3&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;y3&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;y2&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;x6&#x27;</span>: <span class="number">41</span>, <span class="string">&#x27;x7&#x27;</span>: <span class="number">82</span>, <span class="string">&#x27;x4&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;x5&#x27;</span>: <span class="number">20</span>&#125;.</span><br><span class="line">Multi thread engine result &#123;<span class="string">&#x27;x1&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;y5&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;y4&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;y1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;x2&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;x3&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;y3&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;y2&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;x6&#x27;</span>: <span class="number">41</span>, <span class="string">&#x27;x7&#x27;</span>: <span class="number">82</span>, <span class="string">&#x27;x4&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;x5&#x27;</span>: <span class="number">20</span>&#125;.</span><br></pre></td></tr></table></figure>

<p>TaskFlow中的Task和Retry都是Atom的子类。对于任何一种Atom对象，都可以通过requires属性来了解它所要求的输入参数，和通过provides属性来了解它能够提供的输出结果的名字。requires和provides的类型都是包含参数名称的集合（set）。</p>
<h3 id="requires"><a href="#requires" class="headerlink" title="requires"></a>requires</h3><p>Task对象的requires可以由execute方法获得。比如示例中的Adder对象，由于execute方法的参数是execute(self, x, y)，所以它的requires为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Adder().requires</span><br><span class="line"></span><br><span class="line">OrderedSet([<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br></pre></td></tr></table></figure>
<div class="alert danger no-icon"><p>注意，execute方法的可选参数和*args和**kwargs并不会出现在requires中。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, spam, eggs=(<span class="params"></span>), *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> spam + eggs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyTask().requires</span><br><span class="line">OrderedSet([<span class="string">&#x27;spam&#x27;</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UniTask</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UniTask().requires</span><br><span class="line">OrderedSet([])</span><br></pre></td></tr></table></figure>

<p>此外，也可以在创建Task时明确指定它的输入参数要求，这些参数在调用execute()方法时可以通过kwargs获得：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, food, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog = Dog(requires=(<span class="string">&#x27;water&#x27;</span>, <span class="string">&#x27;grass&#x27;</span>))</span><br><span class="line">dog.requires</span><br><span class="line">OrderedSet([<span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;water&#x27;</span>, <span class="string">&#x27;grass&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="rebind"><a href="#rebind" class="headerlink" title="rebind"></a>rebind</h3><p>在有些情况下，传递给某个task的输入参数名称和其所需要的参数名不同，这个时候可以通过rebind来处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpawnVMTask</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, vm_name, vm_image_id, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># engine执行下面这个task时，会从后台存储中获取到名为&#x27;name&#x27;的参数值</span></span><br><span class="line"><span class="comment"># 然后把它当做vm_name参数传递给task的execute()方法</span></span><br><span class="line">s = SpawnVMTask(rebind=&#123;<span class="string">&#x27;vm_name&#x27;</span>: <span class="string">&#x27;name&#x27;</span>&#125;)</span><br><span class="line">s.requires</span><br><span class="line">OrderedSet([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;vm_image_id&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># engine执行下面这个task时，会从后台存储中获取到名为&#x27;name&#x27;, &#x27;image_id&#x27;</span></span><br><span class="line"><span class="comment"># 和&#x27;admin_key_name&#x27;的参数值，把name和image_id分别当做vm_name</span></span><br><span class="line"><span class="comment"># 和vm_image_id参数，把admin_key_name当做args参数中的某一项传递</span></span><br><span class="line"><span class="comment"># 给task的execute()方法</span></span><br><span class="line">s = SpawnVMTask(rebind=(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;image_id&#x27;</span>, <span class="string">&#x27;admin_key_name&#x27;</span>))</span><br><span class="line">s.requires</span><br><span class="line">OrderedSet([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;image_id&#x27;</span>, <span class="string">&#x27;admin_key_name&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="provides"><a href="#provides" class="headerlink" title="provides"></a>provides</h3><p>task的输出结果一般是指其execute()方法的返回值。但是由于Python返回值是没有名字的，所有需要通过Task对象的provides属性指明返回值以什么名称存入后台存储中。根据execute()返回值类型的不同，provides可以有不同的方式指定。</p>
<ul>
<li><p>如果execute()方法返回的是一个单一的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> task</span><br><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> engines</span><br><span class="line"><span class="keyword">from</span> taskflow.patterns <span class="keyword">import</span> linear_flow <span class="keyword">as</span> lf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TheAnswerReturningTask</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = TheAnswerReturningTask(provides=<span class="string">&#x27;the_answer&#x27;</span>)</span><br><span class="line">flow = lf.Flow(<span class="string">&#x27;linear&#x27;</span>).add(t)</span><br><span class="line">result = engines.run(</span><br><span class="line">    flow=flow,</span><br><span class="line">    engine_conf=<span class="string">&#x27;serial&#x27;</span></span><br><span class="line">)</span><br><span class="line">result</span><br><span class="line">&#123;<span class="string">&#x27;the_answer&#x27;</span>: <span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果execute()方法返回元组tuple。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> task</span><br><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> engines</span><br><span class="line"><span class="keyword">from</span> taskflow.patterns <span class="keyword">import</span> linear_flow <span class="keyword">as</span> lf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitsAndPiecesTask</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Bits&#x27;</span>, <span class="string">&#x27;Pieces&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = BitsAndPiecesTask(provides=(<span class="string">&#x27;bits&#x27;</span>, <span class="string">&#x27;pieces&#x27;</span>))</span><br><span class="line">flow = lf.Flow(<span class="string">&#x27;linear&#x27;</span>).add(t)</span><br><span class="line">result = engines.run(</span><br><span class="line">    flow=flow,</span><br><span class="line">    engine_conf=<span class="string">&#x27;serial&#x27;</span></span><br><span class="line">)</span><br><span class="line">result</span><br><span class="line">&#123;<span class="string">&#x27;bits&#x27;</span>: <span class="string">&#x27;Bits&#x27;</span>, <span class="string">&#x27;pieces&#x27;</span>: <span class="string">&#x27;Pieces&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果execute()方法返回字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> task</span><br><span class="line"><span class="keyword">from</span> taskflow <span class="keyword">import</span> engines</span><br><span class="line"><span class="keyword">from</span> taskflow.patterns <span class="keyword">import</span> linear_flow <span class="keyword">as</span> lf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitsAndPiecesTask</span>(task.Task):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;Bits&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;Pieces&#x27;</span>: <span class="number">321</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = BitsAndPiecesTask(provides=&#123;<span class="string">&#x27;Bits&#x27;</span>, <span class="string">&#x27;Pieces&#x27;</span>&#125;)</span><br><span class="line">flow = lf.Flow(<span class="string">&#x27;linear&#x27;</span>).add(t)</span><br><span class="line">result = engines.run(</span><br><span class="line">    flow=flow,</span><br><span class="line">    engine_conf=<span class="string">&#x27;serial&#x27;</span></span><br><span class="line">)</span><br><span class="line">result</span><br><span class="line">&#123;<span class="string">&#x27;Bits&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;Pieces&#x27;</span>: <span class="number">321</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="oslo-policy"><a href="#oslo-policy" class="headerlink" title="oslo.policy"></a>oslo.policy</h1><p><a target="_blank" rel="noopener" href="https://github.com/openstack/oslo.policy">oslo.policy</a>用于控制用户的权限，能够执行什么样的操作。</p>
<p>OpenStack的每个项目都有一个/etc/<project>/policy.yaml文件，通过这个配置文件来实现对用户的权限管理。</p>
<p>将policy操作的公共部分提取出来，就形成了oslo.policy库，它会负责policy的验证和rules的管理。</p>
<p>policy的验证，其实就是对字典key和value的判断，如果匹配成功，则通过policy，否则失败。</p>
<p>各个工程的API通过policy来检测用户身份群权限的规则，例如有些API只有管理员权限可以执行，有些普通用户可以执行，在代码中的体现就是判断context的project_id和user_id是不是合法类型的。</p>
<p>Nova API示例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authorize</span>(<span class="params">context, action, target, do_raise=<span class="literal">True</span>, exc=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Verifies that the action is valid on the target in this context.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       :param context: nova context</span></span><br><span class="line"><span class="string">       :param action: string representing the action to be checked</span></span><br><span class="line"><span class="string">           this should be colon separated for clarity.</span></span><br><span class="line"><span class="string">           i.e. ``compute:create_instance``,</span></span><br><span class="line"><span class="string">           ``compute:attach_volume``,</span></span><br><span class="line"><span class="string">           ``volume:attach_volume``</span></span><br><span class="line"><span class="string">       :param target: dictionary representing the object of the action</span></span><br><span class="line"><span class="string">           for object creation this should be a dictionary representing the</span></span><br><span class="line"><span class="string">           location of the object e.g. ``&#123;&#x27;project_id&#x27;: context.project_id&#125;``</span></span><br><span class="line"><span class="string">       :param do_raise: if True (the default), raises PolicyNotAuthorized;</span></span><br><span class="line"><span class="string">           if False, returns False</span></span><br><span class="line"><span class="string">       :param exc: Class of the exception to raise if the check fails.</span></span><br><span class="line"><span class="string">                   Any remaining arguments passed to :meth:`authorize` (both</span></span><br><span class="line"><span class="string">                   positional and keyword arguments) will be passed to</span></span><br><span class="line"><span class="string">                   the exception class. If not specified,</span></span><br><span class="line"><span class="string">                   :class:`PolicyNotAuthorized` will be used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       :raises nova.exception.PolicyNotAuthorized: if verification fails</span></span><br><span class="line"><span class="string">           and do_raise is True. Or if &#x27;exc&#x27; is specified it will raise an</span></span><br><span class="line"><span class="string">           exception of that type.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       :return: returns a non-False value (not necessarily &quot;True&quot;) if</span></span><br><span class="line"><span class="string">           authorized, and the exact value False if not authorized and</span></span><br><span class="line"><span class="string">           do_raise is False.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    init()</span><br><span class="line">    credentials = context.to_policy_values()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> exc:</span><br><span class="line">        exc = exception.PolicyNotAuthorized</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = _ENFORCER.authorize(action, target, credentials,</span><br><span class="line">                                     do_raise=do_raise, exc=exc, action=action)</span><br><span class="line">    <span class="keyword">except</span> policy.PolicyNotRegistered:</span><br><span class="line">        <span class="keyword">with</span> excutils.save_and_reraise_exception():</span><br><span class="line">            LOG.exception(_LE(<span class="string">&#x27;Policy not registered&#x27;</span>))</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">with</span> excutils.save_and_reraise_exception():</span><br><span class="line">            LOG.debug(<span class="string">&#x27;Policy check for %(action)s failed with credentials &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;%(credentials)s&#x27;</span>,</span><br><span class="line">                      &#123;<span class="string">&#x27;action&#x27;</span>: action, <span class="string">&#x27;credentials&#x27;</span>: credentials&#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对应/etc/nova/policy.json文件内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;context_is_admin&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;role:admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin_or_owner&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;is_admin:True or project_id:%(project_id)s&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rule:admin_or_owner&quot;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看到，nova policy的rule是“is_admin:True or project_id:%(project_id)s”，需要验证policy验证是不是admin用户或者project_id是不是匹配。</p>
<h1 id="oslo-rootwarp"><a href="#oslo-rootwarp" class="headerlink" title="oslo.rootwarp"></a>oslo.rootwarp</h1><p><a target="_blank" rel="noopener" href="https://github.com/openstack/oslo.rootwrap">oslo.rootwarp</a>可以让其他OpenStack服务以root身份执行shell命令。一般来说，OpenStack的服务都是以非特权用户的身份运行的，但是当它们需要以root身份运行某些shell命令时，就需要利用到oslo.rootwrap的功能。</p>
<p>oslo.rootwarp首先从配置文件所定义的Filter文件目录中读取所有Filter定义，然后检查要运行的shell命令是否和Filter中的定义相匹配，匹配则运行，不匹配就不运行。</p>
<h2 id="构造rootwrap-shell脚本"><a href="#构造rootwrap-shell脚本" class="headerlink" title="构造rootwrap shell脚本"></a>构造rootwrap shell脚本</h2><p>使用rootwrap需要在一个单独的Python进程中以root身份调用Python函数oslo.rootwrap.cmd.main()。可以通过Setuptools中的console script来构造这样一个脚本。</p>
<p>以nova为例。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setup.cfg</span></span><br><span class="line"></span><br><span class="line"><span class="attr">console_scripts</span> =</span><br><span class="line">    <span class="attr">nova-api</span> = nova.cmd.api:main</span><br><span class="line">    <span class="attr">nova-compute</span> = nova.cmd.compute:main</span><br><span class="line">    <span class="attr">nova-conductor</span> = nova.cmd.conductor:main</span><br><span class="line">    <span class="attr">nova-console</span> = nova.cmd.console:main</span><br><span class="line">    <span class="attr">nova-manage</span> = nova.cmd.manage:main</span><br><span class="line">    <span class="attr">nova-policy</span> = nova.cmd.policy:main</span><br><span class="line">    <span class="attr">nova-rootwrap</span> = oslo_rootwrap.cmd:main</span><br></pre></td></tr></table></figure>
<p>可以看到构造一个名为nova-rootwrap的shell脚本时，会调用oslo.rootwrap.cmd.main()函数。运行“python setup.py install”之后，nova-rootwrap脚本就会被生成。</p>
<h2 id="调用rootwrap-shell脚本"><a href="#调用rootwrap-shell脚本" class="headerlink" title="调用rootwrap shell脚本"></a>调用rootwrap shell脚本</h2><p>rootwrap的shell脚本需要以sudo方式调用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nova-rootwrap /etc/nova/rootwrap.conf COMAND_LINE</span><br></pre></td></tr></table></figure>
<p>其中/etc/nova/rootwrap.conf是oslo.rootwrap的配置文件名，COMAND_LINE是希望root用户身份运行的shell命令。</p>
<p>由于rootwrap shell 脚本需要以sudo方式运行，所以还需要配置sudoers文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nova ALL = (root) NOPASSWD: /var/lib/kolla/venv/bin/nova-rootwrap /etc/nova/rootwrap.conf *</span><br></pre></td></tr></table></figure>

<h2 id="rootwrap配置文件"><a href="#rootwrap配置文件" class="headerlink" title="rootwrap配置文件"></a>rootwrap配置文件</h2><p>rootwrap配置文件是以INI的文件格式存放的。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/oslo.rootwrap.png" title="rootwrap 配置选项" data-caption="rootwrap 配置选项" data-fancybox="default"><img class="fig-img" src="images/oslo.rootwrap.png" alt="rootwrap 配置选项"></a><span class="caption">rootwrap 配置选项</span></div>

<h2 id="定义Filter"><a href="#定义Filter" class="headerlink" title="定义Filter"></a>定义Filter</h2><p>Filter定义文件一般以.filter后缀结尾，放在配置选项filters_path所指定的目录中。这些定义文件以ini格式存放，Filter的定义存放在[Filter]节中。定义的格式如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filter名: Filter类, [Filter类参数1, Filter类参数2, ...]</span><br></pre></td></tr></table></figure>

<p>rootwrap目前所支持的Filter类型。</p>
<div class="figure center" style="width:;"><a class="fancybox" href="images/oslo.rootwrap_filter.png" title="rootwrap 所支持的Filter类型" data-caption="rootwrap 所支持的Filter类型" data-fancybox="default"><img class="fig-img" src="images/oslo.rootwrap_filter.png" alt="rootwrap 所支持的Filter类型"></a><span class="caption">rootwrap 所支持的Filter类型</span></div>

<h1 id="oslo-test"><a href="#oslo-test" class="headerlink" title="oslo.test"></a>oslo.test</h1><p><a target="_blank" rel="noopener" href="https://github.com/openstack/oslotest">oslo.test</a>库提供单元测试的基础框架。</p>
<h1 id="oslo-versionedobjects"><a href="#oslo-versionedobjects" class="headerlink" title="oslo.versionedobjects"></a>oslo.versionedobjects</h1><p>在项目的不断迭代和升级中，数据库结构和API接口的改动不可避免，如果没有一个版本控制的概念在里面，新旧不同模块之间交互就很容易出现问题。<a target="_blank" rel="noopener" href="https://github.com/openstack/oslo.versionedobjects">oslo.versionedobjects</a>库提供一种通用的自带版本的对象模型，自带序列化功能，可以很容易地和oslo.messaging结合进行远程调用。</p>
            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/OpenStack/" rel="tag">OpenStack</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Oslo/" rel="tag">Oslo</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/15/Glance%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"
                    data-tooltip="Glance接口测试"
                    aria-label="PREVIOUS: Glance接口测试"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"
                    data-tooltip="Python内置函数"
                    aria-label="NEXT: Python内置函数"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/"
                    title="Share on Weibo"
                    aria-label="Share on Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/&amp;title=OpenStack通用库"
                    title="Share on QQ"
                    aria-label="Share on QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/"
                    title="Share on Qzone"
                    aria-label="Share on Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>

<div class="main-content-wrap">
    
        
            <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
阅读量：<span id="2019/05/07/OpenStack通用库/" class="waline-visitor-count"></span>
<div id="vcomments"></div>
<script>
    new Waline({
        el: "#vcomments",
        serverURL: "https://blog-api-nu-nine.vercel.app/",
        lang: "zh-cn",
        visitor: true,
        emoji: [
            "https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili",
            "https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq",
        ],
        placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
        dark: "auto",
        meta: ["nick", "mail", "link"],
        requiredMeta: [],
        wordLimit: "200",
        pageSize: "10",
        highlight: "hanabi",
        copyright: true,
        avatar: "wavatar",
    });
</script>
  
        
    
</div>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 Wang kuntian. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/15/Glance%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"
                    data-tooltip="Glance接口测试"
                    aria-label="PREVIOUS: Glance接口测试"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/04/02/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"
                    data-tooltip="Python内置函数"
                    aria-label="NEXT: Python内置函数"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/"
                    title="Share on Weibo"
                    aria-label="Share on Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/&amp;title=OpenStack通用库"
                    title="Share on QQ"
                    aria-label="Share on QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/"
                    title="Share on Qzone"
                    aria-label="Share on Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/"
                        aria-label="Share on Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>Share on Weibo</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/&amp;title=OpenStack通用库"
                        aria-label="Share on QQ"
                    >
                        <i class="fab fa-qq" aria-hidden="true"></i><span>Share on QQ</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://wangkuntian.github.io/2019/05/07/OpenStack%E9%80%9A%E7%94%A8%E5%BA%93/"
                        aria-label="Share on Qzone"
                    >
                        <i class="fa fa-star" aria-hidden="true"></i><span>Share on Qzone</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/faker.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Wang kuntian</h4>
        
            <div id="about-card-bio"><p>Hi</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Software Engineer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Beijing
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-ndtc2tx33sr3grlppafri7aw03fwgxbruphsl7cntcdkym8tusuknerf6c0g.min.js"></script>

<!--SCRIPTS END-->


    




    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"display":{"superSample":2.5,"width":180,"height":400,"position":"right","hOffset":0,"vOffset":40},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":true,"hitokoto":false},"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hibiki.model.json"},"log":false});</script></body>
</html>
