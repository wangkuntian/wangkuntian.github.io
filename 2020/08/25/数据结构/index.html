
<!DOCTYPE html>
<html lang="zh-en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Wang kuntian&#39;s Blog">
    <title>数据结构 - Wang kuntian&#39;s Blog</title>
    <meta name="author" content="Wang kuntian">
    
        <meta name="keywords" content="数据结构">
    
    
        <link rel="icon" href="https://wangkuntian.github.io/assets/images/favicon.png">
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Wang kuntian","sameAs":["https://github.com/wangkuntian","mailto:wangkuntian1994@163.com"],"image":"faker.jpg"},"articleBody":"\n\n链表链表分为单（向）链表和双（向）链表。顾名思义，单链表就是单一方向遍历的链表结构，双链表就是双向遍历的链表结构。\n单链表在python中可以这么定义单链表节点。\n123456789101112131415161718192021class ListNode(object):    def __init__(self, x):        self.val = x        self.next = None    def __repr__(self):        temp = self        s = &#x27;&#x27;        while temp:            s += str(temp.val) + &#x27; ---&gt; &#x27;            temp = temp.next        s += &#x27;None&#x27;        return s        @classmethod    def generate(cls, nums):        result = temp = ListNode(nums[0])        for i in nums[1:]:            temp.next = ListNode(i)            temp = temp.next        return result\n链表长度为n时，遍历的时间复杂度是O(n)，插入的时间复杂度是O(1), 删除的时间复杂度是O(n)。\n\n\n插入在链表之间插入。\n123456l1 = ListNode(1)l2 = ListNode(2)l1.next = l2&#x27;&#x27;&#x27;1 -&gt;  2 -&gt; None&#x27;&#x27;&#x27;\n现在有个一新的节点l3，将它插入到链表中我们只要。\n123456l3 = ListNode(3)l3.next = l2l1.next = l3&#x27;&#x27;&#x27;1 -&gt; 3 -&gt; 2 -&gt; None&#x27;&#x27;&#x27;\n\n在链表前或者末尾插入，都是比较简单的。\n1234567891011121314151617181920# 链表前l4 = ListNode(4)l4.next = l1&#x27;&#x27;&#x27;4 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; None&#x27;&#x27;&#x27;# 链表后l5 = ListNode(5)l2.next = l5&#x27;&#x27;&#x27;4 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; None&#x27;&#x27;&#x27;# 或者l5 = ListNode(5)while l1.next:    l1 = l1.nextl1.next = l5&#x27;&#x27;&#x27;4 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; None&#x27;&#x27;&#x27;\n\n删除12345678l1 = ListNode(1)l2 = ListNode(2)l3 = ListNode(3)l1.next = l2   l2.next = l3&#x27;&#x27;&#x27;1 -&gt; 2 -&gt; 3 -&gt; None&#x27;&#x27;&#x27;    \n删除l2可以这样\n1234l1.next = l3&#x27;&#x27;&#x27;1 -&gt; 3 -&gt; None&#x27;&#x27;&#x27;    \n删除结点的时间复杂度是O(n)，空间复杂度为O(1)。\n设计链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class MyLinkedList(object):    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.length = 0        self.head = ListNode(0)    def get(self, index):        &quot;&quot;&quot;        Get the value of the index-th node in the linked list. If the index is invalid, return -1.        :type index: int        :rtype: int        &quot;&quot;&quot;        if index &gt;= self.length:            return -1        head = self.head        for _ in range(index + 1):            head = head.next        return head.val    def addAtHead(self, val):        &quot;&quot;&quot;        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.        :type val: int        :rtype: None        &quot;&quot;&quot;        self.addAtIndex(0, val)    def addAtTail(self, val):        &quot;&quot;&quot;        Append a node of value val to the last element of the linked list.        :type val: int        :rtype: None        &quot;&quot;&quot;        self.addAtIndex(self.length, val)    def addAtIndex(self, index, val):        &quot;&quot;&quot;        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.        :type index: int        :type val: int        :rtype: None        &quot;&quot;&quot;        if index &gt; self.length:            return        if index &lt; 0:            index = 0        node = ListNode(val)        head = self.head        for i in range(index):            head = head.next        node.next = head.next        head.next = node        self.length += 1    def deleteAtIndex(self, index):        &quot;&quot;&quot;        Delete the index-th node in the linked list, if the index is valid.        :type index: int        :rtype: None        &quot;&quot;&quot;        if index &gt;= self.length or index &lt; 0:            return        head = self.head        while index:            index -= 1            head = head.next        head.next = head.next.next        self.length -= 1linkedList = MyLinkedList()linkedList.addAtHead(1)print(linkedList.head)linkedList.addAtTail(3)print(linkedList.head)linkedList.addAtIndex(1, 2)print(linkedList.head)print(linkedList.get(1))linkedList.deleteAtIndex(1)print(linkedList.head)print(linkedList.get(1))\n\n双指针判断是否有环给定一个链表，判断链表中是否有环，返回链表开始入环的第一个节点。\n思路：定义两个指针，一个走的快，一个走的慢。如果链表中存在环，那么快指针肯定会再次追上慢指针（套圈）。两个指针相遇的点记作点A。再定义一个指针再从链表头出发，慢指针从点A出发，它们相遇的地方记作点B。点B就是链表开始入环的第一个节点。\n\n\n123456789101112131415161718192021222324252627282930313233343536class Solution(object):    def detectCycle(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not head:            return None        fast = head        slow = head        while slow and fast.next:            slow = slow.next            fast = fast.next.next            if slow == fast:                fast = head                while fast != slow:                    slow = slow.next                    fast = fast.next                return slow        return Nonel0 = ListNode(0)l1 = ListNode(1)l2 = ListNode(2)l3 = ListNode(3)l4 = ListNode(4)l0.next = l1l1.next = l2l2.next = l3l3.next = l4l4.next = l1s = Solution().detectCycle(l0)print(s.val)\n\n相交链表找到两个单链表相交的起始节点。\n思路：x + y = y + x。同时遍历两个条链表，短的链表先遍历完，再将它和长的链表相接也就是x + y。同理长的链表遍历完的时候，再将它和短的链表相接也就是y + x。这样一来，就解决了遍历时两条链表长度不一致的问题。遍历过程中，节点相同的就是交点。\n两条链表没有交点的情况也同样适用。\n\n\n123456789101112131415161718192021222324252627282930313233class Solution(object):    def getIntersectionNode(self, headA, headB):        &quot;&quot;&quot;        :type head1, head1: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not headA or not headB:            return None        x = headA        y = headB        while x != y:            x = x.next if x else headB            y = y.next if y else headA        return xl1 = ListNode(4)l2 = ListNode(1)l3 = ListNode(8)l4 = ListNode(4)l5 = ListNode(5)l1.next = l2l2.next = l3l3.next = l4l4.next = l5l6 = ListNode(5)l7 = ListNode(0)l8 = ListNode(1)l6.next = l7l7.next = l8l8.next = l3print(Solution().getIntersectionNode(l1, l6))\n\n删除倒数第N个节点删除链表的倒数第n个节点，并且返回链表的头结点。n保证是有效值。\n思路：定义两个指针，一个负责定位删除的元素的指针x，一个负责辅助定位的指针y。先让y指针走n步，再让x和y，同时遍历。当y指向链表的最后一项时，x刚好指向要删除的元素的前一项。这样可以利用x.next = x.next.next删除x的下一项。\n有一个情况需要考虑到，就是指针y走n步后，y已经为空，也就是n == 链表的长度，也就是要删除第一个数，结果直接返回head.next即可。\n\n\n\n1234567891011121314151617181920212223242526272829class Solution(object):    def removeNthFromEnd(self, head, n):        &quot;&quot;&quot;        :type head: ListNode        :type n: int        :rtype: ListNode        &quot;&quot;&quot;        if not head:            return None        x = y = head        for _ in range(n):            y = y.next        if not y:            return head.next        while y.next:            y = y.next            x = x.next        x.next = x.next.next        return head        l = ListNode.generate([1, 2, 3, 4, 5])print(Solution().removeNthFromEnd(l, 2))l = ListNode.generate([1])print(Solution().removeNthFromEnd(l, 1))l = ListNode.generate([1, 2])print(Solution().removeNthFromEnd(l, 1))l = ListNode.generate([1, 2])print(Solution().removeNthFromEnd(l, 2))\n\n经典问题反转链表反转一个链表。\n思路一：双指针解法。定义一个指针result，配合参数head组成双指针。result必须先设为None。随后遍历head。遍历head时，注意要记录一下head.next的值，这里定义一个temp来接收它。然后就是反转。head.next = result 把head下一个指向result，result = head 同时更新一下result的位置，让result指向当前head所指向的位置。最后更新一下head的位置，注意这时的head指向，不能使用head = head.next要用head = temp来更新head位置。最后返回result即可。\n这里说明一下result的初始值必须为None，因为反转后的链表的最后一项（也就是反转前的第一项）必须指向None。result指针在第一次循环开始后，就紧跟在head的前面。\n算法时间复杂度是O(n)，空间复杂度是O(1)。\n\n\n思路二：递归。递归的解法有点不好想。首先想，递归要什么时候返回值合适，应该是head.next为空的时候我们需要返回head的值，不能等到head为空了再返回，因为我们要保证head.next不为空才能进行反转。\n1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; None拿上面的链表举例。刚开始head在1的位置，当进行递归时head的位置应该在5。反转时，我们还需要知道前一个节点，所以head应该在4的位置。给递归函数需要传head.next，这样既保证了递归，也保证了在head到4位置时，返回值是5 -&gt; None这个链表。此时的head的值为 4 —&gt; 5 -&gt; None。返回值后我们知道需要反转了。首先让5 -&gt; 4，head.next.next = head，再将4 -&gt; 5之间的联系断开，不然有环。head.next = None就得到了5 -&gt; 4。\n当head为空时，直接返回head。\n算法时间复杂度是O(n)，空间复杂度是O(n)。\n\n\n123456789101112131415161718192021222324252627282930class Solution(object):    # 循环    def reverseList(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not head:            return None        result = None        while head:            temp = head.next            head.next = result            result = head            head = temp        return result        # 递归    def reverseList_2(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not head or not head.next:            return head        result = self.reverseList_2(head.next)        head.next.next = head        head.next = None        return result        \n\n移除链表元素删除链表中等于给定值 val 的所有节点。\n思路：定义两个指针result和pre，它们的next都指向head。遍历pre，当pre.next不为空时，判断pre.next.val和val的值是否一致，如果一致，pre.next被删除掉，pre.next = pre.next.next，不一致，pre前进一步，pre = pre.next。循环结束后result.next即所求。\n主要考虑到删除当前元素时，需要知道前一个元素的指针才能删除。所以要，pre.next = head。\n\n123456789101112131415class Solution(object):    def removeElements(self, head, val):        &quot;&quot;&quot;        :type head: ListNode        :type val: int        :rtype: ListNode        &quot;&quot;&quot;        result = pre = ListNode(None)        pre.next = head        while pre.next:            if pre.next.val == val:                pre.next = pre.next.next            else:                 pre = pre.next        return result.next\n\n奇偶链表给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。\n思路：定义两个ListNode，odd（奇）和even（偶），和他们各自的head，odd_head和even_head。遍历链表head，第一次循环时，链表的第一项默认是奇数项，所以odd.next = head, odd前进一步odd = odd.next。链表的第一项默认是奇数项，第二项就是偶数项，所以even的下一项就是head.next，even.next = head.next，even前进一步。这时候，head应该前进两步，要使用head = head.next.next，但是当head.next为空时（遍历到最后一项），会出错，这时应该直接将head置为空。循环结束后，得到两条链表，odd_head和even_head。将even_head接在odd_head后就好了。odd.next = odd_head.nextodd_head.next即所得。\n\n\n1234567891011121314151617class Solution(object):    def oddEvenList(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        odd = odd_head = ListNode(None)        even = even_head = ListNode(None)        while head:            odd.next = head            odd = odd.next            even.next = head.next            even = even.next            head = head.next.next if even else None        odd.next = even_head.next        return odd_head.next\n\n回文链表判断一个链表是否为回文链表。\n思路一：遍历链表，然后利用数组存放链表的值。最后判断数组是否是回文就可以了。此方法的算法时间复杂度是O(n)，空间复杂度也是O(n)，因为开辟了链表大小的数组。\n\n\n思路二：类似反转链表。例如，链表1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; None我们只需要将1 -&gt; 2 -&gt; 3的链表反转，再和剩下的链表进行比较，就可以了。定义一个快指针fast，一个慢指针slow， 一个控制反转的指针x。快指针一次走两步，慢指针一次走一步。遍历链表，要保证fast和fast.next不为空，这时进行链表的反转操作。当循环结束时，fast指针可能在最后一个或者倒数第二个的位置即fast为空或者fast.next为空，这是由于链表长度有奇有偶导致的。所以当fast不为空时（链表项为奇数项），我们将slow后移动一步，slow = slow.next。这样我们就将链表从中间分开，得到一个slow链表，一个x链表（经过反转）。slow：2 -&gt; 1 -&gt; Nonex：2 -&gt; 1 -&gt; None反转链表时，x所指的位置一直是都是slow的前一项。再遍历链表slow判断值是否和x链表一致就可以得出是否是回文链表了。\n算法时间复杂度是O(n)，空间复杂度是O(1)。\n\n\n123456789101112131415161718192021222324252627282930313233343536class Solution(object):    def isPalindrome(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: bool        &quot;&quot;&quot;        values = []        while head:            values.append(head.val)            head = head.next        return values == values[::-1]         def isPalindrome_2(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: bool        &quot;&quot;&quot;        if not head or not head.next:            return True        fast = slow = head        x = None        while fast and fast.next:            fast = fast.next.next            temp = slow.next            slow.next = x            x = slow            slow = temp        if fast:            slow = slow.next        while slow:            if slow.val != x.val:                return False            slow = slow.next            x = x.next        return True\n\n双链表双链表中节点的定义。\n123456class DoublyListNode(object):    def __init__(self, x):        self.val = x        self.pre = None        self.next = None    \n\n插入如果我们想在现有的结点prev之后，next之前插入一个新的结点cur，我们可以将此过程分为两个步骤：\n12345cur.pre = prevcur.next = nextprev.next = curnext.pre = cur\n\n与单链表类似，添加操作的时间和空间复杂度都是O(1)。\n\n\n删除删除之前添加在prev和next之间的节点cur。\n12prev.next = nextnext.pre = prev\n删除操作的时间和空间复杂度都是O(1)。\n\n\n\n小结单链表和双链表相同点。\n它们都无法在常量时间内随机访问数据。它们都能够在O(1)时间内在给定结点之后或列表开头添加一个新结点。它们都能够在O(1)时间内删除第一个结点。\n\n\n再删除节点上，单链表和双链表稍有不同。\n在单链表中，它无法获取给定结点的前一个结点，因此在删除给定结点之前我们必须花费O(N)时间来找出前一结点。在双链表中，这会更容易，因为可以使用pre获取前一个结点。因此可以在O(1)时间内删除给定结点。\n\n\n时间复杂度对照\n\n练习合并两个有序的链表将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n123456789101112131415161718class Solution(object):    def mergeTwoLists(self, l1, l2):        &quot;&quot;&quot;        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        &quot;&quot;&quot;        result = temp = ListNode(None)        while l1 and l2:            if l1.val &lt;= l2.val:                temp.next = l1                l1 = l1.next            else:                temp.next = l2                l2 = l2.next            temp = temp.next        temp.next = l1 if l1 else l2        return result.next\n\n两数相加给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n123456789101112131415161718192021class Solution(object):    class Solution(object):        def addTwoNumbers(self, l1, l2):            &quot;&quot;&quot;            :type l1: ListNode            :type l2: ListNode            :rtype: ListNode            &quot;&quot;&quot;            result = pre = ListNode(None)            carry = 0            while l1 or l2 or carry:                if l1:                    carry += l1.val                    l1 = l1.next                if l2:                    carry += l2.val                    l2 = l2.next                pre.next = ListNode(carry % 10)                pre = pre.next                carry //= 10            return result.next\n\n旋转链表给定一个链表，旋转链表，将链表每个节点向右移动k个位置，其中k是非负数。\n1234567891011121314151617181920class Solution(object):    def rotateRight(self, head, k):        &quot;&quot;&quot;        :type head: ListNode        :type k: int        :rtype: ListNode        &quot;&quot;&quot;        if not head:            return head        x = y = head        n = 1        while x.next:            n += 1            x = x.next        x.next = head        for _ in range(n - k % n - 1):            y = y.next        result = y.next        y.next = None        return result\n\n队列队列是先进先出（FIFO）的数据结构。\n插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。删除（delete）操作也被称为出队（dequeue)。你只能移除第一个元素。\n按顺序处理元素时，使用队列可能是一个很好的选择。\n循环队列普通队列，在存储变量时，会出现假溢出的情况，为了充分利用存储空间，克服这一现象，循环队列应运而生。\n假溢出。系统作为队列用的存储区还没有满,但队列却发生了溢出,我们把这种现象称为”假溢出”。\n解决方法：\n\n将队列元素向前“平移”。\n将队列看成首尾相连，即循环队列。\n\n\n\n设计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class MyCircularQueue(object):    def __init__(self, k):        &quot;&quot;&quot;        Initialize your data structure here. Set the size of the queue to be k.        :type k: int        &quot;&quot;&quot;        self.k = k + 1        self.q = [None] * self.k        self.head = self.tail = 0    def enQueue(self, value):        &quot;&quot;&quot;        Insert an element into the circular queue. Return true if the operation is successful.        :type value: int        :rtype: bool        &quot;&quot;&quot;        if self.isFull():            return False        self.q[self.tail] = value        self.tail = (self.tail - 1) % self.k        return True    def deQueue(self):        &quot;&quot;&quot;        Delete an element from the circular queue. Return true if the operation is successful.        :rtype: bool        &quot;&quot;&quot;        if self.isEmpty():            return False        self.head = (self.head - 1) % self.k        return True    def Front(self):        &quot;&quot;&quot;        Get the front item from the queue.        :rtype: int        &quot;&quot;&quot;        if self.isEmpty():            return -1        return self.q[self.head]    def Rear(self):        &quot;&quot;&quot;        Get the last item from the queue.        :rtype: int        &quot;&quot;&quot;        if self.isEmpty():            return -1        return self.q[(self.tail + 1) % self.k]    def isEmpty(self):        &quot;&quot;&quot;        Checks whether the circular queue is empty or not.        :rtype: bool        &quot;&quot;&quot;        return self.head == self.tail    def isFull(self):        &quot;&quot;&quot;        Checks whether the circular queue is full or not.        :rtype: bool        &quot;&quot;&quot;        return (self.head + 1) % self.k == self.tail\nPython中的队列Python标准库中包含了四种队列，分别是queue.Queue、asyncio.Queue、multiprocessing.Queue和collections.deque。这里只讨论collections.deque。\ncollections.deque是双端队列（double-ended queue）的缩写，由于两端都能编辑，deque既可以用来实现栈（stack）也可以用来实现队列（queue）。\ndeque支持丰富的操作方法。\n\n\n相比于list实现的队列，deque实现拥有更低的时间和空间复杂度。list实现在出队和入队时的空间复杂度大约为O(n)，deque在出队和入队时的时间复杂度是O(1)。\n广度优先搜索广度优先搜索（Breadth First Search）简称BFS，其中一个应用就是找到根节点距离目标节点的最短路径。最近接根节点的节点最先遍历。\n在第k轮中将节点x添加到队列中，则根节点和节点x之间的最短距离刚好是k。\n广度优先搜索遍历时，首先将根节点加入队列中，随后将临近根节点的节点依次加入到队列中，并将根节点推出队列，以此类推，新添加的节点不会被立即处理，而是被添加到队列的末尾，等待下一轮的处理。\n节点的添加到队列的顺序和它们被处理的顺序完全相同，即先进先出（FIFO）。这是在BFS中应用队列的主要原因。\n模板模板一。\n12345678910111213141516171819202122232425262728import collectionsdef BFS(node, target):    # store all nodes which are waiting to be processed    queue = collections.deque()    # number of steps neeeded from root to current node    step = 0    # initialize    # add root to queue;    # find neighbors    def neighbors(node):        pass    while queue:        step += 1        # iterate the nodes which are already in the queue        for item in queue:            if item == target:                return step            for n in neighbors(item):                queue.append(n)            queue.popleft()    # there is no path from root to target    return -1\n\n模板二。确保不会访问一个结点两次。可以在上面的代码中添加一个哈希集。\n1234567891011121314151617181920212223242526272829303132import collectionsdef BFS(node, target):    # store all nodes which are waiting to be processed    queue = collections.deque()    # number of steps neeeded from root to current node    step = 0    used = set()    # initialize    # add root to queue;    # find neighbors    def neighbors(node):        pass    while queue:        step += 1        # iterate the nodes which are already in the queue        for item in queue:            if item == target:                return step            for n in neighbors(item):                if n not in used:                    used.add(n)                    queue.append(n)            queue.popleft()    # there is no path from root to target    return -1\n有两种情况你不需要使用哈希集：\n\n确定没有循环，例如，在树遍历中；\n希望多次将结点添加到队列中。\n\n\n\n岛屿数量一个由’1’（陆地）和’0’（水）组成的的二维网格，计算网格中岛屿的数量。\n岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，可以假设该网格的四条边均被水包围。\n1234567891011121314151617181920212223242526272829303132333435363738import collectionsclass Solution(object):    def numIslands(self, grid):        &quot;&quot;&quot;        :type grid: List[List[str]]        :rtype: int        &quot;&quot;&quot;        if not grid:            return 0        islands = 0        rows = len(grid)        cols = len(grid[0])        for r in range(rows):            for c in range(cols):                if grid[r][c] == &#x27;1&#x27;:                    islands += 1                    grid[r][c] = &#x27;0&#x27;                    queue = collections.deque([(r, c)])                    while queue:                        row, col = queue.popleft()                        if row - 1 &gt;= 0 and grid[row - 1][col] == &#x27;1&#x27;:                            queue.append((row - 1, col))                            grid[row - 1][col] = &#x27;0&#x27;                        if row + 1 &lt; rows and grid[row + 1][col] == &#x27;1&#x27;:                            queue.append((row + 1, col))                            grid[row + 1][col] = &#x27;0&#x27;                        if col - 1 &gt;= 0 and grid[row][col - 1] == &#x27;1&#x27;:                            queue.append((row, col - 1))                            grid[row][col - 1] = &#x27;0&#x27;                        if col + 1 &gt;= 0 and grid[row][col + 1] == &#x27;1&#x27;:                            queue.append((row, col + 1))                            grid[row][col + 1] = &#x27;0&#x27;                return islands\n\n\n打开转盘锁你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字：’0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把’9’变为’0’，’0’变为’9’。每次旋转都只能旋转一个拨轮的一位数字。\n锁的初始数字为’0000’ ，一个代表四个拨轮的数字的字符串。\n列表deadends包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\n字符串target代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。\n1234567891011121314151617181920212223242526272829import collectionsclass Solution(object):    def openLock(self, deadends, target):        &quot;&quot;&quot;        :type deadends: List[str]        :type target: str        :rtype: int        &quot;&quot;&quot;        def neighbors(node):            for i in range(4):                for x in (-1, 1):                    x = (int(node[i]) + x ) % 10                    yield node[:i] + str(x) + node[i+1:]        dead = set(deadends)        if &#x27;0000&#x27; in dead:            return -1        queue = collections.deque([(&#x27;0000&#x27;, 0)])        seen = &#123; &#x27;0000&#x27; &#125;        while queue:            node, step = queue.popleft()            if node == target:                return step            if node in dead:                continue            for n in neighbors(node):                if n not in seen:                    seen.add(n)                    queue.append((n, step + 1))        return -1\n\n完全平方数给定正整数n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于n。你需要让组成和的完全平方数的个数最少。\n12345678910111213141516171819202122class Solution(object):    def numSquares(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: int        &quot;&quot;&quot;        &quot;&quot;&quot;        四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。        推论：满足四数平方和定理的数n（四个整数的情况），必定满足 n=(4^a)(8b+7)        &quot;&quot;&quot;        while n % 4 == 0:            n /= 4        if n % 8 == 7:            return 4        a = 0        while a ** 2 &lt;= n:            b = int((n - a ** 2) ** 0.5)            if a ** 2 + b ** 2 == n:                return (not not a) + (not not b)            a += 1        return 3        \n\n\n01 矩阵给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n两个相邻元素间的距离为 1 。解法一。\n12345678910111213141516171819202122232425262728293031class Solution(object):    def updateMatrix(self, matrix):        &quot;&quot;&quot;        :type matrix: List[List[int]]        :rtype: List[List[int]]        &quot;&quot;&quot;        rows = len(matrix)        cols = len(matrix[0])        deltas = [            (1, 0 ), (-1, 0), (0, 1), (0, -1)        ]        unknown = set()        for r in range(rows):            for c in range(cols):                if matrix[r][c] == 1:                    unknown.add((r, c))                while unknown:            new_unknown = set()            for r, c in unknown:                for dr, dc in deltas:                    if 0 &lt;= dr + r &lt; rows and 0 &lt;= dc + c &lt; cols and (dr + r, dc + r) not in unkonwn:                        matrix[r][c] = matrix[dr + r][dc + c] + 1                        break                else:                    new_unknown.add((r, c))            unknown = new_unknown        return matrix\n我有骄傲吗？\n\n解法二。\n1234567891011121314151617181920212223242526272829import collectionsclass Solution(object):    def updateMatrix(self, matrix):        &quot;&quot;&quot;        :type matrix: List[List[int]]        :rtype: List[List[int]]        &quot;&quot;&quot;        rows = len(matrix)        cols = len(matrix[0])        deltas = [ (0, 1), (0, -1), (1, 0), (-1, 0)]        max_dist = rows + cols - 1        queue = collections.deque()        for r in range(rows):            for c in range(cols):                if matrix[r][c] == 1:                    matrix[r][c] = max_dist                else:                    queue.append((r, c))                while queue:            r, c = queue.popleft()            for dr, dc in deltas:                if 0 &lt;= dr + r &lt; rows and 0 &lt;= dc + c &lt; cols:                     if matrix[r][c] + 1 &lt; matrix[r + dr][c + dc]:                        matrix[dr + r][dc + c] = matrix[r][c] + 1                        queue.append((dr + r, dc + c))        return matrix                    \n\n栈栈是先入后出（LIFO）的数据结构。\n在LIFO数据结构中，将首先处理添加到队列中的最新元素。与队列不同，栈是一个LIFO数据结构。通常，插入操作在栈中被称作入栈（push）。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈（pop），始终删除最后一个入栈的元素。\n经典问题有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。\n有效字符串需满足：\n左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。\n123456789101112131415161718192021class Solution(object):    def isValid(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: bool        &quot;&quot;&quot;        if not s:            return True        stack = []        match = &#123;            &#x27;&#123;&#x27;: &#x27;&#125;&#x27;,            &#x27;[&#x27;: &#x27;]&#x27;,            &#x27;(&#x27;: &#x27;)&#x27;,        &#125;        for c in s:            if c in match:                stack.append(c)            else:                 if not stack or match[stack.pop()] != c:                    return False        return not stack\n\n每日温度请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用0来代替。\n例如，给定一个列表temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，输出应该是[1, 1, 4, 2, 1, 1, 0, 0]。\n提示：气温列表长度的范围是[1, 30000]。每个气温的值的均为华氏度，都是在[30, 100]范围内的整数。\n1234567891011121314class Solution(object):    def dailyTemperatures(self, T):        &quot;&quot;&quot;        :type T: List[int]        :rtype: List[int]        &quot;&quot;&quot;        stack = []        result = [0] * len(T)        for i, temp in enumerate(T):            while stack and T[stack[-1]] &lt; temp:                result[stack.pop()] = i - stack[-1]            stack.append(i)        return result        \n\n逆波兰表达式求值根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n说明：整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\n平常使用的算式则是一种中缀表达式，如( 1 + 2 ) * ( 3 + 4 )。该算式的逆波兰表达式写法为( ( 1 2 + ) ( 3 4 + ) * )。逆波兰表达式主要有以下两个优点：\n\n去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。\n适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。\n\n12345678910111213141516171819class Solution(object):    def evalRPN(self, tokens):        &quot;&quot;&quot;        :type tokens: List[str]        :rtype: int        &quot;&quot;&quot;        opts = &#123;            &#x27;+&#x27;: lambda x, y: x + y,            &#x27;-&#x27;: lambda x, y: y - x,            &#x27;*&#x27;: lambda x, y: x * y,            &#x27;/&#x27;: lambda x, y: int( y * 1.0 / x )        &#125;        stack = []        for c in tokens:            if c in opts:                stack.append(opts[c](stack.pop(),stack.pop()))            else:                stack.append(int(c))        return stack[-1]\n\n深度优先搜索查找从根结点到目标结点的路径时，结点的处理和添加完全相反的顺序，后进先出，这就是DFS中使用栈的原因。\n模板一 递归1234567891011121314def neighbors(cur):    return []def DFS(cur, target, visited):    if cur == target:        return True    for next_node in neighbors(cur):        if next_node not in visited:            visited.add(next_node)            if DFS(next_node, target, visited):                return True    return False\n\n当我们递归地实现DFS时，似乎不需要使用任何栈。但实际上，我们使用的是由系统提供的隐式栈，也称为调用栈（Call Stack）。在最坏的情况下，维护系统栈需要O(h)，其中h是DFS的最大深度。\n\n\n\n岛屿数量一个由’1’（陆地）和’0’（水）组成的的二维网格，计算网格中岛屿的数量。\n岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，可以假设该网格的四条边均被水包围。\n1234567891011121314151617181920212223242526272829class Solution(object):    def numIslands(self, grid):        &quot;&quot;&quot;        :type grid: List[List[str]]        :rtype: int        &quot;&quot;&quot;        if not grid:            return 0        rows = len(grid)        cols = len(grid[0])        islands = 0        for r in range(rows):            for c in range(cols):                if grid[r][c] == &#x27;1&#x27;:                    islands += 1                    self.set_island(r, c, grid)        return islands        def set_island(self, row, col, grid):        if row &gt;= len(grid) or row &lt; 0 or col &gt;= len(grid[0]) or col &lt; 0:            return        if grid[row][col] == &#x27;0&#x27;:            return        grid[row][col] = &#x27;0&#x27;        self.set_island(row + 1, col, grid)        self.set_island(row - 1, col, grid)        self.set_island(row, col + 1, grid)        self.set_island(row, col - 1, grid)\n\n克隆图给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。\n图中的每个节点都包含它的值val（int）和其邻居的列表（list[Node]）。\n&gt;&gt;&gt;&gt; 传送门 &lt;&lt;&lt;&lt;\n123456789101112131415161718192021222324252627282930class Node(object):    def __init__(self, val=0, neighbors=[]):        self.val = val        self.neighbors = neighborsclass Solution(object):    def cloneGraph(self, node):        &quot;&quot;&quot;        :type node: Node        :rtype: Node        &quot;&quot;&quot;        if not node:            return None                cloned = Node(node.val, neighbors=[])        stack = [node]        mapping = &#123; node: cloned &#125;        while stack:            node = stack.pop()            cloned_node = mapping[node]            for neighbor in node.neighbors:                if neighbor not in mapping:                    cloned_neighbor = Node(neighbor.val, neighbors=[])                    mapping[neighbor] = cloned_neighbor                    stack.append(neighbor)                else:                    cloned_neighbor = mapping[neighbor]                cloned_node.neighbors.append(cloned_neighbor)        return cloned\n\n\n目标和给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n&gt;&gt;&gt;&gt; 传送门 &lt;&lt;&lt;&lt;\n思路一， 递归：使用递归，枚举出所有可能出现的情况，在处理到i个的数的时候，我们可以选择将它添加或者减除。当处理完nums列表时，计算出所有数的和，和目标数S进行判断。添加一个字典d，用于存储递归时出现的情况，d的key是（current，i），value是从起，到最后一个数，初始值是current时，目标值是S时，所能找到的所有的方法使得最后的数值等于S。\n\n\n思路二， 01背包：将这个数组nums看做成两部分，使用+的集合x，和使用-的集合y，则有sum(x) + sum(y) = sum(nums)，而且sum(x) - sum(y) = S，所以sum(x) = (sum(nums) + S) // 2。就可以看成，已知一个数组，求有多少种方法，将容量为sum(x)的背包填满的问题了。\ndp[0]为什么默认为1，因为当背包容量为0时，不需要任何操作就可以填满背包，可行解为1。\n\n\n12345678910111213141516171819202122232425262728293031class Solution(object):    # 递归    def findTargetSumWays(self, nums, S):        &quot;&quot;&quot;        :type nums: List[int]        :type S: int        :rtype: int        &quot;&quot;&quot;        def dfs(current, i, d):            if i &lt; len(nums) and (current, i) not in d:                d[(current, i)] = dfs(current + nums[i], i + 1, d) + dfs(current - nums[i], i + 1, d)            return d.get((current, i), int(current == S))        return dfs(0, 0, &#123;&#125;)    # 01背包    def findTargetSumWays_2(self, nums, S):        &quot;&quot;&quot;        :type nums: List[int]        :type S: int        :rtype: int        &quot;&quot;&quot;        if sum(nums) &lt; S or (sum(nums) + S ) % 2 == 1:            return 0        half = (sum(nums) + S) // 2        dp = [1] + [0 for _ in range(half)]        for num in nums:            for i in range(half, num - 1, -1):                # i代表背包容量                # i - num 代表将num放进背包                dp[i] += dp[i - num]        return dp[half]\n\n模板二 栈显式的栈。\n1234567891011121314151617def neighbors(cur):    return []def DFS(root, target):    visited = set()    # add root to stack    stack = [root]    while stack:        cur = stack.pop()        if cur == target:            return True        for node in neighbors(cur):            if node not in visited:                stack.append(node)                visited.add(node)    return False\n\n二叉树的中序遍历12345678910111213141516171819202122232425262728# Definition for a binary tree node.class TreeNode(object):    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution(object):    def inorderTraversal(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        stack = []        result = []        while root:            stack.append(root)            root = root.left        while stack:            node = stack.pop()            result.append(node.val)            if node.right:                node = node.right                while node:                    stack.append(node)                    node = node.left        return result\n\n练习字符串解码给定一个经过编码的字符串，返回它解码后的字符串。\n编码规则为: k[encoded_string]，表示其中方括号内部的encoded_string正好重复k次。注意k保证为正整数。\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n此外，可以认为原始数据不包含数字，所有的数字只表示重复的次数k，例如不会出现像3a或2[4]的输入。\n123456789101112131415161718192021222324class Solution(object):    def decodeString(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: str        &quot;&quot;&quot;        if not s:            return &#x27;&#x27;        stack = []        result = &#x27;&#x27;        multi = 0        for c in s:            if c == &#x27;[&#x27;:                stack.append((multi, result))                result = &#x27;&#x27;                multi = 0            elif c == &#x27;]&#x27;:                m, res = stack.pop()                result = res + m * result            elif &#x27;0&#x27; &lt;= c &lt;= &#x27;9&#x27;:                multi = 10 * multi + int(c)            esle:                result += c        return result\n\n图像渲染有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在0到65535之间。\n给一个坐标(sr, sc)表示图像渲染开始的像素值（行 ，列）和一个新的颜色值newColor，重新上色这幅图像。\n为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。\n最后返回经过上色渲染后的图像。\n12345678910111213141516171819202122232425262728class Solution(object):    def floodFill(self, image, sr, sc, newColor):        &quot;&quot;&quot;        :type image: List[List[int]]        :type sr: int        :type sc: int        :type newColor: int        :rtype: List[List[int]]        &quot;&quot;&quot;        old_Color = image[sr][sc]        if old_Color == newColor:            return image                rows = len(image)        cols = len(images)        def bfs(row, col, image):            if row &gt;= rows or col &gt;= cols or row &lt; 0 or col &lt; 0:                return            if image[row][col] != old_color or image[row][col] == newColor:                return            image[row][col] = newColor            bfs(row + 1, col, image)            bfs(row - 1, col, image)            bfs(row, col + 1, image)            bfs(row, col - 1, image)        bfs(sr, sc, image)        return image\n\n钥匙和房间有 N 个房间，开始时你位于0号房间。每个房间有不同的号码：0，1，2，…，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。\n在形式上，对于每个房间i都有一个钥匙列表rooms[i]，每个钥匙rooms[i][j]由[0,1，…，N-1]中的一个整数表示，其中N = rooms.length。钥匙rooms[i][j] = v可以打开编号为v的房间。\n最初，除0号房间外的其余所有房间都被锁住。\n你可以自由地在房间之间来回走动。如果能进入每个房间返回true，否则返回false。\n1234567891011121314151617class Solution(object):    def canVisitAllRooms(self, rooms):        &quot;&quot;&quot;        :type rooms: List[List[int]]        :rtype: bool        &quot;&quot;&quot;        seen = [False] * len(rooms)        seen[0] = True        stack = [0]        while stack:            node = stack.pop()            for neighbor in rooms[node]:                if not seen[neighbor]:                    seen[neighbor] = True                    stack.append(neighbor)        return all(seen)\n\n二叉树树是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。\n树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N个节点和N-1条边的一个有向无环图。\n二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。\n节点的深度 - 从树的根节点到该节点的边数节点的高度 - 该节点和叶子之间最长路径上的边数树的高度 - 其根节点的高度\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142class TreeNode(object):    def __init__(self, x):        self.val = x        self.left = None        self.right = None    def __repr__(self):        # 输出前序遍历        nodes = []        def preorder(node):            if not node:                nodes.append(&#x27;None&#x27;)            else:                nodes.append(str(node.val))                preorder(node.left)                preorder(node.right)        preorder(self)        return &#x27;, &#x27;.join(nodes)    @classmethod    def generate(cls, nums):        &quot;&quot;&quot;        :param nums: 前序遍历        :type nums: list        :rtype: TreeNode        &quot;&quot;&quot;        nodes = deque(nums)        def build():            if not nodes:                return None            node = nodes.popleft()            if node is None:                return None            node = TreeNode(node)            node.left = build()            node.right = build()            return node        return build()\n\n二叉树的遍历前序遍历前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。\n中序遍历中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。\n后序遍历后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。\n\n\n前序遍历12345678910111213141516171819202122232425262728293031class Solution(object):    # 迭代    def preorderTraversal(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        if not root:            return []        result = []        stack = [root]        while stack:            node = stack.pop()            result.append(node.val)            if node.right:                stack.append(node.right)            if node.left:                stack.append(node.left)        return result    # 递归    def postorderTraversal2(self, root):        result = []        self.dfs(root, result)        return result        def dfs(self, node, result):        if not node:                return        result.append(node.val)        self.dfs(node.left, result)        self.dfs(node.right, result)\n\n中序遍历123456789101112131415161718192021222324252627282930313233343536373839class Solution(object):    def inorderTraversal(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        if not root:            return []        stack = []        result = []        while root:            stack.append(root)            root = root.left        while stack:            node = stack.pop()            result.append(node.val)            if node.right:                node = node.right                while node:                    stack.append(node)                    node = node.left        return result    def inorderTraversal2(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        result = []        self.dfs(root, result)        return result        def dfs(self, node, result):        if not node:            return        self.dfs(node.left, result)        result.append(node.val)        self.dfs(node.right, result)\n\n后序遍历12345678910111213141516171819202122232425262728293031323334353637import collectionsclass Solution(object):    def postorderTraversal(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        if not root:            return []        result = collections.deque()        stack = [root]        while stack:            node = stack.pop()            result.appendleft(node.val)            if node.left:                stack.append(node.left)            if node.right:                stack.append(node.right)        return result    def postorderTraversal2(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        result = []        self.dfs(root, result)        return result        def dfs(self, node, result):        if not node:            return        self.dfs(node.left, result)        self.dfs(node.right, result)        result.append(node.val)\n\n二叉树的层序遍历给一个二叉树，返回其按层序遍历得到的节点值。（即逐层地，从左到右访问所有节点）。\n12345678910111213141516171819202122class Solution(object):    def levelOrder(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[List[int]]        &quot;&quot;&quot;        if not root:            return []        result = []        nodes = [root]        while nodes:            new_nodes = []            result.append([])            for node in nodes:                result[-1].append(node.val)                if node.left:                    new_nodes.append(node.left)                if node.right:                    new_nodes.append(node.right)            nodes = new_nodes        return result\n\n练习二叉树的最大深度给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n12345678910class Solution(object):    def maxDepth(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        if not root:            return 0        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n对称二叉树给定一个二叉树，检查它是否是镜像对称的。\n1234567891011121314151617181920212223242526272829303132333435363738class Solution(object):    def isSymmetric(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        if not root:            return True        return self.dfs(root.left, root.right)        def dfs(self, left_node, right_node):        if not left_node and not right_node:            return True        if not left_node or not right_node:            return False        if left_node.val != right_node.val:            return False        return self.dfs(left_node.left, right_node.right) and self.dfs(left_node.right, right_node.left)        def isSymmetric2(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        if not root:            return True        queue = collections.dequeue([(root.left, root.right)])        while queue:            l, r = queue.popleft()            if not l and not r:                continue            if not l or not r or l.val != r.val:                return False            queue.append((l.left, r.right))            queue.append((l.right, r.left))        return True    \n\n路径总和给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n说明: 叶子节点是指没有子节点的节点。\n1234567891011121314class Solution(object):    def hasPathSum(self, root, sum):        &quot;&quot;&quot;        :type root: TreeNode        :type sum: int        :rtype: bool        &quot;&quot;&quot;        if not root:            return False        sum -= root.val        if sum == 0 and not root.left and not root.right:            return True        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\n\n从中序与后序遍历序列构造二叉树根据一棵树的中序遍历与后序遍历构造二叉树。\n123456789101112131415161718192021222324class TreeNode(object):    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution(object):    def buildTree(self, inorder, postorder):        &quot;&quot;&quot;        :type inorder: List[int]        :type postorder: List[int]        :rtype: TreeNode        &quot;&quot;&quot;        if len(inorder) == 0:            return None        index = inorder.index(postorder.pop())        root = TreeNode(inorder[index])        root.right = self.buildTree(inorder[index + 1:], postorder)        root.left = self.buildTree(inorder[:index], postorder)        return root\n\n从前序与中序遍历序列构造二叉树根据一棵树的前序遍历与中序遍历构造二叉树。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445class TreeNode(object):    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution(object):    def buildTree(self, preorder, inorder):        &quot;&quot;&quot;        :type preorder: List[int]        :type inorder: List[int]        :rtype: TreeNode        &quot;&quot;&quot;        if len(inorder) == 0:            return None        root = TreeNode(preorder[0])        index = inorder.index(preorder[0])        root.left = self.buildTree(preorder[1:index + 1], inorder[:index])        root.right = self.buildTree(preorder[index + 1:], inorder[index + 1:])        return root        def buildTree2(self, preorder, inorder):        &quot;&quot;&quot;        :type preorder: List[int]        :type inorder: List[int]        :rtype: TreeNode        &quot;&quot;&quot;        def build(stop=None):            if not inorder or inorder[-1] == stop:                return None            val = preorder.pop()            root = TreeNode(val)            root.left = build(val)            inorder.pop()            root.right = build(stop)            return root                            preorder.reverse()        inorder.reverse()        return build()\n\n填充每个节点的下一个右侧节点指针给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n完美二叉树。一个深度为k(&gt;=-1)且有2^(k+1) - 1个结点的二叉树称为完美二叉树，换句话说：树是满的，还是二叉的。\n\n\n123456class Node:  val = int  left = Node  right = Node  next = Node\n填充它的每个next指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将next指针设置为NULL。\n初始状态下，所有next指针都被设置为NULL。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445class Node(object):    def __init__(self, val=0, left=None, right=None, next=None):        self.val = val        self.left = left        self.right = right        self.next = nextclass Solution(object):    def connect(self, root):        &quot;&quot;&quot;        :type root: Node        :rtype: Node        &quot;&quot;&quot;        if not root:            return None        level = [root]        while level and level[0]:            next_level = []            prev = None            for node in level:                if prev:                    prev.next = node                prev = node                level.append(node.left)                level.append(node.right)            level = next_level        return root        def connect2(self, root):        &quot;&quot;&quot;        :type root: Node        :rtype: Node        &quot;&quot;&quot;        if not root:            return        if root.left:            root.left.next = root.right            if root.next:                root.right.next = root.next.left        self.connect2(root.left)        self.connect2(root.right)        return root\n\n填充每个节点的下一个右侧节点指针 II给定一个二叉树\n123456class Node:  val = int  left = Node  right = Node  next = Node\n\n填充它的每个next指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将next指针设置为NULL。\n初始状态下，所有next指针都被设置为 NULL。\n1234567891011121314151617181920212223242526272829303132class Node(object):    def __init__(self, val=0, left=None, right=None, next=None):        self.val = val        self.left = left        self.right = right        self.next = nextclass Solution(object):    def connect(self, root):        &quot;&quot;&quot;        :type root: Node        :rtype: Node        &quot;&quot;&quot;        if not root:            return None        level = [root]        while level:            next_level = []            prev = None            for node in level:                if prev:                    prev.next = node                prev = node                if node.left:                    next_level.append(node.left)                if node.right:                    next_level.append(node.right)            level = next_level        return root\n\n二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n最近公共祖先对于有根树T的两个结点p、q，最近公共祖先表示为一个结点x，满足x是p、q的祖先且x的深度尽可能大（一个节点也可以是它自己的祖先）。\n\n\n123456789101112131415161718class Solution(object):    def lowestCommonAncestor(self, root, p, q):        &quot;&quot;&quot;        :type root: TreeNode        :type p: TreeNode        :type q: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        if not root or p == root or q == root:            return root        left = self.lowestCommonAncestor(root.left, p, q)        right = self.lowestCommonAncestor(root.right, p, q)        if left and right:            return root        return left or right\n\n二叉树的序列化与反序列化序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n设计一个算法来实现二叉树的序列化与反序列化。这里不限定序列/反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n12345678910111213141516171819202122232425262728293031323334353637383940414243import collectionsclass Solution(object):    def serialize(self, root):        &quot;&quot;&quot;Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        &quot;&quot;&quot;        nodes = []        def preorder(node):            if not node:                nodes.append(&#x27;null&#x27;)            else:                nodes.append(str(node.val))                preorder(node.left)                preorder(node.right)                preorder(root)        return &#x27;,&#x27;.join(nodes)        def deserialize(self, data):        &quot;&quot;&quot;Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        &quot;&quot;&quot;        nodes = collections.deque(data.split(&#x27;,&#x27;))        def build()            if not nodes:                return None            node = nodes.popleft()            if node == &#x27;null&#x27;:                return None            node = TreeNode(node)            node.left = build()            node.right = build()            return node        return build()\n\n二叉搜索树简介123456class TreeNode(object):    def __init__(self, x):        self.val = x        self.left = None        self.right = None\n\n二叉搜索树（BST）是二叉树的一种特殊表示形式，它满足如下特性：\n每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值。每个节点中的值必须小于（或等于）存储在其右子树中的任何值。\n验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。\n123456789101112131415class Solution(object):    def isValidBST(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        return self.valid(root, float(&#x27;-inf&#x27;), float(&#x27;inf&#x27;))        def valid(self, node, l, r):        if not node:            return True        if node.val &lt;= l or r &lt;= node.val:            return False        return self.valid(node.left, l, node.val) and self.valid(node.right, node.val, r)\n\n二叉搜索树迭代器实现一个二叉搜索树迭代器。使用二叉搜索树的根节点初始化迭代器。\n调用next()将返回二叉搜索树中的下一个最小的数。\n12345678910111213141516171819202122232425262728293031323334class BSTIterator(object):    def __init__(self, root):        &quot;&quot;&quot;        :type root: TreeNode        &quot;&quot;&quot;        self.stack = []        while root:             self.stack.append(root)            root = root.left    def next(self):        &quot;&quot;&quot;        @return the next smallest number        :rtype: int        &quot;&quot;&quot;        node = self.stack()        result = node.val        if node.right:            node = node.right            while node:                self.stack.append(node)                node = node.left        return result    def hasNext(self):        &quot;&quot;&quot;        @return whether we have a next smallest number        :rtype: bool        &quot;&quot;&quot;        return True if self.stack else False\n\n操作搜索给定二叉搜索树（BST）的根节点和一个值。需要在BST中找到节点值等于给定值的节点。返回以该节点为根的子树。如果节点不存在，则返回NULL。\n12345678910111213141516171819202122232425262728293031class Solution(object):    def searchBST(self, root, val):        &quot;&quot;&quot;        :type root: TreeNode        :type val: int        :rtype: TreeNode        &quot;&quot;&quot;        if not root or root.val == val:            return root        if root.val &lt; val:            return self.searchBST(root.right, val)        else:            return self.searchBST(root.left, val)        def searchBST2(self, root, val):        &quot;&quot;&quot;        :type root: TreeNode        :type val: int        :rtype: TreeNode        &quot;&quot;&quot;        if not root:            return None        while root:            if root.val == val:                return root            elif root.val &lt; val:                root = root.right            else:                root = root.left        return None            \n\n插入给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。返回插入后二叉搜索树的根节点。保证原始二叉搜索树中不存在新值。\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。可以返回任意有效的结果。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344class TreeNode(object):    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def insertIntoBST(self, root, val):        &quot;&quot;&quot;        :type root: TreeNode        :type val: int        :rtype: TreeNode        &quot;&quot;&quot;        node = TreeNode(val)        if not root:            return node        result = root        while True:            if val &lt; root.val:                if not root.left:                    root.left = node                    return result                root = root.left            else:                if not root.right:                    root.right = node                    return result                root = root.right    def insertIntoBST2(self, root, val):        &quot;&quot;&quot;        :type root: TreeNode        :type val: int        :rtype: TreeNode        &quot;&quot;&quot;        if not root:            return TreeNode(val)        if val &lt; root.val:            root.left = self.insertIntoBST2(root.left, val)        else:            root.right = self.insertIntoBST2(root.right, val)        return root\n\n删除用一个合适的子节点来替换要删除的目标节点。根据其子节点的个数，需考虑以下三种情况：1. 如果目标节点没有子节点，可以直接移除该目标节点。2. 如果目标节只有一个子节点，可以用其子节点作为替换。3. 如果目标节点有两个子节点，要用其中序后继节点或者前驱节点来替换，再删除该目标节点。\n12345678910111213141516171819202122232425262728293031class TreeNode(object):    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def deleteNode(self, root, key):        &quot;&quot;&quot;        :type root: TreeNode        :type key: int        :rtype: TreeNode        &quot;&quot;&quot;        if not root:            return None        if key &gt; root.val:            root.right = self.deleteNode(root.right, key)        elif key &lt; root.val:            root.left = self.deleteNode(root.left, key)        else:            if not(root.left and root.right):                root = root.left or root.right            else:                next_right = root.right                while next_right.left:                    next_right = next_right.left                root.val = next_right.val                root.right = self.deleteNode(root.right, root.val)        return root\n小结二叉搜索树的优点是，即便在最坏的情况下，也允许在O(h)的时间复杂度内执行所有的搜索、插入、删除操作。\n有序地存储数据或者需要同时执行搜索、插入、删除等多步操作，二叉搜索树这个数据结构是一个很好的选择。\n练习数据流中的第K大元素设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。\nKthLargest类需要一个同时接收整数k和整数数组nums的构造器，它包含数据流中的初始元素。每次调用KthLargest.add，返回当前数据流中第K大的元素。\n12345678910111213141516171819202122232425262728import heapqclass KthLargest(object):    def __init__(self, k, nums):        &quot;&quot;&quot;        :type k: int        :type nums: List[int]        &quot;&quot;&quot;        heapq.heapfiy(nums)        while len(nums) &gt; k:            heapq.heappop(nums)        self.k = k        self.nums = nums    def add(self, val):        &quot;&quot;&quot;        :type val: int        :rtype: int        &quot;&quot;&quot;        if len(self.nums) == self.k and val &lt;= self.nums[0]:            return self.nums[0]        heapq.heappush(self.nums, val)        if len(self.nums) &gt; self.k:            heapq.heappop(self.nums)        return self.nums[0]\n\n二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n最近公共祖先对于有根树T的两个结点p、q，最近公共祖先表示为一个结点x，满足x是p、q的祖先且x的深度尽可能大（一个节点也可以是它自己的祖先）。\n\n\n1234567891011121314class Solution(object):    def lowestCommonAncestor(self, root, p, q):        &quot;&quot;&quot;        :type root: TreeNode        :type p: TreeNode        :type q: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        if q.val &gt; root.val and p.val &gt; root.val:            return self.lowestCommonAncestor(root.right, p, q)        if q.val &lt; root.val and p.val &lt; root.val:            return self.lowestCommonAncestor(root.left, p, q)        return root\n\n存在重复元素 III在整数数组nums中，是否存在两个下标i和j，使得nums[i]和nums[j]的差的绝对值小于等于t ，且满足i和j的差的绝对值也小于等于k。\n如果存在则返回true，不存在返回false。\n1234567891011121314151617181920212223242526class Solution(object):    def containsNearbyAlmostDuplicate(self, nums, k, t):        &quot;&quot;&quot;        :type nums: List[int]        :type k: int        :type t: int        :rtype: bool        &quot;&quot;&quot;        if k &lt; 0 or t &lt; 0:            return False        buckets = &#123;&#125;        bucket_size = t + 1        for i in range(len(nums)):            num = nums[i] // bucket_size            if num in buckets:                return True            buckets[num] = nums[i]            if (num - 1) in buckets and abs(buckets[num - 1] - num[i]) &lt;= t:                return True            if (num + 1) in buckets and abs(buckets[num + 1] - num[i]) &lt;= t:                return True            if i &gt;= k:                buckets.pop(num[i-k] // bucket_size)        return False\n\n高度平衡的二叉搜索树一个高度平衡的二叉搜索树（平衡二叉搜索树）是在插入和删除任何节点之后，可以自动保持其高度最小。也就是说，有N个节点的平衡二叉搜索树，它的高度是logN。并且，每个节点的两个子树的高度不会相差超过1。\n一个高度为h的二叉树，节点数为：\n\n\n一个有N个节点，且高度为h的二叉树，满足：\n\n\n所以，\n\n\n判断平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。\n12345678910111213141516171819class Solution(object):    def isBalanced(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        return self.balanced(root) != -1        def balanced(self, node):        if not node:            return 0        left = self.balanced(node.left)        right = self.balanced(node.right)        if left == -1 or right == -1 or abs(left - right) &gt; 1:            return -1        return 1 + max(left, right)\n\n将有序数组转换为二叉搜索树将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\n本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。\n12345678910111213141516171819202122232425class TreeNode(object):    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution(object):    def sortedArrayToBST(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: TreeNode        &quot;&quot;&quot;        return self.convert(nums, 0, len(nums) - 1)        def convert(self, nums, left, right):        if left &gt; right:            return None        mid = (left + right) // 2        root = TreeNode(nums[mid])        root.left = self.convert(left, mid - 1)        root.right = self.convert(mid + 1, right)        return root","dateCreated":"2020-08-25T12:02:41+08:00","dateModified":"2023-09-21T10:45:00+08:00","datePublished":"2020-08-25T12:02:41+08:00","description":"数据结构","headline":"数据结构","image":[null,"images/PROJECT-Vayne.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},"publisher":{"@type":"Organization","name":"Wang kuntian","sameAs":["https://github.com/wangkuntian","mailto:wangkuntian1994@163.com"],"image":"faker.jpg","logo":{"@type":"ImageObject","url":"faker.jpg"}},"url":"https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","keywords":"数据结构","thumbnailUrl":"images/PROJECT-Vayne.jpg"}</script>
    <meta name="description" content="数据结构">
<meta property="og:type" content="blog">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Wang kuntian&#39;s Blog">
<meta property="og:description" content="数据结构">
<meta property="og:locale" content="zh_EN">
<meta property="og:image" content="https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/images/linked_list.png">
<meta property="og:image" content="https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/images/queue.png">
<meta property="og:image" content="https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/images/cut.png">
<meta property="article:published_time" content="2020-08-25T04:02:41.000Z">
<meta property="article:modified_time" content="2023-09-21T02:45:00.323Z">
<meta property="article:author" content="Wang kuntian">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/images/linked_list.png">
    
    
        
    
    
        <meta property="og:image" content="https://wangkuntian.github.io/assets/images/faker.jpg"/>
    
    
    
        <meta property="og:image" content="https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/images/PROJECT-Vayne.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/images/PROJECT-Vayne.jpg"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-bkzaqwnhdy35ne9gawopbfxp7lltc7yhde0uckf6kikurfjo9ztq2v5apuqa.min.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136102260-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-136102260-1');
    </script>


    

    
        
    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Wang kuntian&#39;s Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/faker.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/faker.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Wang kuntian</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Hi</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/wangkuntian"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:wangkuntian1994@163.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full"
             style="background-image:url('/images/PROJECT-Vayne.jpg');"
             data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            数据结构
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-08-25T12:02:41+08:00">
	
		    Aug 25, 2020
    	
    </time>
    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-text">设计链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="toc-text">判断是否有环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-text">相交链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">删除倒数第N个节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-text">经典问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-text">移除链表元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8"><span class="toc-text">奇偶链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">回文链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-text">双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-1"><span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-1"><span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E7%85%A7"><span class="toc-text">时间复杂度对照</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-text">合并两个有序的链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-text">两数相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">旋转链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-text">循环队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1"><span class="toc-text">设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97"><span class="toc-text">Python中的队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">广度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-text">岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81"><span class="toc-text">打开转盘锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">完全平方数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E7%9F%A9%E9%98%B5"><span class="toc-text">01 矩阵</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-1"><span class="toc-text">经典问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-text">每日温度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">逆波兰表达式求值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%80-%E9%80%92%E5%BD%92"><span class="toc-text">模板一 递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-1"><span class="toc-text">岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8B%E9%9A%86%E5%9B%BE"><span class="toc-text">克隆图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text">目标和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%BA%8C-%E6%A0%88"><span class="toc-text">模板二 栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的中序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1"><span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-text">字符串解码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93"><span class="toc-text">图像渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4"><span class="toc-text">钥匙和房间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-2"><span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">对称二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">路径总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-text">填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II"><span class="toc-text">填充每个节点的下一个右侧节点指针 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">二叉树的序列化与反序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">二叉搜索树迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-text">操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-text">搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-2"><span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-2"><span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-3"><span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-text">数据流中的第K大元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-III"><span class="toc-text">存在重复元素 III</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">高度平衡的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">判断平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">将有序数组转换为二叉搜索树</span></a></li></ol></li></ol></li></ol>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表分为单（向）链表和双（向）链表。顾名思义，单链表就是单一方向遍历的链表结构，双链表就是双向遍历的链表结构。</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>在python中可以这么定义单链表节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        temp = self</span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> temp:</span><br><span class="line">            s += <span class="built_in">str</span>(temp.val) + <span class="string">&#x27; ---&gt; &#x27;</span></span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        s += <span class="string">&#x27;None&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">cls, nums</span>):</span><br><span class="line">        result = temp = ListNode(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            temp.<span class="built_in">next</span> = ListNode(i)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<div class="alert info no-icon"><p>链表长度为n时，遍历的时间复杂度是O(n)，插入的时间复杂度是O(1), 删除的时间复杂度是O(n)。</p>
</div>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>在链表之间插入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l1 = ListNode(<span class="number">1</span>)</span><br><span class="line">l2 = ListNode(<span class="number">2</span>)</span><br><span class="line">l1.<span class="built_in">next</span> = l2</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 -&gt;  2 -&gt; None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>现在有个一新的节点l3，将它插入到链表中我们只要。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l3 = ListNode(<span class="number">3</span>)</span><br><span class="line">l3.<span class="built_in">next</span> = l2</span><br><span class="line">l1.<span class="built_in">next</span> = l3</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 -&gt; 3 -&gt; 2 -&gt; None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在链表前或者末尾插入，都是比较简单的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链表前</span></span><br><span class="line">l4 = ListNode(<span class="number">4</span>)</span><br><span class="line">l4.<span class="built_in">next</span> = l1</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 链表后</span></span><br><span class="line">l5 = ListNode(<span class="number">5</span>)</span><br><span class="line">l2.<span class="built_in">next</span> = l5</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">l5 = ListNode(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> l1.<span class="built_in">next</span>:</span><br><span class="line">    l1 = l1.<span class="built_in">next</span></span><br><span class="line">l1.<span class="built_in">next</span> = l5</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l1 = ListNode(<span class="number">1</span>)</span><br><span class="line">l2 = ListNode(<span class="number">2</span>)</span><br><span class="line">l3 = ListNode(<span class="number">3</span>)</span><br><span class="line">l1.<span class="built_in">next</span> = l2   </span><br><span class="line">l2.<span class="built_in">next</span> = l3</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 -&gt; 2 -&gt; 3 -&gt; None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>    </span><br></pre></td></tr></table></figure>
<p>删除l2可以这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1.<span class="built_in">next</span> = l3</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 -&gt; 3 -&gt; None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>    </span><br></pre></td></tr></table></figure>
<p>删除结点的时间复杂度是O(n)，空间复杂度为O(1)。</p>
<h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.length:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        head = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(self.length, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.length:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">        node = ListNode(val)</span><br><span class="line">        head = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        node.<span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = node</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.length <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        head = self.head</span><br><span class="line">        <span class="keyword">while</span> index:</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">linkedList = MyLinkedList()</span><br><span class="line">linkedList.addAtHead(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(linkedList.head)</span><br><span class="line">linkedList.addAtTail(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(linkedList.head)</span><br><span class="line">linkedList.addAtIndex(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(linkedList.head)</span><br><span class="line"><span class="built_in">print</span>(linkedList.get(<span class="number">1</span>))</span><br><span class="line">linkedList.deleteAtIndex(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(linkedList.head)</span><br><span class="line"><span class="built_in">print</span>(linkedList.get(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="判断是否有环"><a href="#判断是否有环" class="headerlink" title="判断是否有环"></a>判断是否有环</h3><p>给定一个链表，判断链表中是否有环，返回链表开始入环的第一个节点。</p>
<div class="alert info no-icon"><p>思路：<br>定义两个指针，一个走的快，一个走的慢。如果链表中存在环，那么快指针肯定会再次追上慢指针（套圈）。<br>两个指针相遇的点记作点A。再定义一个指针再从链表头出发，慢指针从点A出发，它们相遇的地方记作点B。<br>点B就是链表开始入环的第一个节点。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                fast = head</span><br><span class="line">                <span class="keyword">while</span> fast != slow:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> slow</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l0 = ListNode(<span class="number">0</span>)</span><br><span class="line">l1 = ListNode(<span class="number">1</span>)</span><br><span class="line">l2 = ListNode(<span class="number">2</span>)</span><br><span class="line">l3 = ListNode(<span class="number">3</span>)</span><br><span class="line">l4 = ListNode(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">l0.<span class="built_in">next</span> = l1</span><br><span class="line">l1.<span class="built_in">next</span> = l2</span><br><span class="line">l2.<span class="built_in">next</span> = l3</span><br><span class="line">l3.<span class="built_in">next</span> = l4</span><br><span class="line">l4.<span class="built_in">next</span> = l1</span><br><span class="line"></span><br><span class="line">s = Solution().detectCycle(l0)</span><br><span class="line"><span class="built_in">print</span>(s.val)</span><br></pre></td></tr></table></figure>

<h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><p>找到两个单链表相交的起始节点。</p>
<div class="alert info no-icon"><p>思路：<br>x + y = y + x。同时遍历两个条链表，短的链表先遍历完，再将它和长的链表相接也就是x + y。同理长的链表遍历完的时候，再将它和短的链表相接也就是y + x。这样一来，就解决了遍历时两条链表长度不一致的问题。遍历过程中，节点相同的就是交点。</p>
<p>两条链表没有交点的情况也同样适用。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        x = headA</span><br><span class="line">        y = headB</span><br><span class="line">        <span class="keyword">while</span> x != y:</span><br><span class="line">            x = x.<span class="built_in">next</span> <span class="keyword">if</span> x <span class="keyword">else</span> headB</span><br><span class="line">            y = y.<span class="built_in">next</span> <span class="keyword">if</span> y <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">l1 = ListNode(<span class="number">4</span>)</span><br><span class="line">l2 = ListNode(<span class="number">1</span>)</span><br><span class="line">l3 = ListNode(<span class="number">8</span>)</span><br><span class="line">l4 = ListNode(<span class="number">4</span>)</span><br><span class="line">l5 = ListNode(<span class="number">5</span>)</span><br><span class="line">l1.<span class="built_in">next</span> = l2</span><br><span class="line">l2.<span class="built_in">next</span> = l3</span><br><span class="line">l3.<span class="built_in">next</span> = l4</span><br><span class="line">l4.<span class="built_in">next</span> = l5</span><br><span class="line"></span><br><span class="line">l6 = ListNode(<span class="number">5</span>)</span><br><span class="line">l7 = ListNode(<span class="number">0</span>)</span><br><span class="line">l8 = ListNode(<span class="number">1</span>)</span><br><span class="line">l6.<span class="built_in">next</span> = l7</span><br><span class="line">l7.<span class="built_in">next</span> = l8</span><br><span class="line">l8.<span class="built_in">next</span> = l3</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Solution().getIntersectionNode(l1, l6))</span><br></pre></td></tr></table></figure>

<h3 id="删除倒数第N个节点"><a href="#删除倒数第N个节点" class="headerlink" title="删除倒数第N个节点"></a>删除倒数第N个节点</h3><p>删除链表的倒数第n个节点，并且返回链表的头结点。n保证是有效值。</p>
<div class="alert info no-icon"><p>思路：<br>定义两个指针，一个负责定位删除的元素的指针x，一个负责辅助定位的指针y。<br>先让y指针走n步，再让x和y，同时遍历。当y指向链表的最后一项时，x刚好指向要删除的元素的前一项。这样可以利用x.next = x.next.next删除x的下一项。</p>
<p>有一个情况需要考虑到，就是指针y走n步后，y已经为空，也就是n == 链表的长度，也就是要删除第一个数，结果直接返回head.next即可。</p>
</div>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        x = y = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            y = y.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> y:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> y.<span class="built_in">next</span>:</span><br><span class="line">            y = y.<span class="built_in">next</span></span><br><span class="line">            x = x.<span class="built_in">next</span></span><br><span class="line">        x.<span class="built_in">next</span> = x.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">l = ListNode.generate([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(Solution().removeNthFromEnd(l, <span class="number">2</span>))</span><br><span class="line">l = ListNode.generate([<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(Solution().removeNthFromEnd(l, <span class="number">1</span>))</span><br><span class="line">l = ListNode.generate([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(Solution().removeNthFromEnd(l, <span class="number">1</span>))</span><br><span class="line">l = ListNode.generate([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(Solution().removeNthFromEnd(l, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>反转一个链表。</p>
<div class="alert info no-icon"><p>思路一：<br>双指针解法。定义一个指针result，配合参数head组成双指针。result必须先设为None。<br>随后遍历head。遍历head时，注意要记录一下head.next的值，这里定义一个temp来接收它。<br>然后就是反转。<br>head.next = result 把head下一个指向result，<br>result = head 同时更新一下result的位置，让result指向当前head所指向的位置。<br>最后更新一下head的位置，注意这时的head指向，不能使用head = head.next要用head = temp来更新head位置。<br>最后返回result即可。</p>
<p>这里说明一下result的初始值必须为None，因为反转后的链表的最后一项（也就是反转前的第一项）必须指向None。<br>result指针在第一次循环开始后，就紧跟在head的前面。</p>
<p>算法时间复杂度是O(n)，空间复杂度是O(1)。</p>
</div>

<div class="alert info no-icon"><p>思路二：<br>递归。递归的解法有点不好想。首先想，递归要什么时候返回值合适，应该是head.next为空的时候我们需要返回head的值，不能等到head为空了再返回，因为我们要保证head.next不为空才能进行反转。</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; None<br>拿上面的链表举例。刚开始head在1的位置，当进行递归时head的位置应该在5。反转时，我们还需要知道前一个节点，所以head应该在4的位置。给递归函数需要传head.next，这样既保证了递归，也保证了在head到4位置时，返回值是5 -&gt; None这个链表。<br>此时的head的值为 4 —&gt; 5 -&gt; None。返回值后我们知道需要反转了。<br>首先让5 -&gt; 4，head.next.next = head，<br>再将4 -&gt; 5之间的联系断开，不然有环。head.next = None<br>就得到了5 -&gt; 4。</p>
<p>当head为空时，直接返回head。</p>
<p>算法时间复杂度是O(n)，空间复杂度是O(n)。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 循环</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        result = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            temp = head.<span class="built_in">next</span></span><br><span class="line">            head.<span class="built_in">next</span> = result</span><br><span class="line">            result = head</span><br><span class="line">            head = temp</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList_2</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        result = self.reverseList_2(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><p>删除链表中等于给定值 val 的所有节点。</p>
<div class="alert info no-icon"><p>思路：<br>定义两个指针result和pre，它们的next都指向head。遍历pre，当pre.next不为空时，判断pre.next.val和val的值是否一致，如果一致，pre.next被删除掉，pre.next = pre.next.next，不一致，pre前进一步，pre = pre.next。循环结束后result.next即所求。</p>
<p>主要考虑到删除当前元素时，需要知道前一个元素的指针才能删除。所以要，pre.next = head。</p>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = pre = ListNode(<span class="literal">None</span>)</span><br><span class="line">        pre.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">while</span> pre.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> pre.<span class="built_in">next</span>.val == val:</span><br><span class="line">                pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h3><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。<br>请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<div class="alert info no-icon"><p>思路：<br>定义两个ListNode，odd（奇）和even（偶），和他们各自的head，odd_head和even_head。<br>遍历链表head，第一次循环时，链表的第一项默认是奇数项，所以odd.next = head, odd前进一步odd = odd.next。<br>链表的第一项默认是奇数项，第二项就是偶数项，所以even的下一项就是head.next，even.next = head.next，even前进一步。<br>这时候，head应该前进两步，要使用head = head.next.next，但是当head.next为空时（遍历到最后一项），会出错，这时应该直接将head置为空。<br>循环结束后，得到两条链表，odd_head和even_head。将even_head接在odd_head后就好了。odd.next = odd_head.next<br>odd_head.next即所得。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oddEvenList</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        odd = odd_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        even = even_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            odd.<span class="built_in">next</span> = head</span><br><span class="line">            odd = odd.<span class="built_in">next</span></span><br><span class="line">            even.<span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">            even = even.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            head = head.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">if</span> even <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        odd.<span class="built_in">next</span> = even_head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> odd_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><p>判断一个链表是否为回文链表。</p>
<div class="alert info no-icon"><p>思路一：<br>遍历链表，然后利用数组存放链表的值。最后判断数组是否是回文就可以了。此方法的算法时间复杂度是O(n)，空间复杂度也是O(n)，因为开辟了链表大小的数组。</p>
</div>

<div class="alert info no-icon"><p>思路二：<br>类似反转链表。例如，链表<br>1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; None<br>我们只需要将1 -&gt; 2 -&gt; 3的链表反转，再和剩下的链表进行比较，就可以了。<br>定义一个快指针fast，一个慢指针slow， 一个控制反转的指针x。快指针一次走两步，慢指针一次走一步。<br>遍历链表，要保证fast和fast.next不为空，这时进行链表的反转操作。当循环结束时，fast指针可能在最后一个或者倒数第二个的位置即fast为空或者fast.next为空，这是由于链表长度有奇有偶导致的。所以当fast不为空时（链表项为奇数项），我们将slow后移动一步，slow = slow.next。这样我们就将链表从中间分开，得到一个slow链表，一个x链表（经过反转）。<br>slow：2 -&gt; 1 -&gt; None<br>x：2 -&gt; 1 -&gt; None<br>反转链表时，x所指的位置一直是都是slow的前一项。<br>再遍历链表slow判断值是否和x链表一致就可以得出是否是回文链表了。</p>
<p>算法时间复杂度是O(n)，空间复杂度是O(1)。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        values = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            values.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> values == values[::-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">isPalindrome_2</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        fast = slow = head</span><br><span class="line">        x = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            temp = slow.<span class="built_in">next</span></span><br><span class="line">            slow.<span class="built_in">next</span> = x</span><br><span class="line">            x = slow</span><br><span class="line">            slow = temp</span><br><span class="line">        <span class="keyword">if</span> fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> slow:</span><br><span class="line">            <span class="keyword">if</span> slow.val != x.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            x = x.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双链表中节点的定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyListNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>如果我们想在现有的结点prev之后，next之前插入一个新的结点cur，我们可以将此过程分为两个步骤：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cur.pre = prev</span><br><span class="line">cur.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">prev.<span class="built_in">next</span> = cur</span><br><span class="line"><span class="built_in">next</span>.pre = cur</span><br></pre></td></tr></table></figure>

<div class="alert info no-icon"><p>与单链表类似，添加操作的时间和空间复杂度都是O(1)。</p>
</div>

<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>删除之前添加在prev和next之间的节点cur。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prev.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="built_in">next</span>.pre = prev</span><br></pre></td></tr></table></figure>
<div class="alert info no-icon"><p>删除操作的时间和空间复杂度都是O(1)。</p>
</div>


<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>单链表和双链表相同点。</p>
<div class="alert info no-icon"><p>它们都无法在常量时间内随机访问数据。<br>它们都能够在O(1)时间内在给定结点之后或列表开头添加一个新结点。<br>它们都能够在O(1)时间内删除第一个结点。</p>
</div>

<p>再删除节点上，单链表和双链表稍有不同。</p>
<div class="alert info no-icon"><p>在单链表中，它无法获取给定结点的前一个结点，因此在删除给定结点之前我们必须花费O(N)时间来找出前一结点。<br>在双链表中，这会更容易，因为可以使用pre获取前一个结点。因此可以在O(1)时间内删除给定结点。</p>
</div>

<h3 id="时间复杂度对照"><a href="#时间复杂度对照" class="headerlink" title="时间复杂度对照"></a>时间复杂度对照</h3><div class="figure " style="width:;"><a class="fancybox" href="images/linked_list.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="images/linked_list.png" alt=""></a></div>

<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1, l2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = temp = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                temp.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        temp.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h3><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1, l2</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            :type l1: ListNode</span></span><br><span class="line"><span class="string">            :type l2: ListNode</span></span><br><span class="line"><span class="string">            :rtype: ListNode</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            result = pre = ListNode(<span class="literal">None</span>)</span><br><span class="line">            carry = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">                <span class="keyword">if</span> l1:</span><br><span class="line">                    carry += l1.val</span><br><span class="line">                    l1 = l1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> l2:</span><br><span class="line">                    carry += l2.val</span><br><span class="line">                    l2 = l2.<span class="built_in">next</span></span><br><span class="line">                pre.<span class="built_in">next</span> = ListNode(carry % <span class="number">10</span>)</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">                carry //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> result.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动k个位置，其中k是非负数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateRight</span>(<span class="params">self, head, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        x = y = head</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> x.<span class="built_in">next</span>:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            x = x.<span class="built_in">next</span></span><br><span class="line">        x.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - k % n - <span class="number">1</span>):</span><br><span class="line">            y = y.<span class="built_in">next</span></span><br><span class="line">        result = y.<span class="built_in">next</span></span><br><span class="line">        y.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是先进先出（FIFO）的数据结构。</p>
<p>插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。删除（delete）操作也被称为出队（dequeue)。你只能移除第一个元素。</p>
<p>按顺序处理元素时，使用队列可能是一个很好的选择。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>普通队列，在存储变量时，会出现假溢出的情况，为了充分利用存储空间，克服这一现象，循环队列应运而生。</p>
<div class="alert info no-icon"><p>假溢出。<br>系统作为队列用的存储区还没有满,但队列却发生了溢出,我们把这种现象称为”假溢出”。</p>
<p>解决方法：</p>
<ol>
<li>将队列元素向前“平移”。</li>
<li>将队列看成首尾相连，即循环队列。</li>
</ol>
</div>

<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here. Set the size of the queue to be k.</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.k = k + <span class="number">1</span></span><br><span class="line">        self.q = [<span class="literal">None</span>] * self.k</span><br><span class="line">        self.head = self.tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enQueue</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Insert an element into the circular queue. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.q[self.tail] = value</span><br><span class="line">        self.tail = (self.tail - <span class="number">1</span>) % self.k</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deQueue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Delete an element from the circular queue. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.head = (self.head - <span class="number">1</span>) % self.k</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front item from the queue.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.q[self.head]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Rear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the last item from the queue.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.q[(self.tail + <span class="number">1</span>) % self.k]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks whether the circular queue is empty or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.head == self.tail</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isFull</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks whether the circular queue is full or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (self.head + <span class="number">1</span>) % self.k == self.tail</span><br></pre></td></tr></table></figure>
<h2 id="Python中的队列"><a href="#Python中的队列" class="headerlink" title="Python中的队列"></a>Python中的队列</h2><p>Python标准库中包含了四种队列，分别是queue.Queue、asyncio.Queue、multiprocessing.Queue和collections.deque。这里只讨论collections.deque。</p>
<p>collections.deque是双端队列（double-ended queue）的缩写，由于两端都能编辑，deque既可以用来实现栈（stack）也可以用来实现队列（queue）。</p>
<p>deque支持丰富的操作方法。</p>
<div class="figure center" style="width:;"><img class="fig-img" src="images/queue.png" alt=""></div>

<p>相比于list实现的队列，deque实现拥有更低的时间和空间复杂度。list实现在出队和入队时的空间复杂度大约为O(n)，deque在出队和入队时的时间复杂度是O(1)。</p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索（Breadth First Search）简称BFS，其中一个应用就是找到根节点距离目标节点的最短路径。最近接根节点的节点最先遍历。</p>
<p>在第k轮中将节点x添加到队列中，则根节点和节点x之间的最短距离刚好是k。</p>
<p>广度优先搜索遍历时，首先将根节点加入队列中，随后将临近根节点的节点依次加入到队列中，并将根节点推出队列，以此类推，新添加的节点不会被立即处理，而是被添加到队列的末尾，等待下一轮的处理。</p>
<p>节点的添加到队列的顺序和它们被处理的顺序完全相同，即先进先出（FIFO）。这是在BFS中应用队列的主要原因。</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>模板一。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">node, target</span>):</span><br><span class="line">    <span class="comment"># store all nodes which are waiting to be processed</span></span><br><span class="line">    queue = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># number of steps neeeded from root to current node</span></span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize</span></span><br><span class="line">    <span class="comment"># add root to queue;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># find neighbors</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">if</span> item == target:</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> neighbors(item):</span><br><span class="line">                queue.append(n)</span><br><span class="line">            queue.popleft()</span><br><span class="line">    <span class="comment"># there is no path from root to target</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>模板二。<br>确保不会访问一个结点两次。可以在上面的代码中添加一个哈希集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">node, target</span>):</span><br><span class="line">    <span class="comment"># store all nodes which are waiting to be processed</span></span><br><span class="line">    queue = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># number of steps neeeded from root to current node</span></span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    used = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize</span></span><br><span class="line">    <span class="comment"># add root to queue;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># find neighbors</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">if</span> item == target:</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> neighbors(item):</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> used:</span><br><span class="line">                    used.add(n)</span><br><span class="line">                    queue.append(n)</span><br><span class="line">            queue.popleft()</span><br><span class="line">    <span class="comment"># there is no path from root to target</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<div class="alert info no-icon"><p>有两种情况你不需要使用哈希集：</p>
<ol>
<li>确定没有循环，例如，在树遍历中；</li>
<li>希望多次将结点添加到队列中。</li>
</ol>
</div>

<h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><p>一个由’1’（陆地）和’0’（水）组成的的二维网格，计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，可以假设该网格的四条边均被水包围。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        islands = <span class="number">0</span></span><br><span class="line">        rows = <span class="built_in">len</span>(grid)</span><br><span class="line">        cols = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    islands += <span class="number">1</span></span><br><span class="line">                    grid[r][c] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    queue = collections.deque([(r, c)])</span><br><span class="line">                    <span class="keyword">while</span> queue:</span><br><span class="line">                        row, col = queue.popleft()</span><br><span class="line">                        <span class="keyword">if</span> row - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[row - <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            queue.append((row - <span class="number">1</span>, col))</span><br><span class="line">                            grid[row - <span class="number">1</span>][col] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                        <span class="keyword">if</span> row + <span class="number">1</span> &lt; rows <span class="keyword">and</span> grid[row + <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            queue.append((row + <span class="number">1</span>, col))</span><br><span class="line">                            grid[row + <span class="number">1</span>][col] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                        <span class="keyword">if</span> col - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[row][col - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            queue.append((row, col - <span class="number">1</span>))</span><br><span class="line">                            grid[row][col - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                        <span class="keyword">if</span> col + <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[row][col + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            queue.append((row, col + <span class="number">1</span>))</span><br><span class="line">                            grid[row][col + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> islands</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="打开转盘锁"><a href="#打开转盘锁" class="headerlink" title="打开转盘锁"></a>打开转盘锁</h3><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字：’0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把’9’变为’0’，’0’变为’9’。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为’0000’ ，一个代表四个拨轮的数字的字符串。</p>
<p>列表deadends包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串target代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">openLock</span>(<span class="params">self, deadends, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type deadends: List[str]</span></span><br><span class="line"><span class="string">        :type target: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> (-<span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">                    x = (<span class="built_in">int</span>(node[i]) + x ) % <span class="number">10</span></span><br><span class="line">                    <span class="keyword">yield</span> node[:i] + <span class="built_in">str</span>(x) + node[i+<span class="number">1</span>:]</span><br><span class="line">        dead = <span class="built_in">set</span>(deadends)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;0000&#x27;</span> <span class="keyword">in</span> dead:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        queue = collections.deque([(<span class="string">&#x27;0000&#x27;</span>, <span class="number">0</span>)])</span><br><span class="line">        seen = &#123; <span class="string">&#x27;0000&#x27;</span> &#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, step = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node == target:</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> dead:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> neighbors(node):</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(n)</span><br><span class="line">                    queue.append((n, step + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p>给定正整数n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于n。你需要让组成和的完全平方数的个数最少。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。</span></span><br><span class="line"><span class="string">        推论：满足四数平方和定理的数n（四个整数的情况），必定满足 n=(4^a)(8b+7)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> n % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            n /= <span class="number">4</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">8</span> == <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> a ** <span class="number">2</span> &lt;= n:</span><br><span class="line">            b = <span class="built_in">int</span>((n - a ** <span class="number">2</span>) ** <span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">if</span> a ** <span class="number">2</span> + b ** <span class="number">2</span> == n:</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">not</span> <span class="keyword">not</span> a) + (<span class="keyword">not</span> <span class="keyword">not</span> b)</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>


<h3 id="01-矩阵"><a href="#01-矩阵" class="headerlink" title="01 矩阵"></a>01 矩阵</h3><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。<br>解法一。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">updateMatrix</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        deltas = [</span><br><span class="line">            (<span class="number">1</span>, <span class="number">0</span> ), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">        ]</span><br><span class="line">        unknown = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[r][c] == <span class="number">1</span>:</span><br><span class="line">                    unknown.add((r, c))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> unknown:</span><br><span class="line">            new_unknown = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> r, c <span class="keyword">in</span> unknown:</span><br><span class="line">                <span class="keyword">for</span> dr, dc <span class="keyword">in</span> deltas:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= dr + r &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= dc + c &lt; cols <span class="keyword">and</span> (dr + r, dc + r) <span class="keyword">not</span> <span class="keyword">in</span> unkonwn:</span><br><span class="line">                        matrix[r][c] = matrix[dr + r][dc + c] + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    new_unknown.add((r, c))</span><br><span class="line">            unknown = new_unknown</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:;"><img class="fig-img" src="images/cut.png" alt="我有骄傲吗？"><span class="caption">我有骄傲吗？</span></div>

<p>解法二。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">updateMatrix</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        deltas = [ (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        max_dist = rows + cols - <span class="number">1</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[r][c] == <span class="number">1</span>:</span><br><span class="line">                    matrix[r][c] = max_dist</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    queue.append((r, c))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            r, c = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> dr, dc <span class="keyword">in</span> deltas:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= dr + r &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= dc + c &lt; cols: </span><br><span class="line">                    <span class="keyword">if</span> matrix[r][c] + <span class="number">1</span> &lt; matrix[r + dr][c + dc]:</span><br><span class="line">                        matrix[dr + r][dc + c] = matrix[r][c] + <span class="number">1</span></span><br><span class="line">                        queue.append((dr + r, dc + c))</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是先入后出（LIFO）的数据结构。</p>
<p>在LIFO数据结构中，将首先处理添加到队列中的最新元素。<br>与队列不同，栈是一个LIFO数据结构。通常，插入操作在栈中被称作入栈（push）。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈（pop），始终删除最后一个入栈的元素。</p>
<h2 id="经典问题-1"><a href="#经典问题-1" class="headerlink" title="经典问题"></a>经典问题</h2><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">match</span> = &#123;</span><br><span class="line">            <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="keyword">match</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> <span class="keyword">match</span>[stack.pop()] != c:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>

<h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p>请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用0来代替。</p>
<p>例如，给定一个列表temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，输出应该是[1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温列表长度的范围是[1, 30000]。每个气温的值的均为华氏度，都是在[30, 100]范围内的整数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, T</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type T: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stack = []</span><br><span class="line">        result = [<span class="number">0</span>] * <span class="built_in">len</span>(T)</span><br><span class="line">        <span class="keyword">for</span> i, temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(T):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> T[stack[-<span class="number">1</span>]] &lt; temp:</span><br><span class="line">                result[stack.pop()] = i - stack[-<span class="number">1</span>]</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><p>根据逆波兰表示法，求表达式的值。<br>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：<br>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如( 1 + 2 ) * ( 3 + 4 )。<br>该算式的逆波兰表达式写法为( ( 1 2 + ) ( 3 4 + ) * )。<br>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type tokens: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        opts = &#123;</span><br><span class="line">            <span class="string">&#x27;+&#x27;</span>: <span class="keyword">lambda</span> x, y: x + y,</span><br><span class="line">            <span class="string">&#x27;-&#x27;</span>: <span class="keyword">lambda</span> x, y: y - x,</span><br><span class="line">            <span class="string">&#x27;*&#x27;</span>: <span class="keyword">lambda</span> x, y: x * y,</span><br><span class="line">            <span class="string">&#x27;/&#x27;</span>: <span class="keyword">lambda</span> x, y: <span class="built_in">int</span>( y * <span class="number">1.0</span> / x )</span><br><span class="line">        &#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> opts:</span><br><span class="line">                stack.append(opts[c](stack.pop(),stack.pop()))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(c))</span><br><span class="line">        <span class="keyword">return</span> stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>查找从根结点到目标结点的路径时，结点的处理和添加完全相反的顺序，后进先出，这就是DFS中使用栈的原因。</p>
<h3 id="模板一-递归"><a href="#模板一-递归" class="headerlink" title="模板一 递归"></a>模板一 递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">cur</span>):</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">cur, target, visited</span>):</span><br><span class="line">    <span class="keyword">if</span> cur == target:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> next_node <span class="keyword">in</span> neighbors(cur):</span><br><span class="line">        <span class="keyword">if</span> next_node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.add(next_node)</span><br><span class="line">            <span class="keyword">if</span> DFS(next_node, target, visited):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<div class="alert info no-icon"><p>当我们递归地实现DFS时，似乎不需要使用任何栈。<br>但实际上，我们使用的是由系统提供的隐式栈，也称为调用栈（Call Stack）。<br>在最坏的情况下，维护系统栈需要O(h)，其中h是DFS的最大深度。</p>
</div>


<h3 id="岛屿数量-1"><a href="#岛屿数量-1" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><p>一个由’1’（陆地）和’0’（水）组成的的二维网格，计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，可以假设该网格的四条边均被水包围。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rows = <span class="built_in">len</span>(grid)</span><br><span class="line">        cols = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        islands = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    islands += <span class="number">1</span></span><br><span class="line">                    self.set_island(r, c, grid)</span><br><span class="line">        <span class="keyword">return</span> islands</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_island</span>(<span class="params">self, row, col, grid</span>):</span><br><span class="line">        <span class="keyword">if</span> row &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> col &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> grid[row][col] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        grid[row][col] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        self.set_island(row + <span class="number">1</span>, col, grid)</span><br><span class="line">        self.set_island(row - <span class="number">1</span>, col, grid)</span><br><span class="line">        self.set_island(row, col + <span class="number">1</span>, grid)</span><br><span class="line">        self.set_island(row, col - <span class="number">1</span>, grid)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="克隆图"><a href="#克隆图" class="headerlink" title="克隆图"></a>克隆图</h3><p>给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。</p>
<p>图中的每个节点都包含它的值val（int）和其邻居的列表（list[Node]）。</p>
<p>&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/clone-graph/">传送门</a> &lt;&lt;&lt;&lt;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, neighbors=[]</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.neighbors = neighbors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cloneGraph</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type node: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        cloned = Node(node.val, neighbors=[])</span><br><span class="line">        stack = [node]</span><br><span class="line">        mapping = &#123; node: cloned &#125;</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            cloned_node = mapping[node]</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> mapping:</span><br><span class="line">                    cloned_neighbor = Node(neighbor.val, neighbors=[])</span><br><span class="line">                    mapping[neighbor] = cloned_neighbor</span><br><span class="line">                    stack.append(neighbor)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cloned_neighbor = mapping[neighbor]</span><br><span class="line">                cloned_node.neighbors.append(cloned_neighbor)</span><br><span class="line">        <span class="keyword">return</span> cloned</span><br></pre></td></tr></table></figure>


<h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">传送门</a> &lt;&lt;&lt;&lt;</p>
<div class="alert info no-icon"><p>思路一， 递归：<br>使用递归，枚举出所有可能出现的情况，在处理到i个的数的时候，我们可以选择将它添加或者减除。当处理完nums列表时，计算出所有数的和，和目标数S进行判断。添加一个字典d，用于存储递归时出现的情况，d的key是（current，i），value是从起，到最后一个数，初始值是current时，目标值是S时，所能找到的所有的方法使得最后的数值等于S。</p>
</div>

<div class="alert info no-icon"><p>思路二， 01背包：<br>将这个数组nums看做成两部分，使用+的集合x，和使用-的集合y，则有sum(x) + sum(y) = sum(nums)，而且sum(x) - sum(y) = S，<br>所以sum(x) = (sum(nums) + S) // 2。就可以看成，已知一个数组，求有多少种方法，将容量为sum(x)的背包填满的问题了。</p>
<p>dp[0]为什么默认为1，因为当背包容量为0时，不需要任何操作就可以填满背包，可行解为1。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 递归</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums, S</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">current, i, d</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> (current, i) <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[(current, i)] = dfs(current + nums[i], i + <span class="number">1</span>, d) + dfs(current - nums[i], i + <span class="number">1</span>, d)</span><br><span class="line">            <span class="keyword">return</span> d.get((current, i), <span class="built_in">int</span>(current == S))</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 01背包</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays_2</span>(<span class="params">self, nums, S</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(nums) &lt; S <span class="keyword">or</span> (<span class="built_in">sum</span>(nums) + S ) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        half = (<span class="built_in">sum</span>(nums) + S) // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(half)]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(half, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># i代表背包容量</span></span><br><span class="line">                <span class="comment"># i - num 代表将num放进背包</span></span><br><span class="line">                dp[i] += dp[i - num]</span><br><span class="line">        <span class="keyword">return</span> dp[half]</span><br></pre></td></tr></table></figure>

<h3 id="模板二-栈"><a href="#模板二-栈" class="headerlink" title="模板二 栈"></a>模板二 栈</h3><p>显式的栈。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">cur</span>):</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">root, target</span>):</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    <span class="comment"># add root to stack</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> cur == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> neighbors(cur):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                visited.add(node)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">                <span class="keyword">while</span> node:</span><br><span class="line">                    stack.append(node)</span><br><span class="line">                    node = node.left</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的encoded_string正好重复k次。注意k保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，可以认为原始数据不包含数字，所有的数字只表示重复的次数k，例如不会出现像3a或2[4]的输入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodeString</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        stack = []</span><br><span class="line">        result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        multi = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.append((multi, result))</span><br><span class="line">                result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                multi = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                m, res = stack.pop()</span><br><span class="line">                result = res + m * result</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                multi = <span class="number">10</span> * multi + <span class="built_in">int</span>(c)</span><br><span class="line">            esle:</span><br><span class="line">                result += c</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="图像渲染"><a href="#图像渲染" class="headerlink" title="图像渲染"></a>图像渲染</h3><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在0到65535之间。</p>
<p>给一个坐标(sr, sc)表示图像渲染开始的像素值（行 ，列）和一个新的颜色值newColor，重新上色这幅图像。</p>
<p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p>
<p>最后返回经过上色渲染后的图像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">floodFill</span>(<span class="params">self, image, sr, sc, newColor</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type image: List[List[int]]</span></span><br><span class="line"><span class="string">        :type sr: int</span></span><br><span class="line"><span class="string">        :type sc: int</span></span><br><span class="line"><span class="string">        :type newColor: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        old_Color = image[sr][sc]</span><br><span class="line">        <span class="keyword">if</span> old_Color == newColor:</span><br><span class="line">            <span class="keyword">return</span> image</span><br><span class="line">        </span><br><span class="line">        rows = <span class="built_in">len</span>(image)</span><br><span class="line">        cols = <span class="built_in">len</span>(images)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">row, col, image</span>):</span><br><span class="line">            <span class="keyword">if</span> row &gt;= rows <span class="keyword">or</span> col &gt;= cols <span class="keyword">or</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> col &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> image[row][col] != old_color <span class="keyword">or</span> image[row][col] == newColor:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            image[row][col] = newColor</span><br><span class="line">            bfs(row + <span class="number">1</span>, col, image)</span><br><span class="line">            bfs(row - <span class="number">1</span>, col, image)</span><br><span class="line">            bfs(row, col + <span class="number">1</span>, image)</span><br><span class="line">            bfs(row, col - <span class="number">1</span>, image)</span><br><span class="line">        bfs(sr, sc, image)</span><br><span class="line">        <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>

<h3 id="钥匙和房间"><a href="#钥匙和房间" class="headerlink" title="钥匙和房间"></a>钥匙和房间</h3><p>有 N 个房间，开始时你位于0号房间。每个房间有不同的号码：0，1，2，…，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。</p>
<p>在形式上，对于每个房间i都有一个钥匙列表rooms[i]，每个钥匙rooms[i][j]由[0,1，…，N-1]中的一个整数表示，其中N = rooms.length。钥匙rooms[i][j] = v可以打开编号为v的房间。</p>
<p>最初，除0号房间外的其余所有房间都被锁住。</p>
<p>你可以自由地在房间之间来回走动。如果能进入每个房间返回true，否则返回false。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canVisitAllRooms</span>(<span class="params">self, rooms</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type rooms: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        seen = [<span class="literal">False</span>] * <span class="built_in">len</span>(rooms)</span><br><span class="line">        seen[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        stack = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> rooms[node]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> seen[neighbor]:</span><br><span class="line">                    seen[neighbor] = <span class="literal">True</span></span><br><span class="line">                    stack.append(neighbor)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(seen)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>树是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。</p>
<p>树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N个节点和N-1条边的一个有向无环图。</p>
<p>二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p>
<div class="alert info no-icon"><p>节点的深度 - 从树的根节点到该节点的边数<br>节点的高度 - 该节点和叶子之间最长路径上的边数<br>树的高度 - 其根节点的高度</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 输出前序遍历</span></span><br><span class="line">        nodes = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                nodes.append(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nodes.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">                preorder(node.left)</span><br><span class="line">                preorder(node.right)</span><br><span class="line"></span><br><span class="line">        preorder(self)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;, &#x27;</span>.join(nodes)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">cls, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param nums: 前序遍历</span></span><br><span class="line"><span class="string">        :type nums: list</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nodes = deque(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">build</span>():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nodes:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = nodes.popleft()</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = TreeNode(node)</span><br><span class="line">            node.left = build()</span><br><span class="line">            node.right = build()</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> build()</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><div class="alert info no-icon"><p>前序遍历<br>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p>
<p>中序遍历<br>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。</p>
<p>后序遍历<br>后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。</p>
</div>

<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 迭代</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="comment"># 递归</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal2</span>(<span class="params">self, root</span>):</span><br><span class="line">        result = []</span><br><span class="line">        self.dfs(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, node, result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:    </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        result.append(node.val)</span><br><span class="line">        self.dfs(node.left, result)</span><br><span class="line">        self.dfs(node.right, result)</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">                <span class="keyword">while</span> node:</span><br><span class="line">                    stack.append(node)</span><br><span class="line">                    node = node.left</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal2</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        self.dfs(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, node, result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(node.left, result)</span><br><span class="line">        result.append(node.val)</span><br><span class="line">        self.dfs(node.right, result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = collections.deque()</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.appendleft(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal2</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        self.dfs(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, node, result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(node.left, result)</span><br><span class="line">        self.dfs(node.right, result)</span><br><span class="line">        result.append(node.val)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p>给一个二叉树，返回其按层序遍历得到的节点值。（即逐层地，从左到右访问所有节点）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        nodes = [root]</span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            new_nodes = []</span><br><span class="line">            result.append([])</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">                result[-<span class="number">1</span>].append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    new_nodes.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    new_nodes.append(node.right)</span><br><span class="line">            nodes = new_nodes</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root.left, root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, left_node, right_node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left_node <span class="keyword">and</span> <span class="keyword">not</span> right_node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left_node <span class="keyword">or</span> <span class="keyword">not</span> right_node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> left_node.val != right_node.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(left_node.left, right_node.right) <span class="keyword">and</span> self.dfs(left_node.right, right_node.left)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric2</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.dequeue([(root.left, root.right)])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            l, r = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">or</span> <span class="keyword">not</span> r <span class="keyword">or</span> l.val != r.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append((l.left, r.right))</span><br><span class="line">            queue.append((l.right, r.left))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root, <span class="built_in">sum</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type sum: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="built_in">sum</span> -= root.val</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span> == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, <span class="built_in">sum</span>) <span class="keyword">or</span> self.hasPathSum(root.right, <span class="built_in">sum</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder, postorder</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        index = inorder.index(postorder.pop())</span><br><span class="line">        root = TreeNode(inorder[index])</span><br><span class="line"></span><br><span class="line">        root.right = self.buildTree(inorder[index + <span class="number">1</span>:], postorder)</span><br><span class="line">        root.left = self.buildTree(inorder[:index], postorder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h3><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder, inorder</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        index = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:index + <span class="number">1</span>], inorder[:index])</span><br><span class="line">        root.right = self.buildTree(preorder[index + <span class="number">1</span>:], inorder[index + <span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree2</span>(<span class="params">self, preorder, inorder</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">stop=<span class="literal">None</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> inorder[-<span class="number">1</span>] == stop:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            val = preorder.pop()</span><br><span class="line">            root = TreeNode(val)</span><br><span class="line">            root.left = build(val)</span><br><span class="line">            inorder.pop()</span><br><span class="line">            root.right = build(stop)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        preorder.reverse()</span><br><span class="line">        inorder.reverse()</span><br><span class="line">        <span class="keyword">return</span> build()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h3><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<div class="alert info no-icon"><p>完美二叉树。<br>一个深度为k(&gt;=-1)且有2^(k+1) - 1个结点的二叉树称为完美二叉树，换句话说：树是满的，还是二叉的。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">  val = <span class="built_in">int</span></span><br><span class="line">  left = Node</span><br><span class="line">  right = Node</span><br><span class="line">  <span class="built_in">next</span> = Node</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>填充它的每个next指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将next指针设置为NULL。</p>
<p>初始状态下，所有next指针都被设置为NULL。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        level = [root]</span><br><span class="line">        <span class="keyword">while</span> level <span class="keyword">and</span> level[<span class="number">0</span>]:</span><br><span class="line">            next_level = []</span><br><span class="line">            prev = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> level:</span><br><span class="line">                <span class="keyword">if</span> prev:</span><br><span class="line">                    prev.<span class="built_in">next</span> = node</span><br><span class="line">                prev = node</span><br><span class="line">                level.append(node.left)</span><br><span class="line">                level.append(node.right)</span><br><span class="line">            level = next_level</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect2</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            root.left.<span class="built_in">next</span> = root.right</span><br><span class="line">            <span class="keyword">if</span> root.<span class="built_in">next</span>:</span><br><span class="line">                root.right.<span class="built_in">next</span> = root.<span class="built_in">next</span>.left</span><br><span class="line">        self.connect2(root.left)</span><br><span class="line">        self.connect2(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="填充每个节点的下一个右侧节点指针-II"><a href="#填充每个节点的下一个右侧节点指针-II" class="headerlink" title="填充每个节点的下一个右侧节点指针 II"></a>填充每个节点的下一个右侧节点指针 II</h3><p>给定一个二叉树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">  val = <span class="built_in">int</span></span><br><span class="line">  left = Node</span><br><span class="line">  right = Node</span><br><span class="line">  <span class="built_in">next</span> = Node</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>填充它的每个next指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将next指针设置为NULL。</p>
<p>初始状态下，所有next指针都被设置为 NULL。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        level = [root]</span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            next_level = []</span><br><span class="line">            prev = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> level:</span><br><span class="line">                <span class="keyword">if</span> prev:</span><br><span class="line">                    prev.<span class="built_in">next</span> = node</span><br><span class="line">                prev = node</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    next_level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    next_level.append(node.right)</span><br><span class="line">            level = next_level</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<div class="alert info no-icon"><p>最近公共祖先<br>对于有根树T的两个结点p、q，最近公共祖先表示为一个结点x，满足x是p、q的祖先且x的深度尽可能大（一个节点也可以是它自己的祖先）。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> p == root <span class="keyword">or</span> q == root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>设计一个算法来实现二叉树的序列化与反序列化。这里不限定序列/反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nodes = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                nodes.append(<span class="string">&#x27;null&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nodes.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">                preorder(node.left)</span><br><span class="line">                preorder(node.right)</span><br><span class="line">        </span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(nodes)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nodes = collections.deque(data.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">build</span>()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nodes:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = nodes.popleft()</span><br><span class="line">            <span class="keyword">if</span> node == <span class="string">&#x27;null&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = TreeNode(node)</span><br><span class="line">            node.left = build()</span><br><span class="line">            node.right = build()</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> build()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二叉搜索树（BST）是二叉树的一种特殊表示形式，它满足如下特性：</p>
<p>每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值。<br>每个节点中的值必须小于（或等于）存储在其右子树中的任何值。</p>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：<br>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.valid(root, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">valid</span>(<span class="params">self, node, l, r</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> node.val &lt;= l <span class="keyword">or</span> r &lt;= node.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.valid(node.left, l, node.val) <span class="keyword">and</span> self.valid(node.right, node.val, r)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树迭代器"><a href="#二叉搜索树迭代器" class="headerlink" title="二叉搜索树迭代器"></a>二叉搜索树迭代器</h2><p>实现一个二叉搜索树迭代器。使用二叉搜索树的根节点初始化迭代器。</p>
<p>调用next()将返回二叉搜索树中的下一个最小的数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="keyword">while</span> root: </span><br><span class="line">            self.stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        @return the next smallest number</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.stack()</span><br><span class="line">        result = node.val</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            node = node.right</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                self.stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasNext</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        @return whether we have a next smallest number</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> self.stack <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>给定二叉搜索树（BST）的根节点和一个值。需要在BST中找到节点值等于给定值的节点。返回以该节点为根的子树。如果节点不存在，则返回NULL。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST2</span>(<span class="params">self, root, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val == val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<h3 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h3><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。返回插入后二叉搜索树的根节点。保证原始二叉搜索树中不存在新值。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。可以返回任意有效的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        result = root</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left:</span><br><span class="line">                    root.left = node</span><br><span class="line">                    <span class="keyword">return</span> result</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                    root.right = node</span><br><span class="line">                    <span class="keyword">return</span> result</span><br><span class="line">                root = root.right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST2</span>(<span class="params">self, root, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">            root.left = self.insertIntoBST2(root.left, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right = self.insertIntoBST2(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><p>用一个合适的子节点来替换要删除的目标节点。根据其子节点的个数，需考虑以下三种情况：<br>1. 如果目标节点没有子节点，可以直接移除该目标节点。<br>2. 如果目标节只有一个子节点，可以用其子节点作为替换。<br>3. 如果目标节点有两个子节点，要用其中序后继节点或者前驱节点来替换，再删除该目标节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> key &gt; root.val:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">elif</span> key &lt; root.val:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(root.left <span class="keyword">and</span> root.right):</span><br><span class="line">                root = root.left <span class="keyword">or</span> root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                next_right = root.right</span><br><span class="line">                <span class="keyword">while</span> next_right.left:</span><br><span class="line">                    next_right = next_right.left</span><br><span class="line">                root.val = next_right.val</span><br><span class="line">                root.right = self.deleteNode(root.right, root.val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>二叉搜索树的优点是，即便在最坏的情况下，也允许在O(h)的时间复杂度内执行所有的搜索、插入、删除操作。</p>
<p>有序地存储数据或者需要同时执行搜索、插入、删除等多步操作，二叉搜索树这个数据结构是一个很好的选择。</p>
<h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><h3 id="数据流中的第K大元素"><a href="#数据流中的第K大元素" class="headerlink" title="数据流中的第K大元素"></a>数据流中的第K大元素</h3><p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p>
<p>KthLargest类需要一个同时接收整数k和整数数组nums的构造器，它包含数据流中的初始元素。每次调用KthLargest.add，返回当前数据流中第K大的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        heapq.heapfiy(nums)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(nums) &gt; k:</span><br><span class="line">            heapq.heappop(nums)</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.nums) == self.k <span class="keyword">and</span> val &lt;= self.nums[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.nums[<span class="number">0</span>]</span><br><span class="line">        heapq.heappush(self.nums, val)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.nums) &gt; self.k:</span><br><span class="line">            heapq.heappop(self.nums)</span><br><span class="line">        <span class="keyword">return</span> self.nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<div class="alert info no-icon"><p>最近公共祖先<br>对于有根树T的两个结点p、q，最近公共祖先表示为一个结点x，满足x是p、q的祖先且x的深度尽可能大（一个节点也可以是它自己的祖先）。</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> q.val &gt; root.val <span class="keyword">and</span> p.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> q.val &lt; root.val <span class="keyword">and</span> p.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="存在重复元素-III"><a href="#存在重复元素-III" class="headerlink" title="存在重复元素 III"></a>存在重复元素 III</h3><p>在整数数组nums中，是否存在两个下标i和j，使得nums[i]和nums[j]的差的绝对值小于等于t ，且满足i和j的差的绝对值也小于等于k。</p>
<p>如果存在则返回true，不存在返回false。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums, k, t</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type t: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span> <span class="keyword">or</span> t &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        buckets = &#123;&#125;</span><br><span class="line">        bucket_size = t + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            num = nums[i] // bucket_size</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            buckets[num] = nums[i]</span><br><span class="line">            <span class="keyword">if</span> (num - <span class="number">1</span>) <span class="keyword">in</span> buckets <span class="keyword">and</span> <span class="built_in">abs</span>(buckets[num - <span class="number">1</span>] - num[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="number">1</span>) <span class="keyword">in</span> buckets <span class="keyword">and</span> <span class="built_in">abs</span>(buckets[num + <span class="number">1</span>] - num[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                buckets.pop(num[i-k] // bucket_size)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高度平衡的二叉搜索树"><a href="#高度平衡的二叉搜索树" class="headerlink" title="高度平衡的二叉搜索树"></a>高度平衡的二叉搜索树</h2><p>一个高度平衡的二叉搜索树（平衡二叉搜索树）是在插入和删除任何节点之后，可以自动保持其高度最小。也就是说，有N个节点的平衡二叉搜索树，它的高度是logN。并且，每个节点的两个子树的高度不会相差超过1。</p>
<p>一个高度为h的二叉树，节点数为：</p>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="31.866ex" height="2.23ex" role="img" focusable="false" viewBox="0 -903.7 14084.8 985.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path id="MJX-1-TEX-N-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path><path id="MJX-1-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><use data-c="30" xlink:href="#MJX-1-TEX-N-30"></use></g></g><g data-mml-node="mo" transform="translate(1158.8,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="msup" transform="translate(2159,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g><g data-mml-node="mo" transform="translate(3317.8,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="msup" transform="translate(4318,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><use data-c="33" xlink:href="#MJX-1-TEX-N-33"></use></g></g><g data-mml-node="mo" transform="translate(5254.5,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mo" transform="translate(6032.5,0)"><use data-c="2E" xlink:href="#MJX-1-TEX-N-2E"></use></g><g data-mml-node="mo" transform="translate(6477.2,0)"><use data-c="2E" xlink:href="#MJX-1-TEX-N-2E"></use></g><g data-mml-node="mo" transform="translate(6921.9,0)"><use data-c="2E" xlink:href="#MJX-1-TEX-N-2E"></use></g><g data-mml-node="mo" transform="translate(7366.5,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="msup" transform="translate(8144.5,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><use data-c="210E" xlink:href="#MJX-1-TEX-I-210E"></use></g></g><g data-mml-node="mo" transform="translate(9412.6,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="msup" transform="translate(10468.4,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="210E" xlink:href="#MJX-1-TEX-I-210E"></use></g><g data-mml-node="mo" transform="translate(576,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(1354,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g><g data-mml-node="mo" transform="translate(12584.6,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(13584.8,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g></svg></mjx-container>

<p>一个有N个节点，且高度为h的二叉树，满足：</p>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="13.208ex" height="2.357ex" role="img" focusable="false" viewBox="0 -903.7 5838 1041.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-1-TEX-N-2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D441" xlink:href="#MJX-1-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(1165.8,0)"><use data-c="2264" xlink:href="#MJX-1-TEX-N-2264"></use></g><g data-mml-node="msup" transform="translate(2221.6,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="210E" xlink:href="#MJX-1-TEX-I-210E"></use></g><g data-mml-node="mo" transform="translate(576,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(1354,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g><g data-mml-node="mo" transform="translate(4337.8,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(5338,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g></svg></mjx-container>

<p>所以，</p>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.788ex" height="2.593ex" role="img" focusable="false" viewBox="0 -896 4768.5 1146" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path><path id="MJX-1-TEX-N-2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path><path id="MJX-1-TEX-N-230A" d="M174 734Q174 735 175 737T177 740T180 744T184 747T189 749T196 750Q206 748 214 735V-210H310H373Q401 -210 411 -213T422 -230T411 -247T369 -251Q362 -251 338 -251T298 -250H190Q178 -246 174 -234V734Z"></path><path id="MJX-1-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-1-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-1-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-N-230B" d="M229 734Q229 735 230 737T232 740T235 744T239 747T244 749T251 750Q262 748 269 735V-235Q266 -240 256 -249L147 -250H77Q43 -250 32 -247T21 -230T32 -213T72 -209Q79 -209 99 -209T133 -210H229V734Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="210E" xlink:href="#MJX-1-TEX-I-210E"></use></g><g data-mml-node="mo" transform="translate(853.8,0)"><use data-c="2265" xlink:href="#MJX-1-TEX-N-2265"></use></g><g data-mml-node="mo" transform="translate(1909.6,0)"><use data-c="230A" xlink:href="#MJX-1-TEX-N-230A"></use></g><g data-mml-node="mi" transform="translate(2353.6,0)"><use data-c="1D459" xlink:href="#MJX-1-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(2651.6,0)"><use data-c="1D45C" xlink:href="#MJX-1-TEX-I-1D45C"></use></g><g data-mml-node="msubsup" transform="translate(3136.6,0)"><g data-mml-node="mi"><use data-c="1D454" xlink:href="#MJX-1-TEX-I-1D454"></use></g><g data-mml-node="mi" transform="translate(510,413) scale(0.707)"><use data-c="1D441" xlink:href="#MJX-1-TEX-I-1D441"></use></g><g data-mml-node="mn" transform="translate(510,-247) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g><g data-mml-node="mo" transform="translate(4324.5,0)"><use data-c="230B" xlink:href="#MJX-1-TEX-N-230B"></use></g></g></g></svg></mjx-container>

<h3 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.balanced(root) != -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">balanced</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.balanced(node.left)</span><br><span class="line">        right = self.balanced(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span> <span class="keyword">or</span> right == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.convert(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">self, nums, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.convert(left, mid - <span class="number">1</span>)</span><br><span class="line">        root.right = self.convert(mid + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>
            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/09/15/%E7%AE%97%E6%B3%95/"
                    data-tooltip="算法"
                    aria-label="PREVIOUS: 算法"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/06/17/Oh-my-zsh%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"
                    data-tooltip="Oh my zsh使用指南"
                    aria-label="NEXT: Oh my zsh使用指南"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
                    title="Share on Weibo"
                    aria-label="Share on Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&amp;title=数据结构"
                    title="Share on QQ"
                    aria-label="Share on QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
                    title="Share on Qzone"
                    aria-label="Share on Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>

<div class="main-content-wrap">
    
        
            <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
阅读量：<span id="2020/08/25/数据结构/" class="waline-visitor-count"></span>
<div id="vcomments"></div>
<script>
    new Waline({
        el: "#vcomments",
        serverURL: "https://blog-api-nu-nine.vercel.app/",
        lang: "zh-cn",
        visitor: true,
        emoji: [
            "https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili",
            "https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq",
        ],
        placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
        dark: "auto",
        meta: ["nick", "mail", "link"],
        requiredMeta: [],
        wordLimit: "200",
        pageSize: "10",
        highlight: "hanabi",
        copyright: true,
        avatar: "wavatar",
    });
</script>
  
        
    
</div>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 Wang kuntian. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/09/15/%E7%AE%97%E6%B3%95/"
                    data-tooltip="算法"
                    aria-label="PREVIOUS: 算法"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/06/17/Oh-my-zsh%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"
                    data-tooltip="Oh my zsh使用指南"
                    aria-label="NEXT: Oh my zsh使用指南"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
                    title="Share on Weibo"
                    aria-label="Share on Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&amp;title=数据结构"
                    title="Share on QQ"
                    aria-label="Share on QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
                    title="Share on Qzone"
                    aria-label="Share on Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
                        aria-label="Share on Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>Share on Weibo</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&amp;title=数据结构"
                        aria-label="Share on QQ"
                    >
                        <i class="fab fa-qq" aria-hidden="true"></i><span>Share on QQ</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://wangkuntian.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
                        aria-label="Share on Qzone"
                    >
                        <i class="fa fa-star" aria-hidden="true"></i><span>Share on Qzone</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/faker.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Wang kuntian</h4>
        
            <div id="about-card-bio"><p>Hi</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Software Engineer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Beijing
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-ndtc2tx33sr3grlppafri7aw03fwgxbruphsl7cntcdkym8tusuknerf6c0g.min.js"></script>

<!--SCRIPTS END-->


    




    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"display":{"superSample":2.5,"width":180,"height":400,"position":"right","hOffset":0,"vOffset":40},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":true,"hitokoto":false},"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hibiki.model.json"},"log":false});</script></body>
</html>
